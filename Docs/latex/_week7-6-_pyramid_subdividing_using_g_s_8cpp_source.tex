\doxysection{Week7-\/6-\/\+Pyramid\+Subdividing\+Using\+GS.cpp}
\label{_week7-6-_pyramid_subdividing_using_g_s_8cpp_source}\index{Week7/SubdividingTriangle/Week7-\/6-\/PyramidSubdividingUsingGS.cpp@{Week7/SubdividingTriangle/Week7-\/6-\/PyramidSubdividingUsingGS.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00002 \textcolor{comment}{// We are using geometry shader to subdivide our pyramid.  }}
\DoxyCodeLine{00003 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00004 }
\DoxyCodeLine{00005 \textcolor{preprocessor}{\#include "{}../../Common/d3dApp.h"{}}}
\DoxyCodeLine{00006 \textcolor{preprocessor}{\#include "{}../../Common/MathHelper.h"{}}}
\DoxyCodeLine{00007 \textcolor{preprocessor}{\#include "{}../../Common/UploadBuffer.h"{}}}
\DoxyCodeLine{00008 \textcolor{preprocessor}{\#include "{}../../Common/GeometryGenerator.h"{}}}
\DoxyCodeLine{00009 \textcolor{preprocessor}{\#include "{}FrameResource.h"{}}}
\DoxyCodeLine{00010 }
\DoxyCodeLine{00011 \textcolor{keyword}{using} Microsoft::WRL::ComPtr;}
\DoxyCodeLine{00012 \textcolor{keyword}{using namespace }DirectX;}
\DoxyCodeLine{00013 \textcolor{keyword}{using namespace }DirectX::PackedVector;}
\DoxyCodeLine{00014 }
\DoxyCodeLine{00015 \textcolor{preprocessor}{\#pragma comment(lib, "{}d3dcompiler.lib"{}})}
\DoxyCodeLine{00016 \textcolor{preprocessor}{\#pragma comment(lib, "{}D3D12.lib"{}})}
\DoxyCodeLine{00017 }
\DoxyCodeLine{00018 \textcolor{keyword}{const} \textcolor{keywordtype}{int} gNumFrameResources = 3;}
\DoxyCodeLine{00019 }
\DoxyCodeLine{00020 \textcolor{comment}{// Lightweight structure stores parameters to draw a shape.  This will}}
\DoxyCodeLine{00021 \textcolor{comment}{// vary from app-\/to-\/app.}}
\DoxyCodeLine{00022 \textcolor{keyword}{struct }RenderItem}
\DoxyCodeLine{00023 \{}
\DoxyCodeLine{00024     RenderItem() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{00025 }
\DoxyCodeLine{00026     \textcolor{comment}{// World matrix of the shape that describes the object's local space}}
\DoxyCodeLine{00027     \textcolor{comment}{// relative to the world space, which defines the position, orientation,}}
\DoxyCodeLine{00028     \textcolor{comment}{// and scale of the object in the world.}}
\DoxyCodeLine{00029     XMFLOAT4X4 World = MathHelper::Identity4x4();}
\DoxyCodeLine{00030 }
\DoxyCodeLine{00031     XMFLOAT4X4 TexTransform = MathHelper::Identity4x4();}
\DoxyCodeLine{00032 }
\DoxyCodeLine{00033     \textcolor{comment}{// Dirty flag indicating the object data has changed and we need to update the constant buffer.}}
\DoxyCodeLine{00034     \textcolor{comment}{// Because we have an object cbuffer for each FrameResource, we have to apply the}}
\DoxyCodeLine{00035     \textcolor{comment}{// update to each FrameResource.  Thus, when we modify obect data we should set }}
\DoxyCodeLine{00036     \textcolor{comment}{// NumFramesDirty = gNumFrameResources so that each frame resource gets the update.}}
\DoxyCodeLine{00037     \textcolor{keywordtype}{int} NumFramesDirty = gNumFrameResources;}
\DoxyCodeLine{00038 }
\DoxyCodeLine{00039     \textcolor{comment}{// Index into GPU constant buffer corresponding to the ObjectCB for this render item.}}
\DoxyCodeLine{00040     UINT ObjCBIndex = -\/1;}
\DoxyCodeLine{00041 }
\DoxyCodeLine{00042     Material* Mat = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00043     MeshGeometry* Geo = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00044 }
\DoxyCodeLine{00045     \textcolor{comment}{// Primitive topology.}}
\DoxyCodeLine{00046     D3D12\_PRIMITIVE\_TOPOLOGY PrimitiveType = D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{00047 }
\DoxyCodeLine{00048     \textcolor{comment}{// DrawIndexedInstanced parameters.}}
\DoxyCodeLine{00049     UINT IndexCount = 0;}
\DoxyCodeLine{00050     UINT StartIndexLocation = 0;}
\DoxyCodeLine{00051     \textcolor{keywordtype}{int} BaseVertexLocation = 0;}
\DoxyCodeLine{00052 \};}
\DoxyCodeLine{00053 }
\DoxyCodeLine{00054 \textcolor{keyword}{class }CrateApp : \textcolor{keyword}{public} D3DApp}
\DoxyCodeLine{00055 \{}
\DoxyCodeLine{00056 \textcolor{keyword}{public}:}
\DoxyCodeLine{00057     CrateApp(HINSTANCE hInstance);}
\DoxyCodeLine{00058     CrateApp(\textcolor{keyword}{const} CrateApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00059     CrateApp\& operator=(\textcolor{keyword}{const} CrateApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00060     \string~CrateApp();}
\DoxyCodeLine{00061 }
\DoxyCodeLine{00062     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} Initialize()\textcolor{keyword}{override};}
\DoxyCodeLine{00063 }
\DoxyCodeLine{00064 \textcolor{keyword}{private}:}
\DoxyCodeLine{00065     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnResize()\textcolor{keyword}{override};}
\DoxyCodeLine{00066     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Update(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00067     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Draw(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00068 }
\DoxyCodeLine{00069     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00070     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00071     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00072 }
\DoxyCodeLine{00073     \textcolor{keywordtype}{void} OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00074     \textcolor{keywordtype}{void} UpdateCamera(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00075     \textcolor{keywordtype}{void} AnimateMaterials(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00076     \textcolor{keywordtype}{void} UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00077     \textcolor{keywordtype}{void} UpdateMaterialCBs(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00078     \textcolor{keywordtype}{void} UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00079     \textcolor{keywordtype}{void} LoadTextures();}
\DoxyCodeLine{00080     \textcolor{keywordtype}{void} BuildRootSignature();}
\DoxyCodeLine{00081     \textcolor{keywordtype}{void} BuildDescriptorHeaps();}
\DoxyCodeLine{00082     \textcolor{keywordtype}{void} BuildShadersAndInputLayout();}
\DoxyCodeLine{00083     \textcolor{keywordtype}{void} BuildShapeGeometry();}
\DoxyCodeLine{00084     \textcolor{keywordtype}{void} BuildPSOs();}
\DoxyCodeLine{00085     \textcolor{keywordtype}{void} BuildFrameResources();}
\DoxyCodeLine{00086     \textcolor{keywordtype}{void} BuildMaterials();}
\DoxyCodeLine{00087     \textcolor{keywordtype}{void} BuildRenderItems();}
\DoxyCodeLine{00088     \textcolor{keywordtype}{void} DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems);}
\DoxyCodeLine{00089 }
\DoxyCodeLine{00090     std::array<const CD3DX12\_STATIC\_SAMPLER\_DESC, 6> GetStaticSamplers();}
\DoxyCodeLine{00091 }
\DoxyCodeLine{00092 \textcolor{keyword}{private}:}
\DoxyCodeLine{00093 }
\DoxyCodeLine{00094     std::vector<std::unique\_ptr<FrameResource>> mFrameResources;}
\DoxyCodeLine{00095     FrameResource* mCurrFrameResource = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00096     \textcolor{keywordtype}{int} mCurrFrameResourceIndex = 0;}
\DoxyCodeLine{00097 }
\DoxyCodeLine{00098     UINT mCbvSrvDescriptorSize = 0;}
\DoxyCodeLine{00099 }
\DoxyCodeLine{00100     ComPtr<ID3D12RootSignature> mRootSignature = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00101 }
\DoxyCodeLine{00102     ComPtr<ID3D12DescriptorHeap> mSrvDescriptorHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00103 }
\DoxyCodeLine{00104     std::unordered\_map<std::string, std::unique\_ptr<MeshGeometry>> mGeometries;}
\DoxyCodeLine{00105     std::unordered\_map<std::string, std::unique\_ptr<Material>> mMaterials;}
\DoxyCodeLine{00106     std::unordered\_map<std::string, std::unique\_ptr<Texture>> mTextures;}
\DoxyCodeLine{00107 }
\DoxyCodeLine{00108     std::unordered\_map<std::string, ComPtr<ID3DBlob>> mShaders;}
\DoxyCodeLine{00109 }
\DoxyCodeLine{00110     std::vector<D3D12\_INPUT\_ELEMENT\_DESC> mInputLayout;}
\DoxyCodeLine{00111 }
\DoxyCodeLine{00112     ComPtr<ID3D12PipelineState> mOpaquePSO = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00113     ComPtr<ID3D12PipelineState> mWireframePSO = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00114 }
\DoxyCodeLine{00115     \textcolor{comment}{// List of all the render items.}}
\DoxyCodeLine{00116     std::vector<std::unique\_ptr<RenderItem>> mAllRitems;}
\DoxyCodeLine{00117 }
\DoxyCodeLine{00118     \textcolor{comment}{// Render items divided by PSO.}}
\DoxyCodeLine{00119     std::vector<RenderItem*> mOpaqueRitems;}
\DoxyCodeLine{00120 }
\DoxyCodeLine{00121     PassConstants mMainPassCB;}
\DoxyCodeLine{00122 }
\DoxyCodeLine{00123     XMFLOAT3 mEyePos = \{ 0.0f, 0.0f, 0.0f \};}
\DoxyCodeLine{00124     XMFLOAT4X4 mView = MathHelper::Identity4x4();}
\DoxyCodeLine{00125     XMFLOAT4X4 mProj = MathHelper::Identity4x4();}
\DoxyCodeLine{00126 }
\DoxyCodeLine{00127     \textcolor{keywordtype}{float} mTheta = 1.3f * XM\_PI;}
\DoxyCodeLine{00128     \textcolor{keywordtype}{float} mPhi = 0.4f * XM\_PI;}
\DoxyCodeLine{00129     \textcolor{keywordtype}{float} mRadius = 2.5f;}
\DoxyCodeLine{00130 }
\DoxyCodeLine{00131     POINT mLastMousePos;}
\DoxyCodeLine{00132 }
\DoxyCodeLine{00133     \textcolor{keywordtype}{bool} mIsWireframe = \textcolor{keyword}{false};}
\DoxyCodeLine{00134 \};}
\DoxyCodeLine{00135 }
\DoxyCodeLine{00136 \textcolor{keywordtype}{int} WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance,}
\DoxyCodeLine{00137     PSTR cmdLine, \textcolor{keywordtype}{int} showCmd)}
\DoxyCodeLine{00138 \{}
\DoxyCodeLine{00139     \textcolor{comment}{// Enable run-\/time memory check for debug builds.}}
\DoxyCodeLine{00140 \textcolor{preprocessor}{\#if defined(DEBUG) | defined(\_DEBUG)}}
\DoxyCodeLine{00141     \_CrtSetDbgFlag(\_CRTDBG\_ALLOC\_MEM\_DF | \_CRTDBG\_LEAK\_CHECK\_DF);}
\DoxyCodeLine{00142 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00143 }
\DoxyCodeLine{00144     \textcolor{keywordflow}{try}}
\DoxyCodeLine{00145     \{}
\DoxyCodeLine{00146         CrateApp theApp(hInstance);}
\DoxyCodeLine{00147         \textcolor{keywordflow}{if} (!theApp.Initialize())}
\DoxyCodeLine{00148             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00149 }
\DoxyCodeLine{00150         \textcolor{keywordflow}{return} theApp.Run();}
\DoxyCodeLine{00151     \}}
\DoxyCodeLine{00152     \textcolor{keywordflow}{catch} (DxException \& e)}
\DoxyCodeLine{00153     \{}
\DoxyCodeLine{00154         MessageBox(\textcolor{keyword}{nullptr}, e.ToString().c\_str(), L\textcolor{stringliteral}{"{}HR Failed"{}}, MB\_OK);}
\DoxyCodeLine{00155         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00156     \}}
\DoxyCodeLine{00157 \}}
\DoxyCodeLine{00158 }
\DoxyCodeLine{00159 CrateApp::CrateApp(HINSTANCE hInstance)}
\DoxyCodeLine{00160     : D3DApp(hInstance)}
\DoxyCodeLine{00161 \{}
\DoxyCodeLine{00162 \}}
\DoxyCodeLine{00163 }
\DoxyCodeLine{00164 CrateApp::\string~CrateApp()}
\DoxyCodeLine{00165 \{}
\DoxyCodeLine{00166     \textcolor{keywordflow}{if} (md3dDevice != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00167         FlushCommandQueue();}
\DoxyCodeLine{00168 \}}
\DoxyCodeLine{00169 }
\DoxyCodeLine{00170 \textcolor{keywordtype}{bool} CrateApp::Initialize()}
\DoxyCodeLine{00171 \{}
\DoxyCodeLine{00172     \textcolor{keywordflow}{if} (!D3DApp::Initialize())}
\DoxyCodeLine{00173         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00174 }
\DoxyCodeLine{00175     \textcolor{comment}{// Reset the command list to prep for initialization commands.}}
\DoxyCodeLine{00176     ThrowIfFailed(mCommandList-\/>Reset(mDirectCmdListAlloc.Get(), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{00177 }
\DoxyCodeLine{00178     \textcolor{comment}{// Get the increment size of a descriptor in this heap type.  This is hardware specific, }}
\DoxyCodeLine{00179     \textcolor{comment}{// so we have to query this information.}}
\DoxyCodeLine{00180     mCbvSrvDescriptorSize = md3dDevice-\/>GetDescriptorHandleIncrementSize(D3D12\_DESCRIPTOR\_HEAP\_TYPE\_CBV\_SRV\_UAV);}
\DoxyCodeLine{00181 }
\DoxyCodeLine{00182     LoadTextures();}
\DoxyCodeLine{00183     BuildRootSignature();}
\DoxyCodeLine{00184     BuildDescriptorHeaps();}
\DoxyCodeLine{00185 }
\DoxyCodeLine{00186     BuildShadersAndInputLayout();}
\DoxyCodeLine{00187     BuildShapeGeometry();}
\DoxyCodeLine{00188     BuildMaterials();}
\DoxyCodeLine{00189     BuildRenderItems();}
\DoxyCodeLine{00190     BuildFrameResources();}
\DoxyCodeLine{00191     BuildPSOs();}
\DoxyCodeLine{00192 }
\DoxyCodeLine{00193     \textcolor{comment}{// Execute the initialization commands.}}
\DoxyCodeLine{00194     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00195     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00196     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00197 }
\DoxyCodeLine{00198     \textcolor{comment}{// Wait until initialization is complete.}}
\DoxyCodeLine{00199     FlushCommandQueue();}
\DoxyCodeLine{00200 }
\DoxyCodeLine{00201     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00202 \}}
\DoxyCodeLine{00203 }
\DoxyCodeLine{00204 \textcolor{keywordtype}{void} CrateApp::OnResize()}
\DoxyCodeLine{00205 \{}
\DoxyCodeLine{00206     D3DApp::OnResize();}
\DoxyCodeLine{00207 }
\DoxyCodeLine{00208     \textcolor{comment}{// The window resized, so update the aspect ratio and recompute the projection matrix.}}
\DoxyCodeLine{00209     XMMATRIX P = XMMatrixPerspectiveFovLH(0.25f * MathHelper::Pi, AspectRatio(), 1.0f, 1000.0f);}
\DoxyCodeLine{00210     XMStoreFloat4x4(\&mProj, P);}
\DoxyCodeLine{00211 \}}
\DoxyCodeLine{00212 }
\DoxyCodeLine{00213 \textcolor{keywordtype}{void} CrateApp::Update(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00214 \{}
\DoxyCodeLine{00215     OnKeyboardInput(gt);}
\DoxyCodeLine{00216     UpdateCamera(gt);}
\DoxyCodeLine{00217 }
\DoxyCodeLine{00218     \textcolor{comment}{// Cycle through the circular frame resource array.}}
\DoxyCodeLine{00219     mCurrFrameResourceIndex = (mCurrFrameResourceIndex + 1) \% gNumFrameResources;}
\DoxyCodeLine{00220     mCurrFrameResource = mFrameResources[mCurrFrameResourceIndex].get();}
\DoxyCodeLine{00221 }
\DoxyCodeLine{00222     \textcolor{comment}{// Has the GPU finished processing the commands of the current frame resource?}}
\DoxyCodeLine{00223     \textcolor{comment}{// If not, wait until the GPU has completed commands up to this fence point.}}
\DoxyCodeLine{00224     \textcolor{keywordflow}{if} (mCurrFrameResource-\/>Fence != 0 \&\& mFence-\/>GetCompletedValue() < mCurrFrameResource-\/>Fence)}
\DoxyCodeLine{00225     \{}
\DoxyCodeLine{00226         HANDLE eventHandle = CreateEventEx(\textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr}, \textcolor{keyword}{false}, EVENT\_ALL\_ACCESS);}
\DoxyCodeLine{00227         ThrowIfFailed(mFence-\/>SetEventOnCompletion(mCurrFrameResource-\/>Fence, eventHandle));}
\DoxyCodeLine{00228         WaitForSingleObject(eventHandle, INFINITE);}
\DoxyCodeLine{00229         CloseHandle(eventHandle);}
\DoxyCodeLine{00230     \}}
\DoxyCodeLine{00231 }
\DoxyCodeLine{00232     AnimateMaterials(gt);}
\DoxyCodeLine{00233     UpdateObjectCBs(gt);}
\DoxyCodeLine{00234     UpdateMaterialCBs(gt);}
\DoxyCodeLine{00235     UpdateMainPassCB(gt);}
\DoxyCodeLine{00236 \}}
\DoxyCodeLine{00237 }
\DoxyCodeLine{00238 \textcolor{keywordtype}{void} CrateApp::Draw(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00239 \{}
\DoxyCodeLine{00240     \textcolor{keyword}{auto} cmdListAlloc = mCurrFrameResource-\/>CmdListAlloc;}
\DoxyCodeLine{00241 }
\DoxyCodeLine{00242     \textcolor{comment}{// Reuse the memory associated with command recording.}}
\DoxyCodeLine{00243     \textcolor{comment}{// We can only reset when the associated command lists have finished execution on the GPU.}}
\DoxyCodeLine{00244     ThrowIfFailed(cmdListAlloc-\/>Reset());}
\DoxyCodeLine{00245 }
\DoxyCodeLine{00246     \textcolor{comment}{// A command list can be reset after it has been added to the command queue via ExecuteCommandList.}}
\DoxyCodeLine{00247     \textcolor{comment}{// Reusing the command list reuses memory.  }}
\DoxyCodeLine{00248 }
\DoxyCodeLine{00249     \textcolor{keywordflow}{if} (mIsWireframe)}
\DoxyCodeLine{00250     \{}
\DoxyCodeLine{00251         ThrowIfFailed(mCommandList-\/>Reset(cmdListAlloc.Get(), mOpaquePSO.Get()));}
\DoxyCodeLine{00252     \}}
\DoxyCodeLine{00253     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00254     \{}
\DoxyCodeLine{00255         ThrowIfFailed(mCommandList-\/>Reset(cmdListAlloc.Get(), mWireframePSO.Get()));}
\DoxyCodeLine{00256     \}}
\DoxyCodeLine{00257 }
\DoxyCodeLine{00258     mCommandList-\/>RSSetViewports(1, \&mScreenViewport);}
\DoxyCodeLine{00259     mCommandList-\/>RSSetScissorRects(1, \&mScissorRect);}
\DoxyCodeLine{00260 }
\DoxyCodeLine{00261     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00262     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00263         D3D12\_RESOURCE\_STATE\_PRESENT, D3D12\_RESOURCE\_STATE\_RENDER\_TARGET));}
\DoxyCodeLine{00264 }
\DoxyCodeLine{00265     \textcolor{comment}{// Clear the back buffer and depth buffer.}}
\DoxyCodeLine{00266     mCommandList-\/>ClearRenderTargetView(CurrentBackBufferView(), Colors::LightSteelBlue, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00267     mCommandList-\/>ClearDepthStencilView(DepthStencilView(), D3D12\_CLEAR\_FLAG\_DEPTH | D3D12\_CLEAR\_FLAG\_STENCIL, 1.0f, 0, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00268 }
\DoxyCodeLine{00269     \textcolor{comment}{// Specify the buffers we are going to render to.}}
\DoxyCodeLine{00270     mCommandList-\/>OMSetRenderTargets(1, \&CurrentBackBufferView(), \textcolor{keyword}{true}, \&DepthStencilView());}
\DoxyCodeLine{00271 }
\DoxyCodeLine{00272     ID3D12DescriptorHeap* descriptorHeaps[] = \{ mSrvDescriptorHeap.Get() \};}
\DoxyCodeLine{00273     mCommandList-\/>SetDescriptorHeaps(\_countof(descriptorHeaps), descriptorHeaps);}
\DoxyCodeLine{00274 }
\DoxyCodeLine{00275     mCommandList-\/>SetGraphicsRootSignature(mRootSignature.Get());}
\DoxyCodeLine{00276 }
\DoxyCodeLine{00277     \textcolor{keyword}{auto} passCB = mCurrFrameResource-\/>PassCB-\/>Resource();}
\DoxyCodeLine{00278     mCommandList-\/>SetGraphicsRootConstantBufferView(2, passCB-\/>GetGPUVirtualAddress());}
\DoxyCodeLine{00279 }
\DoxyCodeLine{00280 }
\DoxyCodeLine{00281 }
\DoxyCodeLine{00282     DrawRenderItems(mCommandList.Get(), mOpaqueRitems);}
\DoxyCodeLine{00283 }
\DoxyCodeLine{00284 }
\DoxyCodeLine{00285 }
\DoxyCodeLine{00286     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00287     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00288         D3D12\_RESOURCE\_STATE\_RENDER\_TARGET, D3D12\_RESOURCE\_STATE\_PRESENT));}
\DoxyCodeLine{00289 }
\DoxyCodeLine{00290     \textcolor{comment}{// Done recording commands.}}
\DoxyCodeLine{00291     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00292 }
\DoxyCodeLine{00293     \textcolor{comment}{// Add the command list to the queue for execution.}}
\DoxyCodeLine{00294     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00295     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00296 }
\DoxyCodeLine{00297     \textcolor{comment}{// Swap the back and front buffers}}
\DoxyCodeLine{00298     ThrowIfFailed(mSwapChain-\/>Present(0, 0));}
\DoxyCodeLine{00299     mCurrBackBuffer = (mCurrBackBuffer + 1) \% SwapChainBufferCount;}
\DoxyCodeLine{00300 }
\DoxyCodeLine{00301     \textcolor{comment}{// Advance the fence value to mark commands up to this fence point.}}
\DoxyCodeLine{00302     mCurrFrameResource-\/>Fence = ++mCurrentFence;}
\DoxyCodeLine{00303 }
\DoxyCodeLine{00304     \textcolor{comment}{// Add an instruction to the command queue to set a new fence point. }}
\DoxyCodeLine{00305     \textcolor{comment}{// Because we are on the GPU timeline, the new fence point won't be }}
\DoxyCodeLine{00306     \textcolor{comment}{// set until the GPU finishes processing all the commands prior to this Signal().}}
\DoxyCodeLine{00307     mCommandQueue-\/>Signal(mFence.Get(), mCurrentFence);}
\DoxyCodeLine{00308 \}}
\DoxyCodeLine{00309 }
\DoxyCodeLine{00310 \textcolor{keywordtype}{void} CrateApp::OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00311 \{}
\DoxyCodeLine{00312     mLastMousePos.x = x;}
\DoxyCodeLine{00313     mLastMousePos.y = y;}
\DoxyCodeLine{00314 }
\DoxyCodeLine{00315     SetCapture(mhMainWnd);}
\DoxyCodeLine{00316 \}}
\DoxyCodeLine{00317 }
\DoxyCodeLine{00318 \textcolor{keywordtype}{void} CrateApp::OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00319 \{}
\DoxyCodeLine{00320     ReleaseCapture();}
\DoxyCodeLine{00321 \}}
\DoxyCodeLine{00322 }
\DoxyCodeLine{00323 \textcolor{keywordtype}{void} CrateApp::OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00324 \{}
\DoxyCodeLine{00325     \textcolor{keywordflow}{if} ((btnState \& MK\_LBUTTON) != 0)}
\DoxyCodeLine{00326     \{}
\DoxyCodeLine{00327         \textcolor{comment}{// Make each pixel correspond to a quarter of a degree.}}
\DoxyCodeLine{00328         \textcolor{keywordtype}{float} dx = XMConvertToRadians(0.25f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x -\/ mLastMousePos.x));}
\DoxyCodeLine{00329         \textcolor{keywordtype}{float} dy = XMConvertToRadians(0.25f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(y -\/ mLastMousePos.y));}
\DoxyCodeLine{00330 }
\DoxyCodeLine{00331         \textcolor{comment}{// Update angles based on input to orbit camera around box.}}
\DoxyCodeLine{00332         mTheta += dx;}
\DoxyCodeLine{00333         mPhi += dy;}
\DoxyCodeLine{00334 }
\DoxyCodeLine{00335         \textcolor{comment}{// Restrict the angle mPhi.}}
\DoxyCodeLine{00336         mPhi = MathHelper::Clamp(mPhi, 0.1f, MathHelper::Pi -\/ 0.1f);}
\DoxyCodeLine{00337     \}}
\DoxyCodeLine{00338     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((btnState \& MK\_RBUTTON) != 0)}
\DoxyCodeLine{00339     \{}
\DoxyCodeLine{00340         \textcolor{comment}{// Make each pixel correspond to 0.2 unit in the scene.}}
\DoxyCodeLine{00341         \textcolor{keywordtype}{float} dx = 0.05f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x -\/ mLastMousePos.x);}
\DoxyCodeLine{00342         \textcolor{keywordtype}{float} dy = 0.05f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(y -\/ mLastMousePos.y);}
\DoxyCodeLine{00343 }
\DoxyCodeLine{00344         \textcolor{comment}{// Update the camera radius based on input.}}
\DoxyCodeLine{00345         mRadius += dx -\/ dy;}
\DoxyCodeLine{00346 }
\DoxyCodeLine{00347         \textcolor{comment}{// Restrict the radius.}}
\DoxyCodeLine{00348         mRadius = MathHelper::Clamp(mRadius, 5.0f, 150.0f);}
\DoxyCodeLine{00349     \}}
\DoxyCodeLine{00350 }
\DoxyCodeLine{00351     mLastMousePos.x = x;}
\DoxyCodeLine{00352     mLastMousePos.y = y;}
\DoxyCodeLine{00353 \}}
\DoxyCodeLine{00354 }
\DoxyCodeLine{00355 \textcolor{keywordtype}{void} CrateApp::OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00356 \{}
\DoxyCodeLine{00357     \textcolor{comment}{//Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.}}
\DoxyCodeLine{00358 \textcolor{comment}{//If the function succeeds, the return value specifies whether the key was pressed since the last call to GetAsyncKeyState, }}
\DoxyCodeLine{00359 \textcolor{comment}{//and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after the previous call to GetAsyncKeyState.}}
\DoxyCodeLine{00360 \textcolor{comment}{//if (GetAsyncKeyState('1') \& 0x8000)}}
\DoxyCodeLine{00361 }
\DoxyCodeLine{00362     \textcolor{keywordtype}{short} key = GetAsyncKeyState(\textcolor{charliteral}{'1'});}
\DoxyCodeLine{00363     \textcolor{keywordflow}{if} (key \& 0x8000)  \textcolor{comment}{//if one is pressed, 0x8000 = 32767 , key = -\/32767 = FFFFFFFFFFFF8001}}
\DoxyCodeLine{00364         mIsWireframe = \textcolor{keyword}{true};}
\DoxyCodeLine{00365     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00366         mIsWireframe = \textcolor{keyword}{false};}
\DoxyCodeLine{00367 \}}
\DoxyCodeLine{00368 }
\DoxyCodeLine{00369 \textcolor{keywordtype}{void} CrateApp::UpdateCamera(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00370 \{}
\DoxyCodeLine{00371     \textcolor{comment}{// Convert Spherical to Cartesian coordinates.}}
\DoxyCodeLine{00372     mEyePos.x = mRadius * sinf(mPhi) * cosf(mTheta);}
\DoxyCodeLine{00373     mEyePos.z = mRadius * sinf(mPhi) * sinf(mTheta);}
\DoxyCodeLine{00374     mEyePos.y = mRadius * cosf(mPhi);}
\DoxyCodeLine{00375 }
\DoxyCodeLine{00376     \textcolor{comment}{// Build the view matrix.}}
\DoxyCodeLine{00377     XMVECTOR pos = XMVectorSet(mEyePos.x, mEyePos.y, mEyePos.z, 1.0f);}
\DoxyCodeLine{00378     XMVECTOR target = XMVectorZero();}
\DoxyCodeLine{00379     XMVECTOR up = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00380 }
\DoxyCodeLine{00381     XMMATRIX view = XMMatrixLookAtLH(pos, target, up);}
\DoxyCodeLine{00382     XMStoreFloat4x4(\&mView, view);}
\DoxyCodeLine{00383 \}}
\DoxyCodeLine{00384 }
\DoxyCodeLine{00385 \textcolor{keywordtype}{void} CrateApp::AnimateMaterials(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00386 \{}
\DoxyCodeLine{00387 }
\DoxyCodeLine{00388 \}}
\DoxyCodeLine{00389 }
\DoxyCodeLine{00390 \textcolor{keywordtype}{void} CrateApp::UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00391 \{}
\DoxyCodeLine{00392     \textcolor{keyword}{auto} currObjectCB = mCurrFrameResource-\/>ObjectCB.get();}
\DoxyCodeLine{00393     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& e : mAllRitems)}
\DoxyCodeLine{00394     \{}
\DoxyCodeLine{00395         \textcolor{comment}{// Only update the cbuffer data if the constants have changed.  }}
\DoxyCodeLine{00396         \textcolor{comment}{// This needs to be tracked per frame resource.}}
\DoxyCodeLine{00397         \textcolor{keywordflow}{if} (e-\/>NumFramesDirty > 0)}
\DoxyCodeLine{00398         \{}
\DoxyCodeLine{00399             XMMATRIX world = XMLoadFloat4x4(\&e-\/>World);}
\DoxyCodeLine{00400             XMMATRIX texTransform = XMLoadFloat4x4(\&e-\/>TexTransform);}
\DoxyCodeLine{00401 }
\DoxyCodeLine{00402             ObjectConstants objConstants;}
\DoxyCodeLine{00403             XMStoreFloat4x4(\&objConstants.World, XMMatrixTranspose(world));}
\DoxyCodeLine{00404             XMStoreFloat4x4(\&objConstants.TexTransform, XMMatrixTranspose(texTransform));}
\DoxyCodeLine{00405 }
\DoxyCodeLine{00406             currObjectCB-\/>CopyData(e-\/>ObjCBIndex, objConstants);}
\DoxyCodeLine{00407 }
\DoxyCodeLine{00408             \textcolor{comment}{// Next FrameResource need to be updated too.}}
\DoxyCodeLine{00409             e-\/>NumFramesDirty-\/-\/;}
\DoxyCodeLine{00410         \}}
\DoxyCodeLine{00411     \}}
\DoxyCodeLine{00412 \}}
\DoxyCodeLine{00413 }
\DoxyCodeLine{00414 \textcolor{keywordtype}{void} CrateApp::UpdateMaterialCBs(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00415 \{}
\DoxyCodeLine{00416     \textcolor{keyword}{auto} currMaterialCB = mCurrFrameResource-\/>MaterialCB.get();}
\DoxyCodeLine{00417     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& e : mMaterials)}
\DoxyCodeLine{00418     \{}
\DoxyCodeLine{00419         \textcolor{comment}{// Only update the cbuffer data if the constants have changed.  If the cbuffer}}
\DoxyCodeLine{00420         \textcolor{comment}{// data changes, it needs to be updated for each FrameResource.}}
\DoxyCodeLine{00421         Material* mat = e.second.get();}
\DoxyCodeLine{00422         \textcolor{keywordflow}{if} (mat-\/>NumFramesDirty > 0)}
\DoxyCodeLine{00423         \{}
\DoxyCodeLine{00424             XMMATRIX matTransform = XMLoadFloat4x4(\&mat-\/>MatTransform);}
\DoxyCodeLine{00425 }
\DoxyCodeLine{00426             MaterialConstants matConstants;}
\DoxyCodeLine{00427             matConstants.DiffuseAlbedo = mat-\/>DiffuseAlbedo;}
\DoxyCodeLine{00428             matConstants.FresnelR0 = mat-\/>FresnelR0;}
\DoxyCodeLine{00429             matConstants.Roughness = mat-\/>Roughness;}
\DoxyCodeLine{00430             XMStoreFloat4x4(\&matConstants.MatTransform, XMMatrixTranspose(matTransform));}
\DoxyCodeLine{00431 }
\DoxyCodeLine{00432             currMaterialCB-\/>CopyData(mat-\/>MatCBIndex, matConstants);}
\DoxyCodeLine{00433 }
\DoxyCodeLine{00434             \textcolor{comment}{// Next FrameResource need to be updated too.}}
\DoxyCodeLine{00435             mat-\/>NumFramesDirty-\/-\/;}
\DoxyCodeLine{00436         \}}
\DoxyCodeLine{00437     \}}
\DoxyCodeLine{00438 \}}
\DoxyCodeLine{00439 }
\DoxyCodeLine{00440 \textcolor{keywordtype}{void} CrateApp::UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00441 \{}
\DoxyCodeLine{00442     XMMATRIX view = XMLoadFloat4x4(\&mView);}
\DoxyCodeLine{00443     XMMATRIX proj = XMLoadFloat4x4(\&mProj);}
\DoxyCodeLine{00444 }
\DoxyCodeLine{00445     XMMATRIX viewProj = XMMatrixMultiply(view, proj);}
\DoxyCodeLine{00446     XMMATRIX invView = XMMatrixInverse(\&XMMatrixDeterminant(view), view);}
\DoxyCodeLine{00447     XMMATRIX invProj = XMMatrixInverse(\&XMMatrixDeterminant(proj), proj);}
\DoxyCodeLine{00448     XMMATRIX invViewProj = XMMatrixInverse(\&XMMatrixDeterminant(viewProj), viewProj);}
\DoxyCodeLine{00449 }
\DoxyCodeLine{00450     XMStoreFloat4x4(\&mMainPassCB.View, XMMatrixTranspose(view));}
\DoxyCodeLine{00451     XMStoreFloat4x4(\&mMainPassCB.InvView, XMMatrixTranspose(invView));}
\DoxyCodeLine{00452     XMStoreFloat4x4(\&mMainPassCB.Proj, XMMatrixTranspose(proj));}
\DoxyCodeLine{00453     XMStoreFloat4x4(\&mMainPassCB.InvProj, XMMatrixTranspose(invProj));}
\DoxyCodeLine{00454     XMStoreFloat4x4(\&mMainPassCB.ViewProj, XMMatrixTranspose(viewProj));}
\DoxyCodeLine{00455     XMStoreFloat4x4(\&mMainPassCB.InvViewProj, XMMatrixTranspose(invViewProj));}
\DoxyCodeLine{00456     mMainPassCB.EyePosW = mEyePos;}
\DoxyCodeLine{00457     mMainPassCB.RenderTargetSize = XMFLOAT2((\textcolor{keywordtype}{float})mClientWidth, (\textcolor{keywordtype}{float})mClientHeight);}
\DoxyCodeLine{00458     mMainPassCB.InvRenderTargetSize = XMFLOAT2(1.0f / mClientWidth, 1.0f / mClientHeight);}
\DoxyCodeLine{00459     mMainPassCB.NearZ = 1.0f;}
\DoxyCodeLine{00460     mMainPassCB.FarZ = 1000.0f;}
\DoxyCodeLine{00461     mMainPassCB.TotalTime = gt.TotalTime();}
\DoxyCodeLine{00462     mMainPassCB.DeltaTime = gt.DeltaTime();}
\DoxyCodeLine{00463     \textcolor{comment}{//hooman:I changed the ambient for now to give the texture more color.}}
\DoxyCodeLine{00464     mMainPassCB.AmbientLight = \{ 0.75f, 0.25f, 0.35f, 1.0f \};}
\DoxyCodeLine{00465     mMainPassCB.Lights[0].Direction = \{ 0.57735f, -\/0.57735f, 0.57735f \};}
\DoxyCodeLine{00466     mMainPassCB.Lights[0].Strength = \{ 0.6f, 0.6f, 0.6f \};}
\DoxyCodeLine{00467     mMainPassCB.Lights[1].Direction = \{ -\/0.57735f, -\/0.57735f, 0.57735f \};}
\DoxyCodeLine{00468     mMainPassCB.Lights[1].Strength = \{ 0.3f, 0.3f, 0.3f \};}
\DoxyCodeLine{00469     mMainPassCB.Lights[2].Direction = \{ 0.0f, -\/0.707f, -\/0.707f \};}
\DoxyCodeLine{00470     mMainPassCB.Lights[2].Strength = \{ 0.15f, 0.15f, 0.15f \};}
\DoxyCodeLine{00471 }
\DoxyCodeLine{00472     \textcolor{keyword}{auto} currPassCB = mCurrFrameResource-\/>PassCB.get();}
\DoxyCodeLine{00473     currPassCB-\/>CopyData(0, mMainPassCB);}
\DoxyCodeLine{00474 \}}
\DoxyCodeLine{00475 }
\DoxyCodeLine{00476 \textcolor{keywordtype}{void} CrateApp::LoadTextures()}
\DoxyCodeLine{00477 \{}
\DoxyCodeLine{00478     \textcolor{keyword}{auto} woodCrateTex = std::make\_unique<Texture>();}
\DoxyCodeLine{00479     woodCrateTex-\/>Name = \textcolor{stringliteral}{"{}woodCrateTex"{}};}
\DoxyCodeLine{00480     woodCrateTex-\/>Filename = L\textcolor{stringliteral}{"{}../../Textures/ice.dds"{}};}
\DoxyCodeLine{00481     ThrowIfFailed(DirectX::CreateDDSTextureFromFile12(md3dDevice.Get(),}
\DoxyCodeLine{00482         mCommandList.Get(), woodCrateTex-\/>Filename.c\_str(),}
\DoxyCodeLine{00483         woodCrateTex-\/>Resource, woodCrateTex-\/>UploadHeap));}
\DoxyCodeLine{00484 }
\DoxyCodeLine{00485     mTextures[woodCrateTex-\/>Name] = std::move(woodCrateTex);}
\DoxyCodeLine{00486 \}}
\DoxyCodeLine{00487 }
\DoxyCodeLine{00488 \textcolor{keywordtype}{void} CrateApp::BuildRootSignature()}
\DoxyCodeLine{00489 \{}
\DoxyCodeLine{00490     CD3DX12\_DESCRIPTOR\_RANGE texTable;}
\DoxyCodeLine{00491     texTable.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_SRV, 1, 0);}
\DoxyCodeLine{00492 }
\DoxyCodeLine{00493     \textcolor{comment}{// Root parameter can be a table, root descriptor or root constants.}}
\DoxyCodeLine{00494     CD3DX12\_ROOT\_PARAMETER slotRootParameter[4];}
\DoxyCodeLine{00495 }
\DoxyCodeLine{00496     \textcolor{comment}{// Perfomance TIP: Order from most frequent to least frequent.}}
\DoxyCodeLine{00497     slotRootParameter[0].InitAsDescriptorTable(1, \&texTable, D3D12\_SHADER\_VISIBILITY\_PIXEL);}
\DoxyCodeLine{00498     slotRootParameter[1].InitAsConstantBufferView(0);}
\DoxyCodeLine{00499     slotRootParameter[2].InitAsConstantBufferView(1);}
\DoxyCodeLine{00500     slotRootParameter[3].InitAsConstantBufferView(2);}
\DoxyCodeLine{00501 }
\DoxyCodeLine{00502     \textcolor{keyword}{auto} staticSamplers = GetStaticSamplers();}
\DoxyCodeLine{00503 }
\DoxyCodeLine{00504     \textcolor{comment}{// A root signature is an array of root parameters.}}
\DoxyCodeLine{00505     \textcolor{comment}{//The Init function of the CD3DX12\_ROOT\_SIGNATURE\_DESC class has two parameters that allow you to}}
\DoxyCodeLine{00506         \textcolor{comment}{//define an array of so -\/ called static samplers your application can use.}}
\DoxyCodeLine{00507     CD3DX12\_ROOT\_SIGNATURE\_DESC rootSigDesc(4, slotRootParameter,}
\DoxyCodeLine{00508         (UINT)staticSamplers.size(), staticSamplers.data(),  \textcolor{comment}{//6 samplers!}}
\DoxyCodeLine{00509         D3D12\_ROOT\_SIGNATURE\_FLAG\_ALLOW\_INPUT\_ASSEMBLER\_INPUT\_LAYOUT);}
\DoxyCodeLine{00510 }
\DoxyCodeLine{00511     \textcolor{comment}{// create a root signature with a single slot which points to a descriptor range consisting of a single constant buffer}}
\DoxyCodeLine{00512     ComPtr<ID3DBlob> serializedRootSig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00513     ComPtr<ID3DBlob> errorBlob = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00514     HRESULT hr = D3D12SerializeRootSignature(\&rootSigDesc, D3D\_ROOT\_SIGNATURE\_VERSION\_1,}
\DoxyCodeLine{00515         serializedRootSig.GetAddressOf(), errorBlob.GetAddressOf());}
\DoxyCodeLine{00516 }
\DoxyCodeLine{00517     \textcolor{keywordflow}{if} (errorBlob != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00518     \{}
\DoxyCodeLine{00519         ::OutputDebugStringA((\textcolor{keywordtype}{char}*)errorBlob-\/>GetBufferPointer());}
\DoxyCodeLine{00520     \}}
\DoxyCodeLine{00521     ThrowIfFailed(hr);}
\DoxyCodeLine{00522 }
\DoxyCodeLine{00523     ThrowIfFailed(md3dDevice-\/>CreateRootSignature(}
\DoxyCodeLine{00524         0,}
\DoxyCodeLine{00525         serializedRootSig-\/>GetBufferPointer(),}
\DoxyCodeLine{00526         serializedRootSig-\/>GetBufferSize(),}
\DoxyCodeLine{00527         IID\_PPV\_ARGS(mRootSignature.GetAddressOf())));}
\DoxyCodeLine{00528 \}}
\DoxyCodeLine{00529 }
\DoxyCodeLine{00530 \textcolor{comment}{//Once a texture resource is created, we need to create an SRV descriptor to it which we}}
\DoxyCodeLine{00531 \textcolor{comment}{//can set to a root signature parameter slot for use by the shader programs.}}
\DoxyCodeLine{00532 \textcolor{keywordtype}{void} CrateApp::BuildDescriptorHeaps()}
\DoxyCodeLine{00533 \{}
\DoxyCodeLine{00534     \textcolor{comment}{//}}
\DoxyCodeLine{00535     \textcolor{comment}{// Create the SRV heap.}}
\DoxyCodeLine{00536     \textcolor{comment}{//}}
\DoxyCodeLine{00537     D3D12\_DESCRIPTOR\_HEAP\_DESC srvHeapDesc = \{\};}
\DoxyCodeLine{00538     srvHeapDesc.NumDescriptors = 1;}
\DoxyCodeLine{00539     srvHeapDesc.Type = D3D12\_DESCRIPTOR\_HEAP\_TYPE\_CBV\_SRV\_UAV;}
\DoxyCodeLine{00540     srvHeapDesc.Flags = D3D12\_DESCRIPTOR\_HEAP\_FLAG\_SHADER\_VISIBLE;}
\DoxyCodeLine{00541     ThrowIfFailed(md3dDevice-\/>CreateDescriptorHeap(\&srvHeapDesc, IID\_PPV\_ARGS(\&mSrvDescriptorHeap)));}
\DoxyCodeLine{00542 }
\DoxyCodeLine{00543     \textcolor{comment}{//}}
\DoxyCodeLine{00544     \textcolor{comment}{// Fill out the heap with actual descriptors.}}
\DoxyCodeLine{00545     \textcolor{comment}{//}}
\DoxyCodeLine{00546     CD3DX12\_CPU\_DESCRIPTOR\_HANDLE hDescriptor(mSrvDescriptorHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00547 }
\DoxyCodeLine{00548     \textcolor{keyword}{auto} woodCrateTex = mTextures[\textcolor{stringliteral}{"{}woodCrateTex"{}}]-\/>Resource;}
\DoxyCodeLine{00549 }
\DoxyCodeLine{00550     D3D12\_SHADER\_RESOURCE\_VIEW\_DESC srvDesc = \{\};}
\DoxyCodeLine{00551 }
\DoxyCodeLine{00552     \textcolor{comment}{//This mapping enables the shader resource view (SRV) to choose how memory gets routed to the 4 return components in a shader after a memory fetch.}}
\DoxyCodeLine{00553     \textcolor{comment}{//When a texture is sampled in a shader, it will return a vector of the texture data at the specified texture coordinates.}}
\DoxyCodeLine{00554     \textcolor{comment}{//This field provides a way to reorder the vector components returned when sampling the texture.}}
\DoxyCodeLine{00555     \textcolor{comment}{//D3D12\_DEFAULT\_SHADER\_4\_COMPONENT\_MAPPING  will not reorder the components and just return the data in the order it is stored in the texture resource.}}
\DoxyCodeLine{00556     srvDesc.Shader4ComponentMapping = D3D12\_DEFAULT\_SHADER\_4\_COMPONENT\_MAPPING;}
\DoxyCodeLine{00557 }
\DoxyCodeLine{00558     srvDesc.Format = woodCrateTex-\/>GetDesc().Format;}
\DoxyCodeLine{00559     srvDesc.ViewDimension = D3D12\_SRV\_DIMENSION\_TEXTURE2D;}
\DoxyCodeLine{00560     srvDesc.Texture2D.MostDetailedMip = 0;}
\DoxyCodeLine{00561     \textcolor{comment}{//The number of mipmap levels to view, starting at MostDetailedMip.This field, along with MostDetailedMip allows us to}}
\DoxyCodeLine{00562     \textcolor{comment}{//specify a subrange of mipmap levels to view.You can specify -\/ 1 to indicate to view}}
\DoxyCodeLine{00563     \textcolor{comment}{//all mipmap levels from MostDetailedMip down to the last mipmap level.}}
\DoxyCodeLine{00564 }
\DoxyCodeLine{00565     srvDesc.Texture2D.MipLevels = woodCrateTex-\/>GetDesc().MipLevels;}
\DoxyCodeLine{00566 }
\DoxyCodeLine{00567     \textcolor{comment}{//Specifies the minimum mipmap level that can be accessed. 0.0 means all the mipmap levels can be accessed.}}
\DoxyCodeLine{00568     \textcolor{comment}{//Specifying 3.0 means mipmap levels 3.0 to MipCount -\/ 1 can be accessed.}}
\DoxyCodeLine{00569     srvDesc.Texture2D.ResourceMinLODClamp = 0.0f;}
\DoxyCodeLine{00570 }
\DoxyCodeLine{00571     md3dDevice-\/>CreateShaderResourceView(woodCrateTex.Get(), \&srvDesc, hDescriptor);}
\DoxyCodeLine{00572 \}}
\DoxyCodeLine{00573 }
\DoxyCodeLine{00574 \textcolor{keywordtype}{void} CrateApp::BuildShadersAndInputLayout()}
\DoxyCodeLine{00575 \{}
\DoxyCodeLine{00576     mShaders[\textcolor{stringliteral}{"{}standardVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Default2.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{00577     mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Default2.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{00578     mShaders[\textcolor{stringliteral}{"{}opaqueGS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)GS5.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}GS"{}}, \textcolor{stringliteral}{"{}gs\_5\_1"{}});}
\DoxyCodeLine{00579 }
\DoxyCodeLine{00580     mInputLayout =}
\DoxyCodeLine{00581     \{}
\DoxyCodeLine{00582         \{ \textcolor{stringliteral}{"{}POSITION"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 0, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00583         \{ \textcolor{stringliteral}{"{}NORMAL"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 12, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00584         \{ \textcolor{stringliteral}{"{}TEXCOORD"{}}, 0, DXGI\_FORMAT\_R32G32\_FLOAT, 0, 24, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00585     \};}
\DoxyCodeLine{00586 \}}
\DoxyCodeLine{00587 }
\DoxyCodeLine{00588 \textcolor{keywordtype}{void} CrateApp::BuildShapeGeometry()}
\DoxyCodeLine{00589 \{}
\DoxyCodeLine{00590     \textcolor{comment}{//GeometryGenerator geoGen;}}
\DoxyCodeLine{00591     GeometryGenerator::MeshData box;}
\DoxyCodeLine{00592 }
\DoxyCodeLine{00593 }
\DoxyCodeLine{00594     \textcolor{comment}{//}}
\DoxyCodeLine{00595     \textcolor{comment}{// Create the vertices.}}
\DoxyCodeLine{00596     \textcolor{comment}{//}}
\DoxyCodeLine{00597 }
\DoxyCodeLine{00598     GeometryGenerator::Vertex v[4];}
\DoxyCodeLine{00599 }
\DoxyCodeLine{00600     \textcolor{comment}{//tetrahedron coordinates}}
\DoxyCodeLine{00601     \textcolor{comment}{//var va = vec4(0.0, 0.0, -\/1.0, 1);}}
\DoxyCodeLine{00602     \textcolor{comment}{//var vb = vec4(0.0, 0.942809, 0.333333, 1);}}
\DoxyCodeLine{00603     \textcolor{comment}{//var vc = vec4(-\/0.816497, -\/0.471405, 0.333333, 1);}}
\DoxyCodeLine{00604     \textcolor{comment}{//var vd = vec4(0.816497, -\/0.471405, 0.333333, 1);}}
\DoxyCodeLine{00605 }
\DoxyCodeLine{00606     \textcolor{comment}{// tetrahedron coordinates}}
\DoxyCodeLine{00607     v[0] = GeometryGenerator::Vertex(0.0f, 0.0f, -\/1.0f, 0.0f, 0.0f, -\/1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);}
\DoxyCodeLine{00608     v[1] = GeometryGenerator::Vertex(0.0f, 0.9428f, 0.3333f, 0.0f, 0.0f, -\/1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00609     v[2] = GeometryGenerator::Vertex(-\/0.816f, -\/0.471f, 0.3333f, 0.0f, 0.0f, -\/1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f);}
\DoxyCodeLine{00610     v[3] = GeometryGenerator::Vertex(0.816f, -\/0.471f, 0.3333f, 0.0f, 0.0f, -\/1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f);}
\DoxyCodeLine{00611 }
\DoxyCodeLine{00612     box.Vertices.assign(\&v[0], \&v[4]);}
\DoxyCodeLine{00613 }
\DoxyCodeLine{00614     \textcolor{comment}{// Create the indices.}}
\DoxyCodeLine{00615     \textcolor{comment}{//function tetrahedron(a, b, c, d) \{}}
\DoxyCodeLine{00616     \textcolor{comment}{//  triangle(c, b, a);}}
\DoxyCodeLine{00617     \textcolor{comment}{//  triangle(b, c, d);}}
\DoxyCodeLine{00618     \textcolor{comment}{//  triangle(b, d, a);}}
\DoxyCodeLine{00619     \textcolor{comment}{//  triangle(d, c, a);}}
\DoxyCodeLine{00620 }
\DoxyCodeLine{00621     GeometryGenerator::uint32 i[12];}
\DoxyCodeLine{00622     \textcolor{comment}{// Fill in the front face index data}}
\DoxyCodeLine{00623     i[0] = 2; i[1] = 1; i[2] = 0;}
\DoxyCodeLine{00624     i[3] = 1; i[4] = 2; i[5] = 3;}
\DoxyCodeLine{00625     i[6] = 1; i[7] = 3; i[8] = 0;}
\DoxyCodeLine{00626     i[9] = 3; i[10] = 2; i[11] = 0;}
\DoxyCodeLine{00627 }
\DoxyCodeLine{00628     box.Indices32.assign(\&i[0], \&i[12]);}
\DoxyCodeLine{00629 }
\DoxyCodeLine{00630     \textcolor{comment}{// Put a cap on the number of subdivisions.}}
\DoxyCodeLine{00631     GeometryGenerator::uint32 numSubdivisions = 6u;}
\DoxyCodeLine{00632 }
\DoxyCodeLine{00633     \textcolor{comment}{//Move this to GPU using Geometry Shader}}
\DoxyCodeLine{00634     \textcolor{comment}{//for (GeometryGenerator::uint32 i = 0; i < numSubdivisions; ++i)}}
\DoxyCodeLine{00635     \textcolor{comment}{//  geoGen.Subdivide(box);}}
\DoxyCodeLine{00636 }
\DoxyCodeLine{00637     SubmeshGeometry boxSubmesh;}
\DoxyCodeLine{00638     boxSubmesh.IndexCount = (UINT)box.Indices32.size();}
\DoxyCodeLine{00639     boxSubmesh.StartIndexLocation = 0;}
\DoxyCodeLine{00640     boxSubmesh.BaseVertexLocation = 0;}
\DoxyCodeLine{00641 }
\DoxyCodeLine{00642 }
\DoxyCodeLine{00643     std::vector<Vertex> vertices(box.Vertices.size());}
\DoxyCodeLine{00644 }
\DoxyCodeLine{00645     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < box.Vertices.size(); ++i)}
\DoxyCodeLine{00646     \{}
\DoxyCodeLine{00647         vertices[i].Pos = box.Vertices[i].Position;}
\DoxyCodeLine{00648         vertices[i].Normal = box.Vertices[i].Normal;}
\DoxyCodeLine{00649         vertices[i].TexC = box.Vertices[i].TexC;}
\DoxyCodeLine{00650     \}}
\DoxyCodeLine{00651 }
\DoxyCodeLine{00652     std::vector<std::uint16\_t> indices = box.GetIndices16();}
\DoxyCodeLine{00653 }
\DoxyCodeLine{00654     \textcolor{keyword}{const} UINT vbByteSize = (UINT)vertices.size() * \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{00655     \textcolor{keyword}{const} UINT ibByteSize = (UINT)indices.size() * \textcolor{keyword}{sizeof}(std::uint16\_t);}
\DoxyCodeLine{00656 }
\DoxyCodeLine{00657     \textcolor{keyword}{auto} geo = std::make\_unique<MeshGeometry>();}
\DoxyCodeLine{00658     geo-\/>Name = \textcolor{stringliteral}{"{}boxGeo"{}};}
\DoxyCodeLine{00659 }
\DoxyCodeLine{00660     ThrowIfFailed(D3DCreateBlob(vbByteSize, \&geo-\/>VertexBufferCPU));}
\DoxyCodeLine{00661     CopyMemory(geo-\/>VertexBufferCPU-\/>GetBufferPointer(), vertices.data(), vbByteSize);}
\DoxyCodeLine{00662 }
\DoxyCodeLine{00663     ThrowIfFailed(D3DCreateBlob(ibByteSize, \&geo-\/>IndexBufferCPU));}
\DoxyCodeLine{00664     CopyMemory(geo-\/>IndexBufferCPU-\/>GetBufferPointer(), indices.data(), ibByteSize);}
\DoxyCodeLine{00665 }
\DoxyCodeLine{00666     geo-\/>VertexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{00667         mCommandList.Get(), vertices.data(), vbByteSize, geo-\/>VertexBufferUploader);}
\DoxyCodeLine{00668 }
\DoxyCodeLine{00669     geo-\/>IndexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{00670         mCommandList.Get(), indices.data(), ibByteSize, geo-\/>IndexBufferUploader);}
\DoxyCodeLine{00671 }
\DoxyCodeLine{00672     geo-\/>VertexByteStride = \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{00673     geo-\/>VertexBufferByteSize = vbByteSize;}
\DoxyCodeLine{00674     geo-\/>IndexFormat = DXGI\_FORMAT\_R16\_UINT;}
\DoxyCodeLine{00675     geo-\/>IndexBufferByteSize = ibByteSize;}
\DoxyCodeLine{00676 }
\DoxyCodeLine{00677     geo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}] = boxSubmesh;}
\DoxyCodeLine{00678 }
\DoxyCodeLine{00679     mGeometries[geo-\/>Name] = std::move(geo);}
\DoxyCodeLine{00680 \}}
\DoxyCodeLine{00681 }
\DoxyCodeLine{00682 \textcolor{keywordtype}{void} CrateApp::BuildPSOs()}
\DoxyCodeLine{00683 \{}
\DoxyCodeLine{00684     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC opaquePsoDesc;}
\DoxyCodeLine{00685 }
\DoxyCodeLine{00686     \textcolor{comment}{//}}
\DoxyCodeLine{00687     \textcolor{comment}{// PSO for opaque objects.}}
\DoxyCodeLine{00688     \textcolor{comment}{//}}
\DoxyCodeLine{00689     ZeroMemory(\&opaquePsoDesc, \textcolor{keyword}{sizeof}(D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC));}
\DoxyCodeLine{00690     opaquePsoDesc.InputLayout = \{ mInputLayout.data(), (UINT)mInputLayout.size() \};}
\DoxyCodeLine{00691     opaquePsoDesc.pRootSignature = mRootSignature.Get();}
\DoxyCodeLine{00692     opaquePsoDesc.VS =}
\DoxyCodeLine{00693     \{}
\DoxyCodeLine{00694         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00695         mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00696     \};}
\DoxyCodeLine{00697     opaquePsoDesc.GS =}
\DoxyCodeLine{00698     \{}
\DoxyCodeLine{00699         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}opaqueGS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00700         mShaders[\textcolor{stringliteral}{"{}opaqueGS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00701     \};}
\DoxyCodeLine{00702     opaquePsoDesc.PS =}
\DoxyCodeLine{00703     \{}
\DoxyCodeLine{00704         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00705         mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00706     \};}
\DoxyCodeLine{00707     opaquePsoDesc.RasterizerState = CD3DX12\_RASTERIZER\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00708     opaquePsoDesc.RasterizerState.FillMode = D3D12\_FILL\_MODE\_SOLID;}
\DoxyCodeLine{00709 }
\DoxyCodeLine{00710     opaquePsoDesc.BlendState = CD3DX12\_BLEND\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00711     opaquePsoDesc.DepthStencilState = CD3DX12\_DEPTH\_STENCIL\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00712     opaquePsoDesc.SampleMask = UINT\_MAX;}
\DoxyCodeLine{00713     opaquePsoDesc.PrimitiveTopologyType = D3D12\_PRIMITIVE\_TOPOLOGY\_TYPE\_TRIANGLE;}
\DoxyCodeLine{00714     opaquePsoDesc.NumRenderTargets = 1;}
\DoxyCodeLine{00715     opaquePsoDesc.RTVFormats[0] = mBackBufferFormat;}
\DoxyCodeLine{00716     opaquePsoDesc.SampleDesc.Count = m4xMsaaState ? 4 : 1;}
\DoxyCodeLine{00717     opaquePsoDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality -\/ 1) : 0;}
\DoxyCodeLine{00718     opaquePsoDesc.DSVFormat = mDepthStencilFormat;}
\DoxyCodeLine{00719     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&opaquePsoDesc, IID\_PPV\_ARGS(\&mOpaquePSO)));}
\DoxyCodeLine{00720 }
\DoxyCodeLine{00721     \textcolor{comment}{//}}
\DoxyCodeLine{00722 \textcolor{comment}{// PSO for opaque wireframe objects.}}
\DoxyCodeLine{00723 \textcolor{comment}{//}}
\DoxyCodeLine{00724 }
\DoxyCodeLine{00725     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC opaqueWireframePsoDesc = opaquePsoDesc;}
\DoxyCodeLine{00726     opaqueWireframePsoDesc.RasterizerState.FillMode = D3D12\_FILL\_MODE\_WIREFRAME;}
\DoxyCodeLine{00727     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&opaqueWireframePsoDesc, IID\_PPV\_ARGS(\&mWireframePSO)));}
\DoxyCodeLine{00728 \}}
\DoxyCodeLine{00729 }
\DoxyCodeLine{00730 \textcolor{keywordtype}{void} CrateApp::BuildFrameResources()}
\DoxyCodeLine{00731 \{}
\DoxyCodeLine{00732     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < gNumFrameResources; ++i)}
\DoxyCodeLine{00733     \{}
\DoxyCodeLine{00734         mFrameResources.push\_back(std::make\_unique<FrameResource>(md3dDevice.Get(),}
\DoxyCodeLine{00735             1, (UINT)mAllRitems.size(), (UINT)mMaterials.size()));}
\DoxyCodeLine{00736     \}}
\DoxyCodeLine{00737 \}}
\DoxyCodeLine{00738 }
\DoxyCodeLine{00739 \textcolor{keywordtype}{void} CrateApp::BuildMaterials()}
\DoxyCodeLine{00740 \{}
\DoxyCodeLine{00741     \textcolor{keyword}{auto} woodCrate = std::make\_unique<Material>();}
\DoxyCodeLine{00742     woodCrate-\/>Name = \textcolor{stringliteral}{"{}woodCrate"{}};}
\DoxyCodeLine{00743     woodCrate-\/>MatCBIndex = 0;}
\DoxyCodeLine{00744     woodCrate-\/>DiffuseSrvHeapIndex = 0;}
\DoxyCodeLine{00745     woodCrate-\/>DiffuseAlbedo = XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f);}
\DoxyCodeLine{00746     woodCrate-\/>FresnelR0 = XMFLOAT3(0.05f, 0.05f, 0.05f);}
\DoxyCodeLine{00747     woodCrate-\/>Roughness = 0.2f;}
\DoxyCodeLine{00748 }
\DoxyCodeLine{00749     mMaterials[\textcolor{stringliteral}{"{}woodCrate"{}}] = std::move(woodCrate);}
\DoxyCodeLine{00750 \}}
\DoxyCodeLine{00751 }
\DoxyCodeLine{00752 \textcolor{keywordtype}{void} CrateApp::BuildRenderItems()}
\DoxyCodeLine{00753 \{}
\DoxyCodeLine{00754     \textcolor{keyword}{auto} boxRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{00755     boxRitem-\/>ObjCBIndex = 0;}
\DoxyCodeLine{00756     boxRitem-\/>Mat = mMaterials[\textcolor{stringliteral}{"{}woodCrate"{}}].get();}
\DoxyCodeLine{00757     boxRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}boxGeo"{}}].get();}
\DoxyCodeLine{00758     boxRitem-\/>PrimitiveType = D3D\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{00759     boxRitem-\/>IndexCount = boxRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}].IndexCount;}
\DoxyCodeLine{00760     boxRitem-\/>StartIndexLocation = boxRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}].StartIndexLocation;}
\DoxyCodeLine{00761     boxRitem-\/>BaseVertexLocation = boxRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}].BaseVertexLocation;}
\DoxyCodeLine{00762     mAllRitems.push\_back(std::move(boxRitem));}
\DoxyCodeLine{00763 }
\DoxyCodeLine{00764     \textcolor{comment}{// All the render items are opaque.}}
\DoxyCodeLine{00765     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& e : mAllRitems)}
\DoxyCodeLine{00766         mOpaqueRitems.push\_back(e.get());}
\DoxyCodeLine{00767 \}}
\DoxyCodeLine{00768 }
\DoxyCodeLine{00769 \textcolor{keywordtype}{void} CrateApp::DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems)}
\DoxyCodeLine{00770 \{}
\DoxyCodeLine{00771     UINT objCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(ObjectConstants));}
\DoxyCodeLine{00772     UINT matCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(MaterialConstants));}
\DoxyCodeLine{00773 }
\DoxyCodeLine{00774     \textcolor{keyword}{auto} objectCB = mCurrFrameResource-\/>ObjectCB-\/>Resource();}
\DoxyCodeLine{00775     \textcolor{keyword}{auto} matCB = mCurrFrameResource-\/>MaterialCB-\/>Resource();}
\DoxyCodeLine{00776 }
\DoxyCodeLine{00777     \textcolor{comment}{// For each render item...}}
\DoxyCodeLine{00778     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < ritems.size(); ++i)}
\DoxyCodeLine{00779     \{}
\DoxyCodeLine{00780         \textcolor{keyword}{auto} ri = ritems[i];}
\DoxyCodeLine{00781 }
\DoxyCodeLine{00782         cmdList-\/>IASetVertexBuffers(0, 1, \&ri-\/>Geo-\/>VertexBufferView());}
\DoxyCodeLine{00783         cmdList-\/>IASetIndexBuffer(\&ri-\/>Geo-\/>IndexBufferView());}
\DoxyCodeLine{00784         cmdList-\/>IASetPrimitiveTopology(ri-\/>PrimitiveType);}
\DoxyCodeLine{00785 }
\DoxyCodeLine{00786         CD3DX12\_GPU\_DESCRIPTOR\_HANDLE tex(mSrvDescriptorHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00787         tex.Offset(ri-\/>Mat-\/>DiffuseSrvHeapIndex, mCbvSrvDescriptorSize);}
\DoxyCodeLine{00788 }
\DoxyCodeLine{00789         D3D12\_GPU\_VIRTUAL\_ADDRESS objCBAddress = objectCB-\/>GetGPUVirtualAddress() + ri-\/>ObjCBIndex * objCBByteSize;}
\DoxyCodeLine{00790         D3D12\_GPU\_VIRTUAL\_ADDRESS matCBAddress = matCB-\/>GetGPUVirtualAddress() + ri-\/>Mat-\/>MatCBIndex * matCBByteSize;}
\DoxyCodeLine{00791 }
\DoxyCodeLine{00792         cmdList-\/>SetGraphicsRootDescriptorTable(0, tex);}
\DoxyCodeLine{00793         cmdList-\/>SetGraphicsRootConstantBufferView(1, objCBAddress);}
\DoxyCodeLine{00794         cmdList-\/>SetGraphicsRootConstantBufferView(3, matCBAddress);}
\DoxyCodeLine{00795 }
\DoxyCodeLine{00796         cmdList-\/>DrawIndexedInstanced(ri-\/>IndexCount, 1, ri-\/>StartIndexLocation, ri-\/>BaseVertexLocation, 0);}
\DoxyCodeLine{00797     \}}
\DoxyCodeLine{00798 \}}
\DoxyCodeLine{00799 }
\DoxyCodeLine{00800 std::array<const CD3DX12\_STATIC\_SAMPLER\_DESC, 6> CrateApp::GetStaticSamplers()}
\DoxyCodeLine{00801 \{}
\DoxyCodeLine{00802     \textcolor{comment}{// Applications usually only need a handful of samplers.  So just define them all up front}}
\DoxyCodeLine{00803     \textcolor{comment}{// and keep them available as part of the root signature.  }}
\DoxyCodeLine{00804 }
\DoxyCodeLine{00805     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC pointWrap(}
\DoxyCodeLine{00806         0, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00807         D3D12\_FILTER\_MIN\_MAG\_MIP\_POINT, \textcolor{comment}{// filter}}
\DoxyCodeLine{00808         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00809         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00810         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{00811 }
\DoxyCodeLine{00812     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC pointClamp(}
\DoxyCodeLine{00813         1, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00814         D3D12\_FILTER\_MIN\_MAG\_MIP\_POINT, \textcolor{comment}{// filter}}
\DoxyCodeLine{00815         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00816         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00817         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{00818 }
\DoxyCodeLine{00819     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC linearWrap(}
\DoxyCodeLine{00820         2, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00821         D3D12\_FILTER\_MIN\_MAG\_MIP\_LINEAR, \textcolor{comment}{// filter}}
\DoxyCodeLine{00822         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00823         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00824         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{00825 }
\DoxyCodeLine{00826     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC linearClamp(}
\DoxyCodeLine{00827         3, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00828         D3D12\_FILTER\_MIN\_MAG\_MIP\_LINEAR, \textcolor{comment}{// filter}}
\DoxyCodeLine{00829         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00830         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00831         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{00832 }
\DoxyCodeLine{00833     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC anisotropicWrap(}
\DoxyCodeLine{00834         4, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00835         D3D12\_FILTER\_ANISOTROPIC, \textcolor{comment}{// filter}}
\DoxyCodeLine{00836         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00837         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00838         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressW}}
\DoxyCodeLine{00839         0.0f,                             \textcolor{comment}{// mipLODBias}}
\DoxyCodeLine{00840         8);                               \textcolor{comment}{// maxAnisotropy}}
\DoxyCodeLine{00841 }
\DoxyCodeLine{00842     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC anisotropicClamp(}
\DoxyCodeLine{00843         5, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00844         D3D12\_FILTER\_ANISOTROPIC, \textcolor{comment}{// filter}}
\DoxyCodeLine{00845         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00846         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00847         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressW}}
\DoxyCodeLine{00848         0.0f,                              \textcolor{comment}{// mipLODBias}}
\DoxyCodeLine{00849         8);                                \textcolor{comment}{// maxAnisotropy}}
\DoxyCodeLine{00850 }
\DoxyCodeLine{00851     \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{00852         pointWrap, pointClamp,}
\DoxyCodeLine{00853         linearWrap, linearClamp,}
\DoxyCodeLine{00854         anisotropicWrap, anisotropicClamp \};}
\DoxyCodeLine{00855 \}}
\DoxyCodeLine{00856 }
\DoxyCodeLine{00857 }
\DoxyCodeLine{00858 }
\DoxyCodeLine{00859 }
\DoxyCodeLine{00860 }
\DoxyCodeLine{00861 }
\DoxyCodeLine{00862 }
\DoxyCodeLine{00863 }
\DoxyCodeLine{00864 }

\end{DoxyCode}
