\doxysection{d3d\+Util.\+h}
\label{d3d_util_8h_source}\index{Common/d3dUtil.h@{Common/d3dUtil.h}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 }
\DoxyCodeLine{00002 }
\DoxyCodeLine{00003 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{00004 }
\DoxyCodeLine{00005 \textcolor{preprocessor}{\#include <windows.h>}}
\DoxyCodeLine{00006 \textcolor{preprocessor}{\#include <wrl.h>}}
\DoxyCodeLine{00007 \textcolor{preprocessor}{\#include <dxgi1\_4.h>}}
\DoxyCodeLine{00008 \textcolor{preprocessor}{\#include <d3d12.h>}}
\DoxyCodeLine{00009 \textcolor{preprocessor}{\#include <D3Dcompiler.h>}}
\DoxyCodeLine{00010 \textcolor{preprocessor}{\#include <DirectXMath.h>}}
\DoxyCodeLine{00011 \textcolor{preprocessor}{\#include <DirectXPackedVector.h>}}
\DoxyCodeLine{00012 \textcolor{preprocessor}{\#include <DirectXColors.h>}}
\DoxyCodeLine{00013 \textcolor{preprocessor}{\#include <DirectXCollision.h>}}
\DoxyCodeLine{00014 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{00015 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{00016 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{00017 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{00018 \textcolor{preprocessor}{\#include <array>}}
\DoxyCodeLine{00019 \textcolor{preprocessor}{\#include <unordered\_map>}}
\DoxyCodeLine{00020 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{00021 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{00022 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{00023 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{00024 \textcolor{preprocessor}{\#include "{}d3dx12.h"{}}}
\DoxyCodeLine{00025 \textcolor{preprocessor}{\#include "{}DDSTextureLoader.h"{}}}
\DoxyCodeLine{00026 \textcolor{preprocessor}{\#include "{}MathHelper.h"{}}}
\DoxyCodeLine{00027 }
\DoxyCodeLine{00028 \textcolor{keyword}{extern} \textcolor{keyword}{const} \textcolor{keywordtype}{int} gNumFrameResources;}
\DoxyCodeLine{00029 }
\DoxyCodeLine{00030 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} d3dSetDebugName(IDXGIObject* obj, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name)}
\DoxyCodeLine{00031 \{}
\DoxyCodeLine{00032     \textcolor{keywordflow}{if} (obj)}
\DoxyCodeLine{00033     \{}
\DoxyCodeLine{00034         obj-\/>SetPrivateData(WKPDID\_D3DDebugObjectName, lstrlenA(name), name);}
\DoxyCodeLine{00035     \}}
\DoxyCodeLine{00036 \}}
\DoxyCodeLine{00037 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} d3dSetDebugName(ID3D12Device* obj, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name)}
\DoxyCodeLine{00038 \{}
\DoxyCodeLine{00039     \textcolor{keywordflow}{if} (obj)}
\DoxyCodeLine{00040     \{}
\DoxyCodeLine{00041         obj-\/>SetPrivateData(WKPDID\_D3DDebugObjectName, lstrlenA(name), name);}
\DoxyCodeLine{00042     \}}
\DoxyCodeLine{00043 \}}
\DoxyCodeLine{00044 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} d3dSetDebugName(ID3D12DeviceChild* obj, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name)}
\DoxyCodeLine{00045 \{}
\DoxyCodeLine{00046     \textcolor{keywordflow}{if} (obj)}
\DoxyCodeLine{00047     \{}
\DoxyCodeLine{00048         obj-\/>SetPrivateData(WKPDID\_D3DDebugObjectName, lstrlenA(name), name);}
\DoxyCodeLine{00049     \}}
\DoxyCodeLine{00050 \}}
\DoxyCodeLine{00051 }
\DoxyCodeLine{00052 \textcolor{keyword}{inline} std::wstring AnsiToWString(\textcolor{keyword}{const} std::string\& str)}
\DoxyCodeLine{00053 \{}
\DoxyCodeLine{00054     WCHAR buffer[512];}
\DoxyCodeLine{00055     MultiByteToWideChar(CP\_ACP, 0, str.c\_str(), -\/1, buffer, 512);}
\DoxyCodeLine{00056     \textcolor{keywordflow}{return} std::wstring(buffer);}
\DoxyCodeLine{00057 \}}
\DoxyCodeLine{00058 }
\DoxyCodeLine{00059 \textcolor{comment}{/*}}
\DoxyCodeLine{00060 \textcolor{comment}{\#if defined(\_DEBUG)}}
\DoxyCodeLine{00061 \textcolor{comment}{    \#ifndef Assert}}
\DoxyCodeLine{00062 \textcolor{comment}{    \#define Assert(x, description)                                  \(\backslash\)}}
\DoxyCodeLine{00063 \textcolor{comment}{    \{                                                               \(\backslash\)}}
\DoxyCodeLine{00064 \textcolor{comment}{        static bool ignoreAssert = false;                           \(\backslash\)}}
\DoxyCodeLine{00065 \textcolor{comment}{        if(!ignoreAssert \&\& !(x))                                   \(\backslash\)}}
\DoxyCodeLine{00066 \textcolor{comment}{        \{                                                           \(\backslash\)}}
\DoxyCodeLine{00067 \textcolor{comment}{            Debug::AssertResult result = Debug::ShowAssertDialog(   \(\backslash\)}}
\DoxyCodeLine{00068 \textcolor{comment}{            (L\#x), description, AnsiToWString(\_\_FILE\_\_), \_\_LINE\_\_); \(\backslash\)}}
\DoxyCodeLine{00069 \textcolor{comment}{        if(result == Debug::AssertIgnore)                           \(\backslash\)}}
\DoxyCodeLine{00070 \textcolor{comment}{        \{                                                           \(\backslash\)}}
\DoxyCodeLine{00071 \textcolor{comment}{            ignoreAssert = true;                                    \(\backslash\)}}
\DoxyCodeLine{00072 \textcolor{comment}{        \}                                                           \(\backslash\)}}
\DoxyCodeLine{00073 \textcolor{comment}{                    else if(result == Debug::AssertBreak)           \(\backslash\)}}
\DoxyCodeLine{00074 \textcolor{comment}{        \{                                                           \(\backslash\)}}
\DoxyCodeLine{00075 \textcolor{comment}{            \_\_debugbreak();                                         \(\backslash\)}}
\DoxyCodeLine{00076 \textcolor{comment}{        \}                                                           \(\backslash\)}}
\DoxyCodeLine{00077 \textcolor{comment}{        \}                                                           \(\backslash\)}}
\DoxyCodeLine{00078 \textcolor{comment}{    \}}}
\DoxyCodeLine{00079 \textcolor{comment}{    \#endif}}
\DoxyCodeLine{00080 \textcolor{comment}{\#else}}
\DoxyCodeLine{00081 \textcolor{comment}{    \#ifndef Assert}}
\DoxyCodeLine{00082 \textcolor{comment}{    \#define Assert(x, description)}}
\DoxyCodeLine{00083 \textcolor{comment}{    \#endif}}
\DoxyCodeLine{00084 \textcolor{comment}{\#endif}}
\DoxyCodeLine{00085 \textcolor{comment}{    */}}
\DoxyCodeLine{00086 }
\DoxyCodeLine{00087 \textcolor{keyword}{class }d3dUtil}
\DoxyCodeLine{00088 \{}
\DoxyCodeLine{00089 \textcolor{keyword}{public}:}
\DoxyCodeLine{00090 }
\DoxyCodeLine{00091     \textcolor{keyword}{static} \textcolor{keywordtype}{bool} IsKeyDown(\textcolor{keywordtype}{int} vkeyCode);}
\DoxyCodeLine{00092 }
\DoxyCodeLine{00093     \textcolor{keyword}{static} std::string ToString(HRESULT hr);}
\DoxyCodeLine{00094 }
\DoxyCodeLine{00095     \textcolor{keyword}{static} UINT CalcConstantBufferByteSize(UINT byteSize)}
\DoxyCodeLine{00096     \{}
\DoxyCodeLine{00097         \textcolor{comment}{// Constant buffers must be a multiple of the minimum hardware}}
\DoxyCodeLine{00098         \textcolor{comment}{// allocation size (usually 256 bytes).  So round up to nearest}}
\DoxyCodeLine{00099         \textcolor{comment}{// multiple of 256.  We do this by adding 255 and then masking off}}
\DoxyCodeLine{00100         \textcolor{comment}{// the lower 2 bytes which store all bits < 256.}}
\DoxyCodeLine{00101         \textcolor{comment}{// Example: Suppose byteSize = 300.}}
\DoxyCodeLine{00102         \textcolor{comment}{// (300 + 255) \& \string~255}}
\DoxyCodeLine{00103         \textcolor{comment}{// 555 \& \string~255}}
\DoxyCodeLine{00104         \textcolor{comment}{// 0x022B \& \string~0x00ff}}
\DoxyCodeLine{00105         \textcolor{comment}{// 0x022B \& 0xff00}}
\DoxyCodeLine{00106         \textcolor{comment}{// 0x0200}}
\DoxyCodeLine{00107         \textcolor{comment}{// 512}}
\DoxyCodeLine{00108         \textcolor{keywordflow}{return} (byteSize + 255) \& \string~255;}
\DoxyCodeLine{00109     \}}
\DoxyCodeLine{00110 }
\DoxyCodeLine{00111     \textcolor{keyword}{static} Microsoft::WRL::ComPtr<ID3DBlob> LoadBinary(\textcolor{keyword}{const} std::wstring\& filename);}
\DoxyCodeLine{00112 }
\DoxyCodeLine{00113     \textcolor{keyword}{static} Microsoft::WRL::ComPtr<ID3D12Resource> CreateDefaultBuffer(}
\DoxyCodeLine{00114         ID3D12Device* device,}
\DoxyCodeLine{00115         ID3D12GraphicsCommandList* cmdList,}
\DoxyCodeLine{00116         \textcolor{keyword}{const} \textcolor{keywordtype}{void}* initData,}
\DoxyCodeLine{00117         UINT64 byteSize,}
\DoxyCodeLine{00118         Microsoft::WRL::ComPtr<ID3D12Resource>\& uploadBuffer);}
\DoxyCodeLine{00119 }
\DoxyCodeLine{00120     \textcolor{keyword}{static} Microsoft::WRL::ComPtr<ID3DBlob> CompileShader(}
\DoxyCodeLine{00121         \textcolor{keyword}{const} std::wstring\& filename,}
\DoxyCodeLine{00122         \textcolor{keyword}{const} D3D\_SHADER\_MACRO* defines,}
\DoxyCodeLine{00123         \textcolor{keyword}{const} std::string\& entrypoint,}
\DoxyCodeLine{00124         \textcolor{keyword}{const} std::string\& target);}
\DoxyCodeLine{00125 \};}
\DoxyCodeLine{00126 }
\DoxyCodeLine{00127 \textcolor{keyword}{class }DxException}
\DoxyCodeLine{00128 \{}
\DoxyCodeLine{00129 \textcolor{keyword}{public}:}
\DoxyCodeLine{00130     DxException() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{00131     DxException(HRESULT hr, \textcolor{keyword}{const} std::wstring\& functionName, \textcolor{keyword}{const} std::wstring\& filename, \textcolor{keywordtype}{int} lineNumber);}
\DoxyCodeLine{00132 }
\DoxyCodeLine{00133     std::wstring ToString()\textcolor{keyword}{const};}
\DoxyCodeLine{00134 }
\DoxyCodeLine{00135     HRESULT ErrorCode = S\_OK;}
\DoxyCodeLine{00136     std::wstring FunctionName;}
\DoxyCodeLine{00137     std::wstring Filename;}
\DoxyCodeLine{00138     \textcolor{keywordtype}{int} LineNumber = -\/1;}
\DoxyCodeLine{00139 \};}
\DoxyCodeLine{00140 }
\DoxyCodeLine{00141 \textcolor{comment}{// Defines a subrange of geometry in a MeshGeometry.  This is for when multiple}}
\DoxyCodeLine{00142 \textcolor{comment}{// geometries are stored in one vertex and index buffer.  It provides the offsets}}
\DoxyCodeLine{00143 \textcolor{comment}{// and data needed to draw a subset of geometry stores in the vertex and index }}
\DoxyCodeLine{00144 \textcolor{comment}{// buffers so that we can implement the technique described by Figure 6.3.}}
\DoxyCodeLine{00145 \textcolor{keyword}{struct }SubmeshGeometry}
\DoxyCodeLine{00146 \{}
\DoxyCodeLine{00147     UINT IndexCount = 0;}
\DoxyCodeLine{00148     UINT StartIndexLocation = 0;}
\DoxyCodeLine{00149     INT BaseVertexLocation = 0;}
\DoxyCodeLine{00150 }
\DoxyCodeLine{00151     \textcolor{comment}{// Bounding box of the geometry defined by this submesh. }}
\DoxyCodeLine{00152     \textcolor{comment}{// This is used in later chapters of the book.}}
\DoxyCodeLine{00153     DirectX::BoundingBox Bounds;}
\DoxyCodeLine{00154 \};}
\DoxyCodeLine{00155 }
\DoxyCodeLine{00156 \textcolor{keyword}{struct }MeshGeometry}
\DoxyCodeLine{00157 }
\DoxyCodeLine{00158 \{}
\DoxyCodeLine{00159     \textcolor{comment}{// Give it a name so we can look it up by name.}}
\DoxyCodeLine{00160     std::string Name;}
\DoxyCodeLine{00161 }
\DoxyCodeLine{00162     \textcolor{comment}{// System memory copies.  Use Blobs because the vertex/index format can be generic.}}
\DoxyCodeLine{00163     \textcolor{comment}{// It is up to the client to cast appropriately. }}
\DoxyCodeLine{00164 }
\DoxyCodeLine{00165     Microsoft::WRL::ComPtr<ID3DBlob> VertexBufferCPU = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00166     Microsoft::WRL::ComPtr<ID3DBlob> IndexBufferCPU = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00167     Microsoft::WRL::ComPtr<ID3DBlob> ColorBufferCPU = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00168 }
\DoxyCodeLine{00169 }
\DoxyCodeLine{00170     Microsoft::WRL::ComPtr<ID3D12Resource> VertexBufferGPU = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00171     Microsoft::WRL::ComPtr<ID3D12Resource> IndexBufferGPU = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00172     Microsoft::WRL::ComPtr<ID3D12Resource> ColorBufferGPU = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00173 }
\DoxyCodeLine{00174 }
\DoxyCodeLine{00175     Microsoft::WRL::ComPtr<ID3D12Resource> VertexBufferUploader = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00176     Microsoft::WRL::ComPtr<ID3D12Resource> IndexBufferUploader = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00177     Microsoft::WRL::ComPtr<ID3D12Resource> ColorBufferUploader = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00178 }
\DoxyCodeLine{00179 }
\DoxyCodeLine{00180 }
\DoxyCodeLine{00181     \textcolor{comment}{// Data about the buffers.}}
\DoxyCodeLine{00182     UINT VertexByteStride = 0;}
\DoxyCodeLine{00183     UINT VertexBufferByteSize = 0;}
\DoxyCodeLine{00184     DXGI\_FORMAT IndexFormat = DXGI\_FORMAT\_R16\_UINT;}
\DoxyCodeLine{00185     UINT IndexBufferByteSize = 0;}
\DoxyCodeLine{00186     UINT ColorByteStride = 0;}
\DoxyCodeLine{00187     UINT ColorBufferByteSize = 0;}
\DoxyCodeLine{00188 }
\DoxyCodeLine{00189 }
\DoxyCodeLine{00190     \textcolor{comment}{// A MeshGeometry may store multiple geometries in one vertex/index buffer.}}
\DoxyCodeLine{00191     \textcolor{comment}{// Use this container to define the Submesh geometries so we can draw}}
\DoxyCodeLine{00192     \textcolor{comment}{// the Submeshes individually.}}
\DoxyCodeLine{00193 }
\DoxyCodeLine{00194     std::unordered\_map<std::string, SubmeshGeometry> DrawArgs;}
\DoxyCodeLine{00195 }
\DoxyCodeLine{00196     D3D12\_VERTEX\_BUFFER\_VIEW VertexBufferView()\textcolor{keyword}{const}}
\DoxyCodeLine{00197 \textcolor{keyword}{}}
\DoxyCodeLine{00198 \textcolor{keyword}{    }\{}
\DoxyCodeLine{00199         D3D12\_VERTEX\_BUFFER\_VIEW vbv;}
\DoxyCodeLine{00200         vbv.BufferLocation = VertexBufferGPU-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{00201         vbv.StrideInBytes = VertexByteStride;}
\DoxyCodeLine{00202         vbv.SizeInBytes = VertexBufferByteSize;}
\DoxyCodeLine{00203 }
\DoxyCodeLine{00204         \textcolor{keywordflow}{return} vbv;}
\DoxyCodeLine{00205     \}}
\DoxyCodeLine{00206 }
\DoxyCodeLine{00207     D3D12\_INDEX\_BUFFER\_VIEW IndexBufferView()\textcolor{keyword}{const}}
\DoxyCodeLine{00208 \textcolor{keyword}{}}
\DoxyCodeLine{00209 \textcolor{keyword}{    }\{}
\DoxyCodeLine{00210         D3D12\_INDEX\_BUFFER\_VIEW ibv;}
\DoxyCodeLine{00211         ibv.BufferLocation = IndexBufferGPU-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{00212         ibv.Format = IndexFormat;}
\DoxyCodeLine{00213         ibv.SizeInBytes = IndexBufferByteSize;}
\DoxyCodeLine{00214 }
\DoxyCodeLine{00215         \textcolor{keywordflow}{return} ibv;}
\DoxyCodeLine{00216     \}}
\DoxyCodeLine{00217 }
\DoxyCodeLine{00218     D3D12\_VERTEX\_BUFFER\_VIEW ColorBufferView()\textcolor{keyword}{const}}
\DoxyCodeLine{00219 \textcolor{keyword}{}}
\DoxyCodeLine{00220 \textcolor{keyword}{    }\{}
\DoxyCodeLine{00221         D3D12\_VERTEX\_BUFFER\_VIEW cbv;}
\DoxyCodeLine{00222         cbv.BufferLocation = ColorBufferGPU-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{00223         cbv.StrideInBytes = ColorByteStride;}
\DoxyCodeLine{00224         cbv.SizeInBytes = ColorBufferByteSize;}
\DoxyCodeLine{00225 }
\DoxyCodeLine{00226         \textcolor{keywordflow}{return} cbv;}
\DoxyCodeLine{00227     \}}
\DoxyCodeLine{00228 }
\DoxyCodeLine{00229 }
\DoxyCodeLine{00230     \textcolor{comment}{// We can free this memory after we finish upload to the GPU.}}
\DoxyCodeLine{00231     \textcolor{keywordtype}{void} DisposeUploaders()}
\DoxyCodeLine{00232     \{}
\DoxyCodeLine{00233         VertexBufferUploader = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00234         IndexBufferUploader = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00235         ColorBufferUploader = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00236     \}}
\DoxyCodeLine{00237 \};}
\DoxyCodeLine{00238 }
\DoxyCodeLine{00239 }
\DoxyCodeLine{00240 }
\DoxyCodeLine{00241 }
\DoxyCodeLine{00242 }
\DoxyCodeLine{00243 \textcolor{keyword}{struct }Light}
\DoxyCodeLine{00244 \{}
\DoxyCodeLine{00245     DirectX::XMFLOAT3 Strength = \{ 0.5f, 0.5f, 0.5f \};}
\DoxyCodeLine{00246     \textcolor{keywordtype}{float} FalloffStart = 1.0f;                          \textcolor{comment}{// point/spot light only}}
\DoxyCodeLine{00247     DirectX::XMFLOAT3 Direction = \{ 0.0f, -\/1.0f, 0.0f \};\textcolor{comment}{// directional/spot light only}}
\DoxyCodeLine{00248     \textcolor{keywordtype}{float} FalloffEnd = 10.0f;                           \textcolor{comment}{// point/spot light only}}
\DoxyCodeLine{00249     DirectX::XMFLOAT3 Position = \{ 0.0f, 0.0f, 0.0f \};  \textcolor{comment}{// point/spot light only}}
\DoxyCodeLine{00250     \textcolor{keywordtype}{float} SpotPower = 64.0f;                            \textcolor{comment}{// spot light only}}
\DoxyCodeLine{00251 \};}
\DoxyCodeLine{00252 }
\DoxyCodeLine{00253 \textcolor{preprocessor}{\#define MaxLights 16}}
\DoxyCodeLine{00254 }
\DoxyCodeLine{00255 \textcolor{keyword}{struct }MaterialConstants}
\DoxyCodeLine{00256 \{}
\DoxyCodeLine{00257     DirectX::XMFLOAT4 DiffuseAlbedo = \{ 1.0f, 1.0f, 1.0f, 1.0f \};}
\DoxyCodeLine{00258     DirectX::XMFLOAT3 FresnelR0 = \{ 0.01f, 0.01f, 0.01f \};}
\DoxyCodeLine{00259     \textcolor{keywordtype}{float} Roughness = 0.25f;}
\DoxyCodeLine{00260 }
\DoxyCodeLine{00261     \textcolor{comment}{// Used in texture mapping.}}
\DoxyCodeLine{00262     DirectX::XMFLOAT4X4 MatTransform = MathHelper::Identity4x4();}
\DoxyCodeLine{00263 \};}
\DoxyCodeLine{00264 }
\DoxyCodeLine{00265 \textcolor{comment}{// Simple struct to represent a material for our demos.  A production 3D engine}}
\DoxyCodeLine{00266 \textcolor{comment}{// would likely create a class hierarchy of Materials.}}
\DoxyCodeLine{00267 \textcolor{keyword}{struct }Material}
\DoxyCodeLine{00268 \{}
\DoxyCodeLine{00269     \textcolor{comment}{// Unique material name for lookup.}}
\DoxyCodeLine{00270     std::string Name;}
\DoxyCodeLine{00271 }
\DoxyCodeLine{00272     \textcolor{comment}{// Index into constant buffer corresponding to this material.}}
\DoxyCodeLine{00273     \textcolor{keywordtype}{int} MatCBIndex = -\/1;}
\DoxyCodeLine{00274 }
\DoxyCodeLine{00275     \textcolor{comment}{// Index into SRV heap for diffuse texture.}}
\DoxyCodeLine{00276     \textcolor{keywordtype}{int} DiffuseSrvHeapIndex = -\/1;}
\DoxyCodeLine{00277 }
\DoxyCodeLine{00278     \textcolor{comment}{// Index into SRV heap for normal texture.}}
\DoxyCodeLine{00279     \textcolor{keywordtype}{int} NormalSrvHeapIndex = -\/1;}
\DoxyCodeLine{00280 }
\DoxyCodeLine{00281     \textcolor{comment}{// Dirty flag indicating the material has changed and we need to update the constant buffer.}}
\DoxyCodeLine{00282     \textcolor{comment}{// Because we have a material constant buffer for each FrameResource, we have to apply the}}
\DoxyCodeLine{00283     \textcolor{comment}{// update to each FrameResource.  Thus, when we modify a material we should set }}
\DoxyCodeLine{00284     \textcolor{comment}{// NumFramesDirty = gNumFrameResources so that each frame resource gets the update.}}
\DoxyCodeLine{00285     \textcolor{keywordtype}{int} NumFramesDirty = gNumFrameResources;}
\DoxyCodeLine{00286 }
\DoxyCodeLine{00287     \textcolor{comment}{// Material constant buffer data used for shading.}}
\DoxyCodeLine{00288     DirectX::XMFLOAT4 DiffuseAlbedo = \{ 1.0f, 1.0f, 1.0f, 1.0f \};}
\DoxyCodeLine{00289     DirectX::XMFLOAT3 FresnelR0 = \{ 0.01f, 0.01f, 0.01f \};}
\DoxyCodeLine{00290     \textcolor{keywordtype}{float} Roughness = .25f;}
\DoxyCodeLine{00291     DirectX::XMFLOAT4X4 MatTransform = MathHelper::Identity4x4();}
\DoxyCodeLine{00292 \};}
\DoxyCodeLine{00293 }
\DoxyCodeLine{00294 \textcolor{keyword}{struct }Texture}
\DoxyCodeLine{00295 \{}
\DoxyCodeLine{00296     \textcolor{comment}{// Unique material name for lookup.}}
\DoxyCodeLine{00297     std::string Name;}
\DoxyCodeLine{00298 }
\DoxyCodeLine{00299     std::wstring Filename;}
\DoxyCodeLine{00300 }
\DoxyCodeLine{00301     Microsoft::WRL::ComPtr<ID3D12Resource> Resource = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00302     Microsoft::WRL::ComPtr<ID3D12Resource> UploadHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00303 \};}
\DoxyCodeLine{00304 }
\DoxyCodeLine{00305 \textcolor{preprocessor}{\#ifndef ThrowIfFailed}}
\DoxyCodeLine{00306 \textcolor{preprocessor}{\#define ThrowIfFailed(x)                                              \(\backslash\)}}
\DoxyCodeLine{00307 \textcolor{preprocessor}{\{                                                                     \(\backslash\)}}
\DoxyCodeLine{00308 \textcolor{preprocessor}{    HRESULT hr\_\_ = (x);                                               \(\backslash\)}}
\DoxyCodeLine{00309 \textcolor{preprocessor}{    std::wstring wfn = AnsiToWString(\_\_FILE\_\_);                       \(\backslash\)}}
\DoxyCodeLine{00310 \textcolor{preprocessor}{    if(FAILED(hr\_\_)) \{ throw DxException(hr\_\_, L\#x, wfn, \_\_LINE\_\_); \} \(\backslash\)}}
\DoxyCodeLine{00311 \textcolor{preprocessor}{\}}}
\DoxyCodeLine{00312 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00313 }
\DoxyCodeLine{00314 \textcolor{preprocessor}{\#ifndef ReleaseCom}}
\DoxyCodeLine{00315 \textcolor{preprocessor}{\#define ReleaseCom(x) \{ if(x)\{ x-\/>Release(); x = 0; \} \}}}
\DoxyCodeLine{00316 \textcolor{preprocessor}{\#endif}}

\end{DoxyCode}
