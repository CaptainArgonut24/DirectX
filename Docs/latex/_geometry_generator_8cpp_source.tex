\doxysection{Geometry\+Generator.\+cpp}
\label{_geometry_generator_8cpp_source}\index{Common/GeometryGenerator.cpp@{Common/GeometryGenerator.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00002 \textcolor{comment}{// GeometryGenerator.cpp by Frank Luna (C) 2011 All Rights Reserved.}}
\DoxyCodeLine{00003 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00004 }
\DoxyCodeLine{00005 \textcolor{preprocessor}{\#include "{}GeometryGenerator.h"{}}}
\DoxyCodeLine{00006 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{00007 }
\DoxyCodeLine{00008 \textcolor{keyword}{using namespace }DirectX;}
\DoxyCodeLine{00009 }
\DoxyCodeLine{00010 GeometryGenerator::MeshData GeometryGenerator::CreateBox(\textcolor{keywordtype}{float} width, \textcolor{keywordtype}{float} height, \textcolor{keywordtype}{float} depth, uint32 numSubdivisions)}
\DoxyCodeLine{00011 \{}
\DoxyCodeLine{00012     MeshData meshData;}
\DoxyCodeLine{00013 }
\DoxyCodeLine{00014     \textcolor{comment}{//}}
\DoxyCodeLine{00015     \textcolor{comment}{// Create the vertices.}}
\DoxyCodeLine{00016     \textcolor{comment}{//}}
\DoxyCodeLine{00017 }
\DoxyCodeLine{00018     Vertex v[24];}
\DoxyCodeLine{00019 }
\DoxyCodeLine{00020     \textcolor{keywordtype}{float} w2 = 0.5f*width;}
\DoxyCodeLine{00021     \textcolor{keywordtype}{float} h2 = 0.5f*height;}
\DoxyCodeLine{00022     \textcolor{keywordtype}{float} d2 = 0.5f*depth;}
\DoxyCodeLine{00023     }
\DoxyCodeLine{00024     \textcolor{comment}{// Fill in the front face vertex data.}}
\DoxyCodeLine{00025     v[0] = Vertex(-\/w2, -\/h2, -\/d2, 0.0f, 0.0f, -\/1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);}
\DoxyCodeLine{00026     v[1] = Vertex(-\/w2, +h2, -\/d2, 0.0f, 0.0f, -\/1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00027     v[2] = Vertex(+w2, +h2, -\/d2, 0.0f, 0.0f, -\/1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f);}
\DoxyCodeLine{00028     v[3] = Vertex(+w2, -\/h2, -\/d2, 0.0f, 0.0f, -\/1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f);}
\DoxyCodeLine{00029 }
\DoxyCodeLine{00030     \textcolor{comment}{// Fill in the back face vertex data.}}
\DoxyCodeLine{00031     v[4] = Vertex(-\/w2, -\/h2, +d2, 0.0f, 0.0f, 1.0f, -\/1.0f, 0.0f, 0.0f, 1.0f, 1.0f);}
\DoxyCodeLine{00032     v[5] = Vertex(+w2, -\/h2, +d2, 0.0f, 0.0f, 1.0f, -\/1.0f, 0.0f, 0.0f, 0.0f, 1.0f);}
\DoxyCodeLine{00033     v[6] = Vertex(+w2, +h2, +d2, 0.0f, 0.0f, 1.0f, -\/1.0f, 0.0f, 0.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00034     v[7] = Vertex(-\/w2, +h2, +d2, 0.0f, 0.0f, 1.0f, -\/1.0f, 0.0f, 0.0f, 1.0f, 0.0f);}
\DoxyCodeLine{00035 }
\DoxyCodeLine{00036     \textcolor{comment}{// Fill in the top face vertex data.}}
\DoxyCodeLine{00037     v[8]  = Vertex(-\/w2, +h2, -\/d2, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);}
\DoxyCodeLine{00038     v[9]  = Vertex(-\/w2, +h2, +d2, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00039     v[10] = Vertex(+w2, +h2, +d2, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f);}
\DoxyCodeLine{00040     v[11] = Vertex(+w2, +h2, -\/d2, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f);}
\DoxyCodeLine{00041 }
\DoxyCodeLine{00042     \textcolor{comment}{// Fill in the bottom face vertex data.}}
\DoxyCodeLine{00043     v[12] = Vertex(-\/w2, -\/h2, -\/d2, 0.0f, -\/1.0f, 0.0f, -\/1.0f, 0.0f, 0.0f, 1.0f, 1.0f);}
\DoxyCodeLine{00044     v[13] = Vertex(+w2, -\/h2, -\/d2, 0.0f, -\/1.0f, 0.0f, -\/1.0f, 0.0f, 0.0f, 0.0f, 1.0f);}
\DoxyCodeLine{00045     v[14] = Vertex(+w2, -\/h2, +d2, 0.0f, -\/1.0f, 0.0f, -\/1.0f, 0.0f, 0.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00046     v[15] = Vertex(-\/w2, -\/h2, +d2, 0.0f, -\/1.0f, 0.0f, -\/1.0f, 0.0f, 0.0f, 1.0f, 0.0f);}
\DoxyCodeLine{00047 }
\DoxyCodeLine{00048     \textcolor{comment}{// Fill in the left face vertex data.}}
\DoxyCodeLine{00049     v[16] = Vertex(-\/w2, -\/h2, +d2, -\/1.0f, 0.0f, 0.0f, 0.0f, 0.0f, -\/1.0f, 0.0f, 1.0f);}
\DoxyCodeLine{00050     v[17] = Vertex(-\/w2, +h2, +d2, -\/1.0f, 0.0f, 0.0f, 0.0f, 0.0f, -\/1.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00051     v[18] = Vertex(-\/w2, +h2, -\/d2, -\/1.0f, 0.0f, 0.0f, 0.0f, 0.0f, -\/1.0f, 1.0f, 0.0f);}
\DoxyCodeLine{00052     v[19] = Vertex(-\/w2, -\/h2, -\/d2, -\/1.0f, 0.0f, 0.0f, 0.0f, 0.0f, -\/1.0f, 1.0f, 1.0f);}
\DoxyCodeLine{00053 }
\DoxyCodeLine{00054     \textcolor{comment}{// Fill in the right face vertex data.}}
\DoxyCodeLine{00055     v[20] = Vertex(+w2, -\/h2, -\/d2, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f);}
\DoxyCodeLine{00056     v[21] = Vertex(+w2, +h2, -\/d2, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00057     v[22] = Vertex(+w2, +h2, +d2, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f);}
\DoxyCodeLine{00058     v[23] = Vertex(+w2, -\/h2, +d2, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);}
\DoxyCodeLine{00059 }
\DoxyCodeLine{00060     meshData.Vertices.assign(\&v[0], \&v[24]);}
\DoxyCodeLine{00061  }
\DoxyCodeLine{00062     \textcolor{comment}{//}}
\DoxyCodeLine{00063     \textcolor{comment}{// Create the indices.}}
\DoxyCodeLine{00064     \textcolor{comment}{//}}
\DoxyCodeLine{00065 }
\DoxyCodeLine{00066     uint32 i[36];}
\DoxyCodeLine{00067 }
\DoxyCodeLine{00068     \textcolor{comment}{// Fill in the front face index data}}
\DoxyCodeLine{00069     i[0] = 0; i[1] = 1; i[2] = 2;}
\DoxyCodeLine{00070     i[3] = 0; i[4] = 2; i[5] = 3;}
\DoxyCodeLine{00071 }
\DoxyCodeLine{00072     \textcolor{comment}{// Fill in the back face index data}}
\DoxyCodeLine{00073     i[6] = 4; i[7]  = 5; i[8]  = 6;}
\DoxyCodeLine{00074     i[9] = 4; i[10] = 6; i[11] = 7;}
\DoxyCodeLine{00075 }
\DoxyCodeLine{00076     \textcolor{comment}{// Fill in the top face index data}}
\DoxyCodeLine{00077     i[12] = 8; i[13] =  9; i[14] = 10;}
\DoxyCodeLine{00078     i[15] = 8; i[16] = 10; i[17] = 11;}
\DoxyCodeLine{00079 }
\DoxyCodeLine{00080     \textcolor{comment}{// Fill in the bottom face index data}}
\DoxyCodeLine{00081     i[18] = 12; i[19] = 13; i[20] = 14;}
\DoxyCodeLine{00082     i[21] = 12; i[22] = 14; i[23] = 15;}
\DoxyCodeLine{00083 }
\DoxyCodeLine{00084     \textcolor{comment}{// Fill in the left face index data}}
\DoxyCodeLine{00085     i[24] = 16; i[25] = 17; i[26] = 18;}
\DoxyCodeLine{00086     i[27] = 16; i[28] = 18; i[29] = 19;}
\DoxyCodeLine{00087 }
\DoxyCodeLine{00088     \textcolor{comment}{// Fill in the right face index data}}
\DoxyCodeLine{00089     i[30] = 20; i[31] = 21; i[32] = 22;}
\DoxyCodeLine{00090     i[33] = 20; i[34] = 22; i[35] = 23;}
\DoxyCodeLine{00091 }
\DoxyCodeLine{00092     meshData.Indices32.assign(\&i[0], \&i[36]);}
\DoxyCodeLine{00093 }
\DoxyCodeLine{00094     \textcolor{comment}{// Put a cap on the number of subdivisions.}}
\DoxyCodeLine{00095     numSubdivisions = std::min<uint32>(numSubdivisions, 6u);}
\DoxyCodeLine{00096 }
\DoxyCodeLine{00097     \textcolor{keywordflow}{for}(uint32 i = 0; i < numSubdivisions; ++i)}
\DoxyCodeLine{00098         Subdivide(meshData);}
\DoxyCodeLine{00099 }
\DoxyCodeLine{00100     \textcolor{keywordflow}{return} meshData;}
\DoxyCodeLine{00101 \}}
\DoxyCodeLine{00102 }
\DoxyCodeLine{00103 GeometryGenerator::MeshData GeometryGenerator::CreateSphere(\textcolor{keywordtype}{float} radius, uint32 sliceCount, uint32 stackCount)}
\DoxyCodeLine{00104 \{}
\DoxyCodeLine{00105     MeshData meshData;}
\DoxyCodeLine{00106 }
\DoxyCodeLine{00107     \textcolor{comment}{//}}
\DoxyCodeLine{00108     \textcolor{comment}{// Compute the vertices stating at the top pole and moving down the stacks.}}
\DoxyCodeLine{00109     \textcolor{comment}{//}}
\DoxyCodeLine{00110 }
\DoxyCodeLine{00111     \textcolor{comment}{// Poles: note that there will be texture coordinate distortion as there is}}
\DoxyCodeLine{00112     \textcolor{comment}{// not a unique point on the texture map to assign to the pole when mapping}}
\DoxyCodeLine{00113     \textcolor{comment}{// a rectangular texture onto a sphere.}}
\DoxyCodeLine{00114     Vertex topVertex(0.0f, +radius, 0.0f, 0.0f, +1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00115     Vertex bottomVertex(0.0f, -\/radius, 0.0f, 0.0f, -\/1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);}
\DoxyCodeLine{00116 }
\DoxyCodeLine{00117     meshData.Vertices.push\_back( topVertex );}
\DoxyCodeLine{00118 }
\DoxyCodeLine{00119     \textcolor{keywordtype}{float} phiStep   = XM\_PI/stackCount;}
\DoxyCodeLine{00120     \textcolor{keywordtype}{float} thetaStep = 2.0f*XM\_PI/sliceCount;}
\DoxyCodeLine{00121 }
\DoxyCodeLine{00122     \textcolor{comment}{// Compute vertices for each stack ring (do not count the poles as rings).}}
\DoxyCodeLine{00123     \textcolor{keywordflow}{for}(uint32 i = 1; i <= stackCount-\/1; ++i)}
\DoxyCodeLine{00124     \{}
\DoxyCodeLine{00125         \textcolor{keywordtype}{float} phi = i*phiStep;}
\DoxyCodeLine{00126 }
\DoxyCodeLine{00127         \textcolor{comment}{// Vertices of ring.}}
\DoxyCodeLine{00128         \textcolor{keywordflow}{for}(uint32 j = 0; j <= sliceCount; ++j)}
\DoxyCodeLine{00129         \{}
\DoxyCodeLine{00130             \textcolor{keywordtype}{float} theta = j*thetaStep;}
\DoxyCodeLine{00131 }
\DoxyCodeLine{00132             Vertex v;}
\DoxyCodeLine{00133 }
\DoxyCodeLine{00134             \textcolor{comment}{// spherical to cartesian}}
\DoxyCodeLine{00135             v.Position.x = radius*sinf(phi)*cosf(theta);}
\DoxyCodeLine{00136             v.Position.y = radius*cosf(phi);}
\DoxyCodeLine{00137             v.Position.z = radius*sinf(phi)*sinf(theta);}
\DoxyCodeLine{00138 }
\DoxyCodeLine{00139             \textcolor{comment}{// Partial derivative of P with respect to theta}}
\DoxyCodeLine{00140             v.TangentU.x = -\/radius*sinf(phi)*sinf(theta);}
\DoxyCodeLine{00141             v.TangentU.y = 0.0f;}
\DoxyCodeLine{00142             v.TangentU.z = +radius*sinf(phi)*cosf(theta);}
\DoxyCodeLine{00143 }
\DoxyCodeLine{00144             XMVECTOR T = XMLoadFloat3(\&v.TangentU);}
\DoxyCodeLine{00145             XMStoreFloat3(\&v.TangentU, XMVector3Normalize(T));}
\DoxyCodeLine{00146 }
\DoxyCodeLine{00147             XMVECTOR p = XMLoadFloat3(\&v.Position);}
\DoxyCodeLine{00148             XMStoreFloat3(\&v.Normal, XMVector3Normalize(p));}
\DoxyCodeLine{00149 }
\DoxyCodeLine{00150             v.TexC.x = theta / XM\_2PI;}
\DoxyCodeLine{00151             v.TexC.y = phi / XM\_PI;}
\DoxyCodeLine{00152 }
\DoxyCodeLine{00153             meshData.Vertices.push\_back( v );}
\DoxyCodeLine{00154         \}}
\DoxyCodeLine{00155     \}}
\DoxyCodeLine{00156 }
\DoxyCodeLine{00157     meshData.Vertices.push\_back( bottomVertex );}
\DoxyCodeLine{00158 }
\DoxyCodeLine{00159     \textcolor{comment}{//}}
\DoxyCodeLine{00160     \textcolor{comment}{// Compute indices for top stack.  The top stack was written first to the vertex buffer}}
\DoxyCodeLine{00161     \textcolor{comment}{// and connects the top pole to the first ring.}}
\DoxyCodeLine{00162     \textcolor{comment}{//}}
\DoxyCodeLine{00163 }
\DoxyCodeLine{00164     \textcolor{keywordflow}{for}(uint32 i = 1; i <= sliceCount; ++i)}
\DoxyCodeLine{00165     \{}
\DoxyCodeLine{00166         meshData.Indices32.push\_back(0);}
\DoxyCodeLine{00167         meshData.Indices32.push\_back(i+1);}
\DoxyCodeLine{00168         meshData.Indices32.push\_back(i);}
\DoxyCodeLine{00169     \}}
\DoxyCodeLine{00170     }
\DoxyCodeLine{00171     \textcolor{comment}{//}}
\DoxyCodeLine{00172     \textcolor{comment}{// Compute indices for inner stacks (not connected to poles).}}
\DoxyCodeLine{00173     \textcolor{comment}{//}}
\DoxyCodeLine{00174 }
\DoxyCodeLine{00175     \textcolor{comment}{// Offset the indices to the index of the first vertex in the first ring.}}
\DoxyCodeLine{00176     \textcolor{comment}{// This is just skipping the top pole vertex.}}
\DoxyCodeLine{00177     uint32 baseIndex = 1;}
\DoxyCodeLine{00178     uint32 ringVertexCount = sliceCount + 1;}
\DoxyCodeLine{00179     \textcolor{keywordflow}{for}(uint32 i = 0; i < stackCount-\/2; ++i)}
\DoxyCodeLine{00180     \{}
\DoxyCodeLine{00181         \textcolor{keywordflow}{for}(uint32 j = 0; j < sliceCount; ++j)}
\DoxyCodeLine{00182         \{}
\DoxyCodeLine{00183             meshData.Indices32.push\_back(baseIndex + i*ringVertexCount + j);}
\DoxyCodeLine{00184             meshData.Indices32.push\_back(baseIndex + i*ringVertexCount + j+1);}
\DoxyCodeLine{00185             meshData.Indices32.push\_back(baseIndex + (i+1)*ringVertexCount + j);}
\DoxyCodeLine{00186 }
\DoxyCodeLine{00187             meshData.Indices32.push\_back(baseIndex + (i+1)*ringVertexCount + j);}
\DoxyCodeLine{00188             meshData.Indices32.push\_back(baseIndex + i*ringVertexCount + j+1);}
\DoxyCodeLine{00189             meshData.Indices32.push\_back(baseIndex + (i+1)*ringVertexCount + j+1);}
\DoxyCodeLine{00190         \}}
\DoxyCodeLine{00191     \}}
\DoxyCodeLine{00192 }
\DoxyCodeLine{00193     \textcolor{comment}{//}}
\DoxyCodeLine{00194     \textcolor{comment}{// Compute indices for bottom stack.  The bottom stack was written last to the vertex buffer}}
\DoxyCodeLine{00195     \textcolor{comment}{// and connects the bottom pole to the bottom ring.}}
\DoxyCodeLine{00196     \textcolor{comment}{//}}
\DoxyCodeLine{00197 }
\DoxyCodeLine{00198     \textcolor{comment}{// South pole vertex was added last.}}
\DoxyCodeLine{00199     uint32 southPoleIndex = (uint32)meshData.Vertices.size()-\/1;}
\DoxyCodeLine{00200 }
\DoxyCodeLine{00201     \textcolor{comment}{// Offset the indices to the index of the first vertex in the last ring.}}
\DoxyCodeLine{00202     baseIndex = southPoleIndex -\/ ringVertexCount;}
\DoxyCodeLine{00203     }
\DoxyCodeLine{00204     \textcolor{keywordflow}{for}(uint32 i = 0; i < sliceCount; ++i)}
\DoxyCodeLine{00205     \{}
\DoxyCodeLine{00206         meshData.Indices32.push\_back(southPoleIndex);}
\DoxyCodeLine{00207         meshData.Indices32.push\_back(baseIndex+i);}
\DoxyCodeLine{00208         meshData.Indices32.push\_back(baseIndex+i+1);}
\DoxyCodeLine{00209     \}}
\DoxyCodeLine{00210 }
\DoxyCodeLine{00211     \textcolor{keywordflow}{return} meshData;}
\DoxyCodeLine{00212 \}}
\DoxyCodeLine{00213  }
\DoxyCodeLine{00214 \textcolor{keywordtype}{void} GeometryGenerator::Subdivide(MeshData\& meshData)}
\DoxyCodeLine{00215 \{}
\DoxyCodeLine{00216     \textcolor{comment}{// Save a copy of the input geometry.}}
\DoxyCodeLine{00217     MeshData inputCopy = meshData;}
\DoxyCodeLine{00218 }
\DoxyCodeLine{00219 }
\DoxyCodeLine{00220     meshData.Vertices.resize(0);}
\DoxyCodeLine{00221     meshData.Indices32.resize(0);}
\DoxyCodeLine{00222 }
\DoxyCodeLine{00223     \textcolor{comment}{//       v1}}
\DoxyCodeLine{00224     \textcolor{comment}{//       *}}
\DoxyCodeLine{00225     \textcolor{comment}{//      / \(\backslash\)}}
\DoxyCodeLine{00226 \textcolor{comment}{    //     /   \(\backslash\)}}
\DoxyCodeLine{00227 \textcolor{comment}{    //  m0*-\/-\/-\/-\/-\/*m1}}
\DoxyCodeLine{00228     \textcolor{comment}{//   / \(\backslash\)   / \(\backslash\)}}
\DoxyCodeLine{00229 \textcolor{comment}{    //  /   \(\backslash\) /   \(\backslash\)}}
\DoxyCodeLine{00230 \textcolor{comment}{    // *-\/-\/-\/-\/-\/*-\/-\/-\/-\/-\/*}}
\DoxyCodeLine{00231     \textcolor{comment}{// v0    m2     v2}}
\DoxyCodeLine{00232 }
\DoxyCodeLine{00233     uint32 numTris = (uint32)inputCopy.Indices32.size()/3;}
\DoxyCodeLine{00234     \textcolor{keywordflow}{for}(uint32 i = 0; i < numTris; ++i)}
\DoxyCodeLine{00235     \{}
\DoxyCodeLine{00236         Vertex v0 = inputCopy.Vertices[ inputCopy.Indices32[i*3+0] ];}
\DoxyCodeLine{00237         Vertex v1 = inputCopy.Vertices[ inputCopy.Indices32[i*3+1] ];}
\DoxyCodeLine{00238         Vertex v2 = inputCopy.Vertices[ inputCopy.Indices32[i*3+2] ];}
\DoxyCodeLine{00239 }
\DoxyCodeLine{00240         \textcolor{comment}{//}}
\DoxyCodeLine{00241         \textcolor{comment}{// Generate the midpoints.}}
\DoxyCodeLine{00242         \textcolor{comment}{//}}
\DoxyCodeLine{00243 }
\DoxyCodeLine{00244         Vertex m0 = MidPoint(v0, v1);}
\DoxyCodeLine{00245         Vertex m1 = MidPoint(v1, v2);}
\DoxyCodeLine{00246         Vertex m2 = MidPoint(v0, v2);}
\DoxyCodeLine{00247 }
\DoxyCodeLine{00248         \textcolor{comment}{//}}
\DoxyCodeLine{00249         \textcolor{comment}{// Add new geometry.}}
\DoxyCodeLine{00250         \textcolor{comment}{//}}
\DoxyCodeLine{00251 }
\DoxyCodeLine{00252         meshData.Vertices.push\_back(v0); \textcolor{comment}{// 0}}
\DoxyCodeLine{00253         meshData.Vertices.push\_back(v1); \textcolor{comment}{// 1}}
\DoxyCodeLine{00254         meshData.Vertices.push\_back(v2); \textcolor{comment}{// 2}}
\DoxyCodeLine{00255         meshData.Vertices.push\_back(m0); \textcolor{comment}{// 3}}
\DoxyCodeLine{00256         meshData.Vertices.push\_back(m1); \textcolor{comment}{// 4}}
\DoxyCodeLine{00257         meshData.Vertices.push\_back(m2); \textcolor{comment}{// 5}}
\DoxyCodeLine{00258  }
\DoxyCodeLine{00259         meshData.Indices32.push\_back(i*6+0);}
\DoxyCodeLine{00260         meshData.Indices32.push\_back(i*6+3);}
\DoxyCodeLine{00261         meshData.Indices32.push\_back(i*6+5);}
\DoxyCodeLine{00262 }
\DoxyCodeLine{00263         meshData.Indices32.push\_back(i*6+3);}
\DoxyCodeLine{00264         meshData.Indices32.push\_back(i*6+4);}
\DoxyCodeLine{00265         meshData.Indices32.push\_back(i*6+5);}
\DoxyCodeLine{00266 }
\DoxyCodeLine{00267         meshData.Indices32.push\_back(i*6+5);}
\DoxyCodeLine{00268         meshData.Indices32.push\_back(i*6+4);}
\DoxyCodeLine{00269         meshData.Indices32.push\_back(i*6+2);}
\DoxyCodeLine{00270 }
\DoxyCodeLine{00271         meshData.Indices32.push\_back(i*6+3);}
\DoxyCodeLine{00272         meshData.Indices32.push\_back(i*6+1);}
\DoxyCodeLine{00273         meshData.Indices32.push\_back(i*6+4);}
\DoxyCodeLine{00274     \}}
\DoxyCodeLine{00275 \}}
\DoxyCodeLine{00276 }
\DoxyCodeLine{00277 GeometryGenerator::Vertex GeometryGenerator::MidPoint(\textcolor{keyword}{const} Vertex\& v0, \textcolor{keyword}{const} Vertex\& v1)}
\DoxyCodeLine{00278 \{}
\DoxyCodeLine{00279     XMVECTOR p0 = XMLoadFloat3(\&v0.Position);}
\DoxyCodeLine{00280     XMVECTOR p1 = XMLoadFloat3(\&v1.Position);}
\DoxyCodeLine{00281 }
\DoxyCodeLine{00282     XMVECTOR n0 = XMLoadFloat3(\&v0.Normal);}
\DoxyCodeLine{00283     XMVECTOR n1 = XMLoadFloat3(\&v1.Normal);}
\DoxyCodeLine{00284 }
\DoxyCodeLine{00285     XMVECTOR tan0 = XMLoadFloat3(\&v0.TangentU);}
\DoxyCodeLine{00286     XMVECTOR tan1 = XMLoadFloat3(\&v1.TangentU);}
\DoxyCodeLine{00287 }
\DoxyCodeLine{00288     XMVECTOR tex0 = XMLoadFloat2(\&v0.TexC);}
\DoxyCodeLine{00289     XMVECTOR tex1 = XMLoadFloat2(\&v1.TexC);}
\DoxyCodeLine{00290 }
\DoxyCodeLine{00291     \textcolor{comment}{// Compute the midpoints of all the attributes.  Vectors need to be normalized}}
\DoxyCodeLine{00292     \textcolor{comment}{// since linear interpolating can make them not unit length.  }}
\DoxyCodeLine{00293     XMVECTOR pos = 0.5f*(p0 + p1);}
\DoxyCodeLine{00294     XMVECTOR normal = XMVector3Normalize(0.5f*(n0 + n1));}
\DoxyCodeLine{00295     XMVECTOR tangent = XMVector3Normalize(0.5f*(tan0+tan1));}
\DoxyCodeLine{00296     XMVECTOR tex = 0.5f*(tex0 + tex1);}
\DoxyCodeLine{00297 }
\DoxyCodeLine{00298     Vertex v;}
\DoxyCodeLine{00299     XMStoreFloat3(\&v.Position, pos);}
\DoxyCodeLine{00300     XMStoreFloat3(\&v.Normal, normal);}
\DoxyCodeLine{00301     XMStoreFloat3(\&v.TangentU, tangent);}
\DoxyCodeLine{00302     XMStoreFloat2(\&v.TexC, tex);}
\DoxyCodeLine{00303 }
\DoxyCodeLine{00304     \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{00305 \}}
\DoxyCodeLine{00306 }
\DoxyCodeLine{00307 GeometryGenerator::MeshData GeometryGenerator::CreateGeosphere(\textcolor{keywordtype}{float} radius, uint32 numSubdivisions)}
\DoxyCodeLine{00308 \{}
\DoxyCodeLine{00309     MeshData meshData;}
\DoxyCodeLine{00310 }
\DoxyCodeLine{00311     \textcolor{comment}{// Put a cap on the number of subdivisions.}}
\DoxyCodeLine{00312     numSubdivisions = std::min<uint32>(numSubdivisions, 6u);}
\DoxyCodeLine{00313 }
\DoxyCodeLine{00314     \textcolor{comment}{// Approximate a sphere by tessellating an icosahedron.}}
\DoxyCodeLine{00315 }
\DoxyCodeLine{00316     \textcolor{keyword}{const} \textcolor{keywordtype}{float} X = 0.525731f; }
\DoxyCodeLine{00317     \textcolor{keyword}{const} \textcolor{keywordtype}{float} Z = 0.850651f;}
\DoxyCodeLine{00318 }
\DoxyCodeLine{00319     XMFLOAT3 pos[12] = }
\DoxyCodeLine{00320     \{}
\DoxyCodeLine{00321         XMFLOAT3(-\/X, 0.0f, Z),  XMFLOAT3(X, 0.0f, Z),  }
\DoxyCodeLine{00322         XMFLOAT3(-\/X, 0.0f, -\/Z), XMFLOAT3(X, 0.0f, -\/Z),    }
\DoxyCodeLine{00323         XMFLOAT3(0.0f, Z, X),   XMFLOAT3(0.0f, Z, -\/X), }
\DoxyCodeLine{00324         XMFLOAT3(0.0f, -\/Z, X),  XMFLOAT3(0.0f, -\/Z, -\/X),    }
\DoxyCodeLine{00325         XMFLOAT3(Z, X, 0.0f),   XMFLOAT3(-\/Z, X, 0.0f), }
\DoxyCodeLine{00326         XMFLOAT3(Z, -\/X, 0.0f),  XMFLOAT3(-\/Z, -\/X, 0.0f)}
\DoxyCodeLine{00327     \};}
\DoxyCodeLine{00328 }
\DoxyCodeLine{00329     uint32 k[60] =}
\DoxyCodeLine{00330     \{}
\DoxyCodeLine{00331         1,4,0,  4,9,0,  4,5,9,  8,5,4,  1,8,4,    }
\DoxyCodeLine{00332         1,10,8, 10,3,8, 8,3,5,  3,2,5,  3,7,2,    }
\DoxyCodeLine{00333         3,10,7, 10,6,7, 6,11,7, 6,0,11, 6,1,0, }
\DoxyCodeLine{00334         10,1,6, 11,0,9, 2,11,9, 5,2,9,  11,2,7 }
\DoxyCodeLine{00335     \};}
\DoxyCodeLine{00336 }
\DoxyCodeLine{00337     meshData.Vertices.resize(12);}
\DoxyCodeLine{00338     meshData.Indices32.assign(\&k[0], \&k[60]);}
\DoxyCodeLine{00339 }
\DoxyCodeLine{00340     \textcolor{keywordflow}{for}(uint32 i = 0; i < 12; ++i)}
\DoxyCodeLine{00341         meshData.Vertices[i].Position = pos[i];}
\DoxyCodeLine{00342 }
\DoxyCodeLine{00343     \textcolor{keywordflow}{for}(uint32 i = 0; i < numSubdivisions; ++i)}
\DoxyCodeLine{00344         Subdivide(meshData);}
\DoxyCodeLine{00345 }
\DoxyCodeLine{00346     \textcolor{comment}{// Project vertices onto sphere and scale.}}
\DoxyCodeLine{00347     \textcolor{keywordflow}{for}(uint32 i = 0; i < meshData.Vertices.size(); ++i)}
\DoxyCodeLine{00348     \{}
\DoxyCodeLine{00349         \textcolor{comment}{// Project onto unit sphere.}}
\DoxyCodeLine{00350         XMVECTOR n = XMVector3Normalize(XMLoadFloat3(\&meshData.Vertices[i].Position));}
\DoxyCodeLine{00351 }
\DoxyCodeLine{00352         \textcolor{comment}{// Project onto sphere.}}
\DoxyCodeLine{00353         XMVECTOR p = radius*n;}
\DoxyCodeLine{00354 }
\DoxyCodeLine{00355         XMStoreFloat3(\&meshData.Vertices[i].Position, p);}
\DoxyCodeLine{00356         XMStoreFloat3(\&meshData.Vertices[i].Normal, n);}
\DoxyCodeLine{00357 }
\DoxyCodeLine{00358         \textcolor{comment}{// Derive texture coordinates from spherical coordinates.}}
\DoxyCodeLine{00359         \textcolor{keywordtype}{float} theta = atan2f(meshData.Vertices[i].Position.z, meshData.Vertices[i].Position.x);}
\DoxyCodeLine{00360 }
\DoxyCodeLine{00361         \textcolor{comment}{// Put in [0, 2pi].}}
\DoxyCodeLine{00362         \textcolor{keywordflow}{if}(theta < 0.0f)}
\DoxyCodeLine{00363             theta += XM\_2PI;}
\DoxyCodeLine{00364 }
\DoxyCodeLine{00365         \textcolor{keywordtype}{float} phi = acosf(meshData.Vertices[i].Position.y / radius);}
\DoxyCodeLine{00366 }
\DoxyCodeLine{00367         meshData.Vertices[i].TexC.x = theta/XM\_2PI;}
\DoxyCodeLine{00368         meshData.Vertices[i].TexC.y = phi/XM\_PI;}
\DoxyCodeLine{00369 }
\DoxyCodeLine{00370         \textcolor{comment}{// Partial derivative of P with respect to theta}}
\DoxyCodeLine{00371         meshData.Vertices[i].TangentU.x = -\/radius*sinf(phi)*sinf(theta);}
\DoxyCodeLine{00372         meshData.Vertices[i].TangentU.y = 0.0f;}
\DoxyCodeLine{00373         meshData.Vertices[i].TangentU.z = +radius*sinf(phi)*cosf(theta);}
\DoxyCodeLine{00374 }
\DoxyCodeLine{00375         XMVECTOR T = XMLoadFloat3(\&meshData.Vertices[i].TangentU);}
\DoxyCodeLine{00376         XMStoreFloat3(\&meshData.Vertices[i].TangentU, XMVector3Normalize(T));}
\DoxyCodeLine{00377     \}}
\DoxyCodeLine{00378 }
\DoxyCodeLine{00379     \textcolor{keywordflow}{return} meshData;}
\DoxyCodeLine{00380 \}}
\DoxyCodeLine{00381 }
\DoxyCodeLine{00382 GeometryGenerator::MeshData GeometryGenerator::CreateCylinder(\textcolor{keywordtype}{float} bottomRadius, \textcolor{keywordtype}{float} topRadius, \textcolor{keywordtype}{float} height, uint32 sliceCount, uint32 stackCount)}
\DoxyCodeLine{00383 \{}
\DoxyCodeLine{00384     MeshData meshData;}
\DoxyCodeLine{00385 }
\DoxyCodeLine{00386     \textcolor{comment}{//}}
\DoxyCodeLine{00387     \textcolor{comment}{// Build Stacks.}}
\DoxyCodeLine{00388     \textcolor{comment}{// }}
\DoxyCodeLine{00389 }
\DoxyCodeLine{00390     \textcolor{keywordtype}{float} stackHeight = height / stackCount;}
\DoxyCodeLine{00391 }
\DoxyCodeLine{00392     \textcolor{comment}{// Amount to increment radius as we move up each stack level from bottom to top.}}
\DoxyCodeLine{00393     \textcolor{keywordtype}{float} radiusStep = (topRadius -\/ bottomRadius) / stackCount;}
\DoxyCodeLine{00394 }
\DoxyCodeLine{00395     uint32 ringCount = stackCount+1;}
\DoxyCodeLine{00396 }
\DoxyCodeLine{00397     \textcolor{comment}{// Compute vertices for each stack ring starting at the bottom and moving up.}}
\DoxyCodeLine{00398     \textcolor{keywordflow}{for}(uint32 i = 0; i < ringCount; ++i)}
\DoxyCodeLine{00399     \{}
\DoxyCodeLine{00400         \textcolor{keywordtype}{float} y = -\/0.5f*height + i*stackHeight;}
\DoxyCodeLine{00401         \textcolor{keywordtype}{float} r = bottomRadius + i*radiusStep;}
\DoxyCodeLine{00402 }
\DoxyCodeLine{00403         \textcolor{comment}{// vertices of ring}}
\DoxyCodeLine{00404         \textcolor{keywordtype}{float} dTheta = 2.0f*XM\_PI/sliceCount;}
\DoxyCodeLine{00405         \textcolor{keywordflow}{for}(uint32 j = 0; j <= sliceCount; ++j)}
\DoxyCodeLine{00406         \{}
\DoxyCodeLine{00407             Vertex vertex;}
\DoxyCodeLine{00408 }
\DoxyCodeLine{00409             \textcolor{keywordtype}{float} c = cosf(j*dTheta);}
\DoxyCodeLine{00410             \textcolor{keywordtype}{float} s = sinf(j*dTheta);}
\DoxyCodeLine{00411 }
\DoxyCodeLine{00412             vertex.Position = XMFLOAT3(r*c, y, r*s);}
\DoxyCodeLine{00413 }
\DoxyCodeLine{00414             vertex.TexC.x = (float)j/sliceCount;}
\DoxyCodeLine{00415             vertex.TexC.y = 1.0f -\/ (float)i/stackCount;}
\DoxyCodeLine{00416 }
\DoxyCodeLine{00417             \textcolor{comment}{// Cylinder can be parameterized as follows, where we introduce v}}
\DoxyCodeLine{00418             \textcolor{comment}{// parameter that goes in the same direction as the v tex-\/coord}}
\DoxyCodeLine{00419             \textcolor{comment}{// so that the bitangent goes in the same direction as the v tex-\/coord.}}
\DoxyCodeLine{00420             \textcolor{comment}{//   Let r0 be the bottom radius and let r1 be the top radius.}}
\DoxyCodeLine{00421             \textcolor{comment}{//   y(v) = h -\/ hv for v in [0,1].}}
\DoxyCodeLine{00422             \textcolor{comment}{//   r(v) = r1 + (r0-\/r1)v}}
\DoxyCodeLine{00423             \textcolor{comment}{//}}
\DoxyCodeLine{00424             \textcolor{comment}{//   x(t, v) = r(v)*cos(t)}}
\DoxyCodeLine{00425             \textcolor{comment}{//   y(t, v) = h -\/ hv}}
\DoxyCodeLine{00426             \textcolor{comment}{//   z(t, v) = r(v)*sin(t)}}
\DoxyCodeLine{00427             \textcolor{comment}{// }}
\DoxyCodeLine{00428             \textcolor{comment}{//  dx/dt = -\/r(v)*sin(t)}}
\DoxyCodeLine{00429             \textcolor{comment}{//  dy/dt = 0}}
\DoxyCodeLine{00430             \textcolor{comment}{//  dz/dt = +r(v)*cos(t)}}
\DoxyCodeLine{00431             \textcolor{comment}{//}}
\DoxyCodeLine{00432             \textcolor{comment}{//  dx/dv = (r0-\/r1)*cos(t)}}
\DoxyCodeLine{00433             \textcolor{comment}{//  dy/dv = -\/h}}
\DoxyCodeLine{00434             \textcolor{comment}{//  dz/dv = (r0-\/r1)*sin(t)}}
\DoxyCodeLine{00435 }
\DoxyCodeLine{00436             \textcolor{comment}{// This is unit length.}}
\DoxyCodeLine{00437             vertex.TangentU = XMFLOAT3(-\/s, 0.0f, c);}
\DoxyCodeLine{00438 }
\DoxyCodeLine{00439             \textcolor{keywordtype}{float} dr = bottomRadius-\/topRadius;}
\DoxyCodeLine{00440             XMFLOAT3 bitangent(dr*c, -\/height, dr*s);}
\DoxyCodeLine{00441 }
\DoxyCodeLine{00442             XMVECTOR T = XMLoadFloat3(\&vertex.TangentU);}
\DoxyCodeLine{00443             XMVECTOR B = XMLoadFloat3(\&bitangent);}
\DoxyCodeLine{00444             XMVECTOR N = XMVector3Normalize(XMVector3Cross(T, B));}
\DoxyCodeLine{00445             XMStoreFloat3(\&vertex.Normal, N);}
\DoxyCodeLine{00446 }
\DoxyCodeLine{00447             meshData.Vertices.push\_back(vertex);}
\DoxyCodeLine{00448         \}}
\DoxyCodeLine{00449     \}}
\DoxyCodeLine{00450 }
\DoxyCodeLine{00451     \textcolor{comment}{// Add one because we duplicate the first and last vertex per ring}}
\DoxyCodeLine{00452     \textcolor{comment}{// since the texture coordinates are different.}}
\DoxyCodeLine{00453     uint32 ringVertexCount = sliceCount+1;}
\DoxyCodeLine{00454 }
\DoxyCodeLine{00455     \textcolor{comment}{// Compute indices for each stack.}}
\DoxyCodeLine{00456     \textcolor{keywordflow}{for}(uint32 i = 0; i < stackCount; ++i)}
\DoxyCodeLine{00457     \{}
\DoxyCodeLine{00458         \textcolor{keywordflow}{for}(uint32 j = 0; j < sliceCount; ++j)}
\DoxyCodeLine{00459         \{}
\DoxyCodeLine{00460             meshData.Indices32.push\_back(i*ringVertexCount + j);}
\DoxyCodeLine{00461             meshData.Indices32.push\_back((i+1)*ringVertexCount + j);}
\DoxyCodeLine{00462             meshData.Indices32.push\_back((i+1)*ringVertexCount + j+1);}
\DoxyCodeLine{00463 }
\DoxyCodeLine{00464             meshData.Indices32.push\_back(i*ringVertexCount + j);}
\DoxyCodeLine{00465             meshData.Indices32.push\_back((i+1)*ringVertexCount + j+1);}
\DoxyCodeLine{00466             meshData.Indices32.push\_back(i*ringVertexCount + j+1);}
\DoxyCodeLine{00467         \}}
\DoxyCodeLine{00468     \}}
\DoxyCodeLine{00469 }
\DoxyCodeLine{00470     BuildCylinderTopCap(bottomRadius, topRadius, height, sliceCount, stackCount, meshData);}
\DoxyCodeLine{00471     BuildCylinderBottomCap(bottomRadius, topRadius, height, sliceCount, stackCount, meshData);}
\DoxyCodeLine{00472 }
\DoxyCodeLine{00473     \textcolor{keywordflow}{return} meshData;}
\DoxyCodeLine{00474 \}}
\DoxyCodeLine{00475 }
\DoxyCodeLine{00476 \textcolor{keywordtype}{void} GeometryGenerator::BuildCylinderTopCap(\textcolor{keywordtype}{float} bottomRadius, \textcolor{keywordtype}{float} topRadius, \textcolor{keywordtype}{float} height,}
\DoxyCodeLine{00477                                             uint32 sliceCount, uint32 stackCount, MeshData\& meshData)}
\DoxyCodeLine{00478 \{}
\DoxyCodeLine{00479     uint32 baseIndex = (uint32)meshData.Vertices.size();}
\DoxyCodeLine{00480 }
\DoxyCodeLine{00481     \textcolor{keywordtype}{float} y = 0.5f*height;}
\DoxyCodeLine{00482     \textcolor{keywordtype}{float} dTheta = 2.0f*XM\_PI/sliceCount;}
\DoxyCodeLine{00483 }
\DoxyCodeLine{00484     \textcolor{comment}{// Duplicate cap ring vertices because the texture coordinates and normals differ.}}
\DoxyCodeLine{00485     \textcolor{keywordflow}{for}(uint32 i = 0; i <= sliceCount; ++i)}
\DoxyCodeLine{00486     \{}
\DoxyCodeLine{00487         \textcolor{keywordtype}{float} x = topRadius*cosf(i*dTheta);}
\DoxyCodeLine{00488         \textcolor{keywordtype}{float} z = topRadius*sinf(i*dTheta);}
\DoxyCodeLine{00489 }
\DoxyCodeLine{00490         \textcolor{comment}{// Scale down by the height to try and make top cap texture coord area}}
\DoxyCodeLine{00491         \textcolor{comment}{// proportional to base.}}
\DoxyCodeLine{00492         \textcolor{keywordtype}{float} u = x/height + 0.5f;}
\DoxyCodeLine{00493         \textcolor{keywordtype}{float} v = z/height + 0.5f;}
\DoxyCodeLine{00494 }
\DoxyCodeLine{00495         meshData.Vertices.push\_back( Vertex(x, y, z, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, u, v) );}
\DoxyCodeLine{00496     \}}
\DoxyCodeLine{00497 }
\DoxyCodeLine{00498     \textcolor{comment}{// Cap center vertex.}}
\DoxyCodeLine{00499     meshData.Vertices.push\_back( Vertex(0.0f, y, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.5f, 0.5f) );}
\DoxyCodeLine{00500 }
\DoxyCodeLine{00501     \textcolor{comment}{// Index of center vertex.}}
\DoxyCodeLine{00502     uint32 centerIndex = (uint32)meshData.Vertices.size()-\/1;}
\DoxyCodeLine{00503 }
\DoxyCodeLine{00504     \textcolor{keywordflow}{for}(uint32 i = 0; i < sliceCount; ++i)}
\DoxyCodeLine{00505     \{}
\DoxyCodeLine{00506         meshData.Indices32.push\_back(centerIndex);}
\DoxyCodeLine{00507         meshData.Indices32.push\_back(baseIndex + i+1);}
\DoxyCodeLine{00508         meshData.Indices32.push\_back(baseIndex + i);}
\DoxyCodeLine{00509     \}}
\DoxyCodeLine{00510 \}}
\DoxyCodeLine{00511 }
\DoxyCodeLine{00512 \textcolor{keywordtype}{void} GeometryGenerator::BuildCylinderBottomCap(\textcolor{keywordtype}{float} bottomRadius, \textcolor{keywordtype}{float} topRadius, \textcolor{keywordtype}{float} height,}
\DoxyCodeLine{00513                                                uint32 sliceCount, uint32 stackCount, MeshData\& meshData)}
\DoxyCodeLine{00514 \{}
\DoxyCodeLine{00515     \textcolor{comment}{// }}
\DoxyCodeLine{00516     \textcolor{comment}{// Build bottom cap.}}
\DoxyCodeLine{00517     \textcolor{comment}{//}}
\DoxyCodeLine{00518 }
\DoxyCodeLine{00519     uint32 baseIndex = (uint32)meshData.Vertices.size();}
\DoxyCodeLine{00520     \textcolor{keywordtype}{float} y = -\/0.5f*height;}
\DoxyCodeLine{00521 }
\DoxyCodeLine{00522     \textcolor{comment}{// vertices of ring}}
\DoxyCodeLine{00523     \textcolor{keywordtype}{float} dTheta = 2.0f*XM\_PI/sliceCount;}
\DoxyCodeLine{00524     \textcolor{keywordflow}{for}(uint32 i = 0; i <= sliceCount; ++i)}
\DoxyCodeLine{00525     \{}
\DoxyCodeLine{00526         \textcolor{keywordtype}{float} x = bottomRadius*cosf(i*dTheta);}
\DoxyCodeLine{00527         \textcolor{keywordtype}{float} z = bottomRadius*sinf(i*dTheta);}
\DoxyCodeLine{00528 }
\DoxyCodeLine{00529         \textcolor{comment}{// Scale down by the height to try and make top cap texture coord area}}
\DoxyCodeLine{00530         \textcolor{comment}{// proportional to base.}}
\DoxyCodeLine{00531         \textcolor{keywordtype}{float} u = x/height + 0.5f;}
\DoxyCodeLine{00532         \textcolor{keywordtype}{float} v = z/height + 0.5f;}
\DoxyCodeLine{00533 }
\DoxyCodeLine{00534         meshData.Vertices.push\_back( Vertex(x, y, z, 0.0f, -\/1.0f, 0.0f, 1.0f, 0.0f, 0.0f, u, v) );}
\DoxyCodeLine{00535     \}}
\DoxyCodeLine{00536 }
\DoxyCodeLine{00537     \textcolor{comment}{// Cap center vertex.}}
\DoxyCodeLine{00538     meshData.Vertices.push\_back( Vertex(0.0f, y, 0.0f, 0.0f, -\/1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.5f, 0.5f) );}
\DoxyCodeLine{00539 }
\DoxyCodeLine{00540     \textcolor{comment}{// Cache the index of center vertex.}}
\DoxyCodeLine{00541     uint32 centerIndex = (uint32)meshData.Vertices.size()-\/1;}
\DoxyCodeLine{00542 }
\DoxyCodeLine{00543     \textcolor{keywordflow}{for}(uint32 i = 0; i < sliceCount; ++i)}
\DoxyCodeLine{00544     \{}
\DoxyCodeLine{00545         meshData.Indices32.push\_back(centerIndex);}
\DoxyCodeLine{00546         meshData.Indices32.push\_back(baseIndex + i);}
\DoxyCodeLine{00547         meshData.Indices32.push\_back(baseIndex + i+1);}
\DoxyCodeLine{00548     \}}
\DoxyCodeLine{00549 \}}
\DoxyCodeLine{00550 }
\DoxyCodeLine{00551 GeometryGenerator::MeshData GeometryGenerator::CreateGrid(\textcolor{keywordtype}{float} width, \textcolor{keywordtype}{float} depth, uint32 m, uint32 n)}
\DoxyCodeLine{00552 \{}
\DoxyCodeLine{00553     MeshData meshData;}
\DoxyCodeLine{00554 }
\DoxyCodeLine{00555     uint32 vertexCount = m*n;}
\DoxyCodeLine{00556     uint32 faceCount   = (m-\/1)*(n-\/1)*2;}
\DoxyCodeLine{00557 }
\DoxyCodeLine{00558     \textcolor{comment}{//}}
\DoxyCodeLine{00559     \textcolor{comment}{// Create the vertices.}}
\DoxyCodeLine{00560     \textcolor{comment}{//}}
\DoxyCodeLine{00561 }
\DoxyCodeLine{00562     \textcolor{keywordtype}{float} halfWidth = 0.5f*width;}
\DoxyCodeLine{00563     \textcolor{keywordtype}{float} halfDepth = 0.5f*depth;}
\DoxyCodeLine{00564 }
\DoxyCodeLine{00565     \textcolor{keywordtype}{float} dx = width / (n-\/1);}
\DoxyCodeLine{00566     \textcolor{keywordtype}{float} dz = depth / (m-\/1);}
\DoxyCodeLine{00567 }
\DoxyCodeLine{00568     \textcolor{keywordtype}{float} du = 1.0f / (n-\/1);}
\DoxyCodeLine{00569     \textcolor{keywordtype}{float} dv = 1.0f / (m-\/1);}
\DoxyCodeLine{00570 }
\DoxyCodeLine{00571     meshData.Vertices.resize(vertexCount);}
\DoxyCodeLine{00572     \textcolor{keywordflow}{for}(uint32 i = 0; i < m; ++i)}
\DoxyCodeLine{00573     \{}
\DoxyCodeLine{00574         \textcolor{keywordtype}{float} z = halfDepth -\/ i*dz;}
\DoxyCodeLine{00575         \textcolor{keywordflow}{for}(uint32 j = 0; j < n; ++j)}
\DoxyCodeLine{00576         \{}
\DoxyCodeLine{00577             \textcolor{keywordtype}{float} x = -\/halfWidth + j*dx;}
\DoxyCodeLine{00578 }
\DoxyCodeLine{00579             meshData.Vertices[i*n+j].Position = XMFLOAT3(x, 0.0f, z);}
\DoxyCodeLine{00580             meshData.Vertices[i*n+j].Normal   = XMFLOAT3(0.0f, 1.0f, 0.0f);}
\DoxyCodeLine{00581             meshData.Vertices[i*n+j].TangentU = XMFLOAT3(1.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00582 }
\DoxyCodeLine{00583             \textcolor{comment}{// Stretch texture over grid.}}
\DoxyCodeLine{00584             meshData.Vertices[i*n+j].TexC.x = j*du;}
\DoxyCodeLine{00585             meshData.Vertices[i*n+j].TexC.y = i*dv;}
\DoxyCodeLine{00586         \}}
\DoxyCodeLine{00587     \}}
\DoxyCodeLine{00588  }
\DoxyCodeLine{00589     \textcolor{comment}{//}}
\DoxyCodeLine{00590     \textcolor{comment}{// Create the indices.}}
\DoxyCodeLine{00591     \textcolor{comment}{//}}
\DoxyCodeLine{00592 }
\DoxyCodeLine{00593     meshData.Indices32.resize(faceCount*3); \textcolor{comment}{// 3 indices per face}}
\DoxyCodeLine{00594 }
\DoxyCodeLine{00595     \textcolor{comment}{// Iterate over each quad and compute indices.}}
\DoxyCodeLine{00596     uint32 k = 0;}
\DoxyCodeLine{00597     \textcolor{keywordflow}{for}(uint32 i = 0; i < m-\/1; ++i)}
\DoxyCodeLine{00598     \{}
\DoxyCodeLine{00599         \textcolor{keywordflow}{for}(uint32 j = 0; j < n-\/1; ++j)}
\DoxyCodeLine{00600         \{}
\DoxyCodeLine{00601             meshData.Indices32[k]   = i*n+j;}
\DoxyCodeLine{00602             meshData.Indices32[k+1] = i*n+j+1;}
\DoxyCodeLine{00603             meshData.Indices32[k+2] = (i+1)*n+j;}
\DoxyCodeLine{00604 }
\DoxyCodeLine{00605             meshData.Indices32[k+3] = (i+1)*n+j;}
\DoxyCodeLine{00606             meshData.Indices32[k+4] = i*n+j+1;}
\DoxyCodeLine{00607             meshData.Indices32[k+5] = (i+1)*n+j+1;}
\DoxyCodeLine{00608 }
\DoxyCodeLine{00609             k += 6; \textcolor{comment}{// next quad}}
\DoxyCodeLine{00610         \}}
\DoxyCodeLine{00611     \}}
\DoxyCodeLine{00612 }
\DoxyCodeLine{00613     \textcolor{keywordflow}{return} meshData;}
\DoxyCodeLine{00614 \}}
\DoxyCodeLine{00615 }
\DoxyCodeLine{00616 GeometryGenerator::MeshData GeometryGenerator::CreateQuad(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y, \textcolor{keywordtype}{float} w, \textcolor{keywordtype}{float} h, \textcolor{keywordtype}{float} depth)}
\DoxyCodeLine{00617 \{}
\DoxyCodeLine{00618     MeshData meshData;}
\DoxyCodeLine{00619 }
\DoxyCodeLine{00620     meshData.Vertices.resize(4);}
\DoxyCodeLine{00621     meshData.Indices32.resize(6);}
\DoxyCodeLine{00622 }
\DoxyCodeLine{00623     \textcolor{comment}{// Position coordinates specified in NDC space.}}
\DoxyCodeLine{00624     meshData.Vertices[0] = Vertex(}
\DoxyCodeLine{00625         x, y -\/ h, depth,}
\DoxyCodeLine{00626         0.0f, 0.0f, -\/1.0f,}
\DoxyCodeLine{00627         1.0f, 0.0f, 0.0f,}
\DoxyCodeLine{00628         0.0f, 1.0f);}
\DoxyCodeLine{00629 }
\DoxyCodeLine{00630     meshData.Vertices[1] = Vertex(}
\DoxyCodeLine{00631         x, y, depth,}
\DoxyCodeLine{00632         0.0f, 0.0f, -\/1.0f,}
\DoxyCodeLine{00633         1.0f, 0.0f, 0.0f,}
\DoxyCodeLine{00634         0.0f, 0.0f);}
\DoxyCodeLine{00635 }
\DoxyCodeLine{00636     meshData.Vertices[2] = Vertex(}
\DoxyCodeLine{00637         x+w, y, depth,}
\DoxyCodeLine{00638         0.0f, 0.0f, -\/1.0f,}
\DoxyCodeLine{00639         1.0f, 0.0f, 0.0f,}
\DoxyCodeLine{00640         1.0f, 0.0f);}
\DoxyCodeLine{00641 }
\DoxyCodeLine{00642     meshData.Vertices[3] = Vertex(}
\DoxyCodeLine{00643         x+w, y-\/h, depth,}
\DoxyCodeLine{00644         0.0f, 0.0f, -\/1.0f,}
\DoxyCodeLine{00645         1.0f, 0.0f, 0.0f,}
\DoxyCodeLine{00646         1.0f, 1.0f);}
\DoxyCodeLine{00647 }
\DoxyCodeLine{00648     meshData.Indices32[0] = 0;}
\DoxyCodeLine{00649     meshData.Indices32[1] = 1;}
\DoxyCodeLine{00650     meshData.Indices32[2] = 2;}
\DoxyCodeLine{00651 }
\DoxyCodeLine{00652     meshData.Indices32[3] = 0;}
\DoxyCodeLine{00653     meshData.Indices32[4] = 2;}
\DoxyCodeLine{00654     meshData.Indices32[5] = 3;}
\DoxyCodeLine{00655 }
\DoxyCodeLine{00656     \textcolor{keywordflow}{return} meshData;}
\DoxyCodeLine{00657 \}}

\end{DoxyCode}
