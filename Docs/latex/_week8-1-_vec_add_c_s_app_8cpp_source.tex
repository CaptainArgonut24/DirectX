\doxysection{Week8-\/1-\/\+Vec\+Add\+CSApp.cpp}
\label{_week8-1-_vec_add_c_s_app_8cpp_source}\index{Week8/VecAdd/Week8-\/1-\/VecAddCSApp.cpp@{Week8/VecAdd/Week8-\/1-\/VecAddCSApp.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00002 \textcolor{comment}{// VecAddCSApp.cpp how to add two sets of 32 vectors using 32 threads in the compute shader}}
\DoxyCodeLine{00003 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00004 }
\DoxyCodeLine{00005 \textcolor{preprocessor}{\#include "{}../../Common/d3dApp.h"{}}}
\DoxyCodeLine{00006 \textcolor{preprocessor}{\#include "{}../../Common/MathHelper.h"{}}}
\DoxyCodeLine{00007 \textcolor{preprocessor}{\#include "{}../../Common/UploadBuffer.h"{}}}
\DoxyCodeLine{00008 }
\DoxyCodeLine{00009 \textcolor{keyword}{using} Microsoft::WRL::ComPtr;}
\DoxyCodeLine{00010 \textcolor{keyword}{using namespace }DirectX;}
\DoxyCodeLine{00011 \textcolor{keyword}{using namespace }DirectX::PackedVector;}
\DoxyCodeLine{00012 }
\DoxyCodeLine{00013 \textcolor{preprocessor}{\#pragma comment(lib, "{}d3dcompiler.lib"{}})}
\DoxyCodeLine{00014 \textcolor{preprocessor}{\#pragma comment(lib, "{}D3D12.lib"{}})}
\DoxyCodeLine{00015 }
\DoxyCodeLine{00016 }
\DoxyCodeLine{00017 \textcolor{comment}{//step1}}
\DoxyCodeLine{00018 \textcolor{keyword}{struct }Data}
\DoxyCodeLine{00019 \{}
\DoxyCodeLine{00020     XMFLOAT3 v1;}
\DoxyCodeLine{00021     XMFLOAT2 v2;}
\DoxyCodeLine{00022 \};}
\DoxyCodeLine{00023 }
\DoxyCodeLine{00024 }
\DoxyCodeLine{00025 \textcolor{keyword}{class }VecAddApp : \textcolor{keyword}{public} D3DApp}
\DoxyCodeLine{00026 \{}
\DoxyCodeLine{00027 \textcolor{keyword}{public}:}
\DoxyCodeLine{00028     VecAddApp(HINSTANCE hInstance);}
\DoxyCodeLine{00029     VecAddApp(\textcolor{keyword}{const} VecAddApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00030     VecAddApp\& operator=(\textcolor{keyword}{const} VecAddApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00031     \string~VecAddApp();}
\DoxyCodeLine{00032 }
\DoxyCodeLine{00033     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} Initialize()\textcolor{keyword}{override};}
\DoxyCodeLine{00034 }
\DoxyCodeLine{00035 \textcolor{keyword}{private}:}
\DoxyCodeLine{00036     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnResize()\textcolor{keyword}{override};}
\DoxyCodeLine{00037     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Update(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00038     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Draw(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00039 }
\DoxyCodeLine{00040     \textcolor{comment}{//step2}}
\DoxyCodeLine{00041     \textcolor{keywordtype}{void} DoComputeWork();}
\DoxyCodeLine{00042 }
\DoxyCodeLine{00043     \textcolor{keywordtype}{void} BuildBuffers();}
\DoxyCodeLine{00044     \textcolor{keywordtype}{void} BuildRootSignature();}
\DoxyCodeLine{00045     \textcolor{keywordtype}{void} BuildShadersAndInputLayout();}
\DoxyCodeLine{00046     \textcolor{keywordtype}{void} BuildPSOs();}
\DoxyCodeLine{00047 }
\DoxyCodeLine{00048 \textcolor{keyword}{private}:}
\DoxyCodeLine{00049 }
\DoxyCodeLine{00050     ComPtr<ID3D12RootSignature> mRootSignature = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00051 }
\DoxyCodeLine{00052     std::unordered\_map<std::string, ComPtr<ID3DBlob>> mShaders;}
\DoxyCodeLine{00053     std::unordered\_map<std::string, ComPtr<ID3D12PipelineState>> mPSOs;}
\DoxyCodeLine{00054 }
\DoxyCodeLine{00055     std::vector<D3D12\_INPUT\_ELEMENT\_DESC> mInputLayout;}
\DoxyCodeLine{00056 }
\DoxyCodeLine{00057     \textcolor{comment}{//step3: we have 2 sets of 32 vectors that we want to add. Same operation for all vectors!}}
\DoxyCodeLine{00058     \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDataElements = 32;}
\DoxyCodeLine{00059 }
\DoxyCodeLine{00060     ComPtr<ID3D12Resource> mInputBufferA = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00061     ComPtr<ID3D12Resource> mInputUploadBufferA = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00062     ComPtr<ID3D12Resource> mInputBufferB = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00063     ComPtr<ID3D12Resource> mInputUploadBufferB = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00064     ComPtr<ID3D12Resource> mOutputBuffer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00065     ComPtr<ID3D12Resource> mReadBackBuffer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00066 }
\DoxyCodeLine{00067 \};}
\DoxyCodeLine{00068 }
\DoxyCodeLine{00069 \textcolor{keywordtype}{int} WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance,}
\DoxyCodeLine{00070     PSTR cmdLine, \textcolor{keywordtype}{int} showCmd)}
\DoxyCodeLine{00071 \{}
\DoxyCodeLine{00072     \textcolor{comment}{// Enable run-\/time memory check for debug builds.}}
\DoxyCodeLine{00073 \textcolor{preprocessor}{\#if defined(DEBUG) | defined(\_DEBUG)}}
\DoxyCodeLine{00074     \_CrtSetDbgFlag(\_CRTDBG\_ALLOC\_MEM\_DF | \_CRTDBG\_LEAK\_CHECK\_DF);}
\DoxyCodeLine{00075 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00076 }
\DoxyCodeLine{00077     \textcolor{keywordflow}{try}}
\DoxyCodeLine{00078     \{}
\DoxyCodeLine{00079         VecAddApp theApp(hInstance);}
\DoxyCodeLine{00080         \textcolor{keywordflow}{if}(!theApp.Initialize())}
\DoxyCodeLine{00081             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00082         \textcolor{comment}{//step 3: we don't need to have a game loop}}
\DoxyCodeLine{00083        \textcolor{comment}{// return theApp.Run();}}
\DoxyCodeLine{00084         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00085     \}}
\DoxyCodeLine{00086     \textcolor{keywordflow}{catch}(DxException\& e)}
\DoxyCodeLine{00087     \{}
\DoxyCodeLine{00088         MessageBox(\textcolor{keyword}{nullptr}, e.ToString().c\_str(), L\textcolor{stringliteral}{"{}HR Failed"{}}, MB\_OK);}
\DoxyCodeLine{00089         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00090     \}}
\DoxyCodeLine{00091 \}}
\DoxyCodeLine{00092 }
\DoxyCodeLine{00093 VecAddApp::VecAddApp(HINSTANCE hInstance)}
\DoxyCodeLine{00094     : D3DApp(hInstance)}
\DoxyCodeLine{00095 \{}
\DoxyCodeLine{00096 \}}
\DoxyCodeLine{00097 }
\DoxyCodeLine{00098 VecAddApp::\string~VecAddApp()}
\DoxyCodeLine{00099 \{}
\DoxyCodeLine{00100     \textcolor{keywordflow}{if}(md3dDevice != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00101         FlushCommandQueue();}
\DoxyCodeLine{00102 \}}
\DoxyCodeLine{00103 }
\DoxyCodeLine{00104 \textcolor{keywordtype}{bool} VecAddApp::Initialize()}
\DoxyCodeLine{00105 \{}
\DoxyCodeLine{00106     \textcolor{keywordflow}{if}(!D3DApp::Initialize())}
\DoxyCodeLine{00107         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00108 }
\DoxyCodeLine{00109     \textcolor{comment}{// Reset the command list to prep for initialization commands.}}
\DoxyCodeLine{00110     ThrowIfFailed(mCommandList-\/>Reset(mDirectCmdListAlloc.Get(), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{00111 }
\DoxyCodeLine{00112     \textcolor{comment}{//step4}}
\DoxyCodeLine{00113     BuildBuffers();}
\DoxyCodeLine{00114     BuildRootSignature();}
\DoxyCodeLine{00115     BuildShadersAndInputLayout();}
\DoxyCodeLine{00116     BuildPSOs();}
\DoxyCodeLine{00117 }
\DoxyCodeLine{00118     \textcolor{comment}{// Execute the initialization commands.}}
\DoxyCodeLine{00119     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00120     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00121     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00122 }
\DoxyCodeLine{00123     \textcolor{comment}{// Wait until initialization is complete.}}
\DoxyCodeLine{00124     FlushCommandQueue();}
\DoxyCodeLine{00125 }
\DoxyCodeLine{00126     DoComputeWork();}
\DoxyCodeLine{00127 }
\DoxyCodeLine{00128     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00129 \}}
\DoxyCodeLine{00130  }
\DoxyCodeLine{00131 \textcolor{keywordtype}{void} VecAddApp::OnResize()}
\DoxyCodeLine{00132 \{}
\DoxyCodeLine{00133 \}}
\DoxyCodeLine{00134 }
\DoxyCodeLine{00135 \textcolor{keywordtype}{void} VecAddApp::Update(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00136 \{}
\DoxyCodeLine{00137 \}}
\DoxyCodeLine{00138 }
\DoxyCodeLine{00139 \textcolor{keywordtype}{void} VecAddApp::Draw(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00140 \{}
\DoxyCodeLine{00141 \}}
\DoxyCodeLine{00142 }
\DoxyCodeLine{00143  \textcolor{comment}{//step 5}}
\DoxyCodeLine{00144 \textcolor{keywordtype}{void} VecAddApp::DoComputeWork()}
\DoxyCodeLine{00145 \{}
\DoxyCodeLine{00146     \textcolor{comment}{// Reuse the memory associated with command recording.}}
\DoxyCodeLine{00147     \textcolor{comment}{// We can only reset when the associated command lists have finished execution on the GPU.}}
\DoxyCodeLine{00148     ThrowIfFailed(mDirectCmdListAlloc-\/>Reset());}
\DoxyCodeLine{00149 }
\DoxyCodeLine{00150     \textcolor{comment}{// A command list can be reset after it has been added to the command queue via ExecuteCommandList.}}
\DoxyCodeLine{00151     \textcolor{comment}{// Reusing the command list reuses memory.}}
\DoxyCodeLine{00152     ThrowIfFailed(mCommandList-\/>Reset(mDirectCmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}vecAdd"{}}].Get()));}
\DoxyCodeLine{00153 }
\DoxyCodeLine{00154     mCommandList-\/>SetComputeRootSignature(mRootSignature.Get());}
\DoxyCodeLine{00155 }
\DoxyCodeLine{00156     mCommandList-\/>SetComputeRootShaderResourceView(0, mInputBufferA-\/>GetGPUVirtualAddress());}
\DoxyCodeLine{00157     mCommandList-\/>SetComputeRootShaderResourceView(1, mInputBufferB-\/>GetGPUVirtualAddress());}
\DoxyCodeLine{00158     mCommandList-\/>SetComputeRootUnorderedAccessView(2, mOutputBuffer-\/>GetGPUVirtualAddress());}
\DoxyCodeLine{00159  }
\DoxyCodeLine{00160     mCommandList-\/>Dispatch(1, 1, 1);}
\DoxyCodeLine{00161 }
\DoxyCodeLine{00162     \textcolor{comment}{// Schedule to copy the data to the default buffer to the readback buffer.}}
\DoxyCodeLine{00163 }
\DoxyCodeLine{00164     \textcolor{comment}{//D3D12\_RESOURCE\_STATE\_COPY\_SOURCE: The resource is used as the source in a copy operation. }}
\DoxyCodeLine{00165     \textcolor{comment}{//D3D12\_RESOURCE\_STATE\_COPY\_DEST: The resource is used as the destination in a copy operation.}}
\DoxyCodeLine{00166 }
\DoxyCodeLine{00167     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mOutputBuffer.Get(), }
\DoxyCodeLine{00168         D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS, D3D12\_RESOURCE\_STATE\_COPY\_SOURCE));}
\DoxyCodeLine{00169 }
\DoxyCodeLine{00170     \textcolor{comment}{//We need to read the data back from the GPU after computer shader does its calculation}}
\DoxyCodeLine{00171     \textcolor{comment}{//mCommandList-\/>CopyResource(Destination: CPUData, Source: GPUData);}}
\DoxyCodeLine{00172     mCommandList-\/>CopyResource(mReadBackBuffer.Get(), mOutputBuffer.Get());}
\DoxyCodeLine{00173 }
\DoxyCodeLine{00174     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mOutputBuffer.Get(),}
\DoxyCodeLine{00175         D3D12\_RESOURCE\_STATE\_COPY\_SOURCE, D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS));}
\DoxyCodeLine{00176 }
\DoxyCodeLine{00177 }
\DoxyCodeLine{00178     \textcolor{comment}{// Done recording commands.}}
\DoxyCodeLine{00179     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00180 }
\DoxyCodeLine{00181     \textcolor{comment}{// Add the command list to the queue for execution.}}
\DoxyCodeLine{00182     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00183     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00184 }
\DoxyCodeLine{00185     \textcolor{comment}{// Wait for the work to finish.}}
\DoxyCodeLine{00186     FlushCommandQueue();}
\DoxyCodeLine{00187 }
\DoxyCodeLine{00188     \textcolor{comment}{// Map the data so we can read it on CPU.}}
\DoxyCodeLine{00189     Data* mappedData = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00190     ThrowIfFailed(mReadBackBuffer-\/>Map(0, \textcolor{keyword}{nullptr}, \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}**\textcolor{keyword}{>}(\&mappedData)));}
\DoxyCodeLine{00191 }
\DoxyCodeLine{00192     std::ofstream fout(\textcolor{stringliteral}{"{}results.txt"{}});}
\DoxyCodeLine{00193 }
\DoxyCodeLine{00194     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < NumDataElements; ++i)}
\DoxyCodeLine{00195     \{}
\DoxyCodeLine{00196         fout << \textcolor{stringliteral}{"{}("{}} << mappedData[i].v1.x << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].v1.y << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].v1.z <<}
\DoxyCodeLine{00197             \textcolor{stringliteral}{"{}, "{}} << mappedData[i].v2.x << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].v2.y << \textcolor{stringliteral}{"{})"{}} << std::endl;}
\DoxyCodeLine{00198     \}}
\DoxyCodeLine{00199 }
\DoxyCodeLine{00200     mReadBackBuffer-\/>Unmap(0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00201 \}}
\DoxyCodeLine{00202 }
\DoxyCodeLine{00203 \textcolor{keywordtype}{void} VecAddApp::BuildBuffers()}
\DoxyCodeLine{00204 \{}
\DoxyCodeLine{00205     \textcolor{comment}{// Generate some data.}}
\DoxyCodeLine{00206     std::vector<Data> dataA(NumDataElements);}
\DoxyCodeLine{00207     std::vector<Data> dataB(NumDataElements);}
\DoxyCodeLine{00208     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < NumDataElements; ++i)}
\DoxyCodeLine{00209     \{}
\DoxyCodeLine{00210         dataA[i].v1 = XMFLOAT3((\textcolor{keywordtype}{float})i, (\textcolor{keywordtype}{float})i, (\textcolor{keywordtype}{float})i);}
\DoxyCodeLine{00211         dataA[i].v2 = XMFLOAT2((\textcolor{keywordtype}{float})i, 0.0f);}
\DoxyCodeLine{00212 }
\DoxyCodeLine{00213         dataB[i].v1 = XMFLOAT3(-\/(\textcolor{keywordtype}{float})i, (\textcolor{keywordtype}{float})i, 0.0f);}
\DoxyCodeLine{00214         dataB[i].v2 = XMFLOAT2(0.0f, -\/(\textcolor{keywordtype}{float})i);}
\DoxyCodeLine{00215     \}}
\DoxyCodeLine{00216 }
\DoxyCodeLine{00217     UINT64 byteSize = dataA.size()*\textcolor{keyword}{sizeof}(Data);}
\DoxyCodeLine{00218 }
\DoxyCodeLine{00219     \textcolor{comment}{// Create some buffers to be used as SRVs.}}
\DoxyCodeLine{00220     mInputBufferA = d3dUtil::CreateDefaultBuffer(}
\DoxyCodeLine{00221         md3dDevice.Get(),}
\DoxyCodeLine{00222         mCommandList.Get(),}
\DoxyCodeLine{00223         dataA.data(),}
\DoxyCodeLine{00224         byteSize,}
\DoxyCodeLine{00225         mInputUploadBufferA);}
\DoxyCodeLine{00226 }
\DoxyCodeLine{00227     mInputBufferB = d3dUtil::CreateDefaultBuffer(}
\DoxyCodeLine{00228         md3dDevice.Get(),}
\DoxyCodeLine{00229         mCommandList.Get(),}
\DoxyCodeLine{00230         dataB.data(),}
\DoxyCodeLine{00231         byteSize,}
\DoxyCodeLine{00232         mInputUploadBufferB);}
\DoxyCodeLine{00233 }
\DoxyCodeLine{00234     \textcolor{comment}{// Create the buffer that will be a UAV.}}
\DoxyCodeLine{00235     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00236         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_DEFAULT),}
\DoxyCodeLine{00237         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00238         \&CD3DX12\_RESOURCE\_DESC::Buffer(byteSize, D3D12\_RESOURCE\_FLAG\_ALLOW\_UNORDERED\_ACCESS),}
\DoxyCodeLine{00239         D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS,}
\DoxyCodeLine{00240         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00241         IID\_PPV\_ARGS(\&mOutputBuffer)));}
\DoxyCodeLine{00242     }
\DoxyCodeLine{00243     \textcolor{comment}{//Specifies a heap used for reading back. This heap type has CPU access optimized for reading data back from the GPU, }}
\DoxyCodeLine{00244     \textcolor{comment}{//but does not experience the maximum amount of bandwidth for the GPU. This heap type is best for GPU-\/write-\/once, }}
\DoxyCodeLine{00245     \textcolor{comment}{//CPU-\/readable data. The CPU cache behavior is write-\/back, which is conducive for multiple sub-\/cache-\/line CPU reads.}}
\DoxyCodeLine{00246     \textcolor{comment}{//Resources in this heap must be created with D3D12\_RESOURCE\_STATE\_COPY\_DEST, and cannot be changed away from this}}
\DoxyCodeLine{00247     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00248         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_READBACK),}
\DoxyCodeLine{00249         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00250         \&CD3DX12\_RESOURCE\_DESC::Buffer(byteSize),}
\DoxyCodeLine{00251         D3D12\_RESOURCE\_STATE\_COPY\_DEST,}
\DoxyCodeLine{00252         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00253         IID\_PPV\_ARGS(\&mReadBackBuffer)));}
\DoxyCodeLine{00254 \}}
\DoxyCodeLine{00255 }
\DoxyCodeLine{00256 \textcolor{keywordtype}{void} VecAddApp::BuildRootSignature()}
\DoxyCodeLine{00257 \{}
\DoxyCodeLine{00258     \textcolor{comment}{// Root parameter can be a table, root descriptor or root constants.}}
\DoxyCodeLine{00259     CD3DX12\_ROOT\_PARAMETER slotRootParameter[3];}
\DoxyCodeLine{00260 }
\DoxyCodeLine{00261     \textcolor{comment}{// Perfomance TIP: Order from most frequent to least frequent.}}
\DoxyCodeLine{00262     slotRootParameter[0].InitAsShaderResourceView(0);}
\DoxyCodeLine{00263     slotRootParameter[1].InitAsShaderResourceView(1);}
\DoxyCodeLine{00264     slotRootParameter[2].InitAsUnorderedAccessView(0);}
\DoxyCodeLine{00265 }
\DoxyCodeLine{00266     \textcolor{comment}{// A root signature is an array of root parameters.}}
\DoxyCodeLine{00267     CD3DX12\_ROOT\_SIGNATURE\_DESC rootSigDesc(3, slotRootParameter,}
\DoxyCodeLine{00268         0, \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00269         D3D12\_ROOT\_SIGNATURE\_FLAG\_NONE);}
\DoxyCodeLine{00270 }
\DoxyCodeLine{00271     \textcolor{comment}{// create a root signature with a single slot which points to a descriptor range consisting of a single constant buffer}}
\DoxyCodeLine{00272     ComPtr<ID3DBlob> serializedRootSig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00273     ComPtr<ID3DBlob> errorBlob = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00274     HRESULT hr = D3D12SerializeRootSignature(\&rootSigDesc, D3D\_ROOT\_SIGNATURE\_VERSION\_1,}
\DoxyCodeLine{00275         serializedRootSig.GetAddressOf(), errorBlob.GetAddressOf());}
\DoxyCodeLine{00276 }
\DoxyCodeLine{00277     \textcolor{keywordflow}{if}(errorBlob != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00278     \{}
\DoxyCodeLine{00279         ::OutputDebugStringA((\textcolor{keywordtype}{char}*)errorBlob-\/>GetBufferPointer());}
\DoxyCodeLine{00280     \}}
\DoxyCodeLine{00281     ThrowIfFailed(hr);}
\DoxyCodeLine{00282 }
\DoxyCodeLine{00283     ThrowIfFailed(md3dDevice-\/>CreateRootSignature(}
\DoxyCodeLine{00284         0,}
\DoxyCodeLine{00285         serializedRootSig-\/>GetBufferPointer(),}
\DoxyCodeLine{00286         serializedRootSig-\/>GetBufferSize(),}
\DoxyCodeLine{00287         IID\_PPV\_ARGS(mRootSignature.GetAddressOf())));}
\DoxyCodeLine{00288 \}}
\DoxyCodeLine{00289 }
\DoxyCodeLine{00290 }
\DoxyCodeLine{00291 \textcolor{keywordtype}{void} VecAddApp::BuildShadersAndInputLayout()}
\DoxyCodeLine{00292 \{}
\DoxyCodeLine{00293     mShaders[\textcolor{stringliteral}{"{}vecAddCS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)VecAdd.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}CS"{}}, \textcolor{stringliteral}{"{}cs\_5\_1"{}});}
\DoxyCodeLine{00294 \}}
\DoxyCodeLine{00295 }
\DoxyCodeLine{00296 \textcolor{keywordtype}{void} VecAddApp::BuildPSOs()}
\DoxyCodeLine{00297 \{}
\DoxyCodeLine{00298     D3D12\_COMPUTE\_PIPELINE\_STATE\_DESC computePsoDesc = \{\};}
\DoxyCodeLine{00299     computePsoDesc.pRootSignature = mRootSignature.Get();}
\DoxyCodeLine{00300     computePsoDesc.CS =}
\DoxyCodeLine{00301     \{}
\DoxyCodeLine{00302         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}vecAddCS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00303         mShaders[\textcolor{stringliteral}{"{}vecAddCS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00304     \};}
\DoxyCodeLine{00305     computePsoDesc.Flags = D3D12\_PIPELINE\_STATE\_FLAG\_NONE;}
\DoxyCodeLine{00306     ThrowIfFailed(md3dDevice-\/>CreateComputePipelineState(\&computePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}vecAdd"{}}])));}
\DoxyCodeLine{00307 \}}
\DoxyCodeLine{00308 }
\DoxyCodeLine{00309 }
\DoxyCodeLine{00310 }
\DoxyCodeLine{00311 }
\DoxyCodeLine{00312 }

\end{DoxyCode}
