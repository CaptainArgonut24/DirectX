\doxysection{Week8-\/2-\/\+Particle\+Add\+CSApp.cpp}
\label{_week8-2-_particle_add_c_s_app_8cpp_source}\index{Week8/VecAdd/Week8-\/2-\/ParticleAddCSApp.cpp@{Week8/VecAdd/Week8-\/2-\/ParticleAddCSApp.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00002 \textcolor{comment}{// particleAddCSApp.cpp using root UAV}}
\DoxyCodeLine{00003 \textcolor{comment}{//you can't use append/consume buffers from root UAVs, they need to be descriptors in a descriptor table.}}
\DoxyCodeLine{00004 \textcolor{comment}{//That's why you can't produce what you are looking for. }}
\DoxyCodeLine{00005 \textcolor{comment}{//Root UAVs don't have associated counters, and therefore cannot be used as append/consume buffers.}}
\DoxyCodeLine{00006 \textcolor{comment}{//If pCounterResource is specified in the call to CreateUnorderedAccessView, then there is a counter associated with the UAV.}}
\DoxyCodeLine{00007 \textcolor{comment}{//https://docs.microsoft.com/en-\/us/windows/win32/direct3d12/uav-\/counters}}
\DoxyCodeLine{00008 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00009 }
\DoxyCodeLine{00010 \textcolor{preprocessor}{\#include "{}../../Common/d3dApp.h"{}}}
\DoxyCodeLine{00011 \textcolor{preprocessor}{\#include "{}../../Common/UploadBuffer.h"{}}}
\DoxyCodeLine{00012 }
\DoxyCodeLine{00013 \textcolor{keyword}{using} Microsoft::WRL::ComPtr;}
\DoxyCodeLine{00014 \textcolor{keyword}{using namespace }DirectX;}
\DoxyCodeLine{00015 \textcolor{keyword}{using namespace }DirectX::PackedVector;}
\DoxyCodeLine{00016 }
\DoxyCodeLine{00017 \textcolor{preprocessor}{\#pragma comment(lib, "{}d3dcompiler.lib"{}})}
\DoxyCodeLine{00018 \textcolor{preprocessor}{\#pragma comment(lib, "{}D3D12.lib"{}})}
\DoxyCodeLine{00019 }
\DoxyCodeLine{00020 }
\DoxyCodeLine{00021 \textcolor{keyword}{struct }Particle}
\DoxyCodeLine{00022 \{}
\DoxyCodeLine{00023     XMFLOAT3 Position;}
\DoxyCodeLine{00024     XMFLOAT3 Velocity;}
\DoxyCodeLine{00025     XMFLOAT3 Acceleration;}
\DoxyCodeLine{00026 \};}
\DoxyCodeLine{00027 }
\DoxyCodeLine{00028 \textcolor{keyword}{class }ParticleAddCSApp : \textcolor{keyword}{public} D3DApp}
\DoxyCodeLine{00029 \{}
\DoxyCodeLine{00030 \textcolor{keyword}{public}:}
\DoxyCodeLine{00031     ParticleAddCSApp(HINSTANCE hInstance);}
\DoxyCodeLine{00032     ParticleAddCSApp(\textcolor{keyword}{const} ParticleAddCSApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00033     ParticleAddCSApp\& operator=(\textcolor{keyword}{const} ParticleAddCSApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00034     \string~ParticleAddCSApp();}
\DoxyCodeLine{00035 }
\DoxyCodeLine{00036     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} Initialize()\textcolor{keyword}{override};}
\DoxyCodeLine{00037 }
\DoxyCodeLine{00038 \textcolor{keyword}{private}:}
\DoxyCodeLine{00039     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnResize()\textcolor{keyword}{override};}
\DoxyCodeLine{00040     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Update(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00041     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Draw(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00042 }
\DoxyCodeLine{00043     \textcolor{keywordtype}{void} DoComputeWork();}
\DoxyCodeLine{00044 }
\DoxyCodeLine{00045     \textcolor{keywordtype}{void} BuildBuffers();}
\DoxyCodeLine{00046     \textcolor{keywordtype}{void} BuildRootSignature();}
\DoxyCodeLine{00047     \textcolor{keywordtype}{void} BuildShadersAndInputLayout();}
\DoxyCodeLine{00048     \textcolor{keywordtype}{void} BuildPSOs();}
\DoxyCodeLine{00049 }
\DoxyCodeLine{00050 \textcolor{keyword}{private}:}
\DoxyCodeLine{00051 }
\DoxyCodeLine{00052     ComPtr<ID3D12RootSignature> mRootSignature = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00053 }
\DoxyCodeLine{00054     std::unordered\_map<std::string, ComPtr<ID3DBlob>> mShaders;}
\DoxyCodeLine{00055     std::unordered\_map<std::string, ComPtr<ID3D12PipelineState>> mPSOs;}
\DoxyCodeLine{00056 }
\DoxyCodeLine{00057     std::vector<D3D12\_INPUT\_ELEMENT\_DESC> mInputLayout;}
\DoxyCodeLine{00058  }
\DoxyCodeLine{00059     \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDataElements = 16*16;}
\DoxyCodeLine{00060 }
\DoxyCodeLine{00061     ComPtr<ID3D12Resource> mInputBufferA = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00062     ComPtr<ID3D12Resource> mInputUploadBufferA = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00063     ComPtr<ID3D12Resource> mOutputBuffer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00064     ComPtr<ID3D12Resource> mOutputBuffer1 = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00065     ComPtr<ID3D12Resource> mReadBackBuffer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00066 }
\DoxyCodeLine{00067 \};}
\DoxyCodeLine{00068 }
\DoxyCodeLine{00069 \textcolor{keywordtype}{int} WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance,}
\DoxyCodeLine{00070     PSTR cmdLine, \textcolor{keywordtype}{int} showCmd)}
\DoxyCodeLine{00071 \{}
\DoxyCodeLine{00072     \textcolor{comment}{// Enable run-\/time memory check for debug builds.}}
\DoxyCodeLine{00073 \textcolor{preprocessor}{\#if defined(DEBUG) | defined(\_DEBUG)}}
\DoxyCodeLine{00074     \_CrtSetDbgFlag(\_CRTDBG\_ALLOC\_MEM\_DF | \_CRTDBG\_LEAK\_CHECK\_DF);}
\DoxyCodeLine{00075 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00076 }
\DoxyCodeLine{00077     \textcolor{keywordflow}{try}}
\DoxyCodeLine{00078     \{}
\DoxyCodeLine{00079         ParticleAddCSApp theApp(hInstance);}
\DoxyCodeLine{00080         \textcolor{keywordflow}{if}(!theApp.Initialize())}
\DoxyCodeLine{00081             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00082 }
\DoxyCodeLine{00083        \textcolor{comment}{// return theApp.Run();}}
\DoxyCodeLine{00084         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00085     \}}
\DoxyCodeLine{00086     \textcolor{keywordflow}{catch}(DxException\& e)}
\DoxyCodeLine{00087     \{}
\DoxyCodeLine{00088         MessageBox(\textcolor{keyword}{nullptr}, e.ToString().c\_str(), L\textcolor{stringliteral}{"{}HR Failed"{}}, MB\_OK);}
\DoxyCodeLine{00089         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00090     \}}
\DoxyCodeLine{00091 \}}
\DoxyCodeLine{00092 }
\DoxyCodeLine{00093 ParticleAddCSApp::ParticleAddCSApp(HINSTANCE hInstance)}
\DoxyCodeLine{00094     : D3DApp(hInstance)}
\DoxyCodeLine{00095 \{}
\DoxyCodeLine{00096 \}}
\DoxyCodeLine{00097 }
\DoxyCodeLine{00098 ParticleAddCSApp::\string~ParticleAddCSApp()}
\DoxyCodeLine{00099 \{}
\DoxyCodeLine{00100     \textcolor{keywordflow}{if}(md3dDevice != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00101         FlushCommandQueue();}
\DoxyCodeLine{00102 \}}
\DoxyCodeLine{00103 }
\DoxyCodeLine{00104 \textcolor{keywordtype}{bool} ParticleAddCSApp::Initialize()}
\DoxyCodeLine{00105 \{}
\DoxyCodeLine{00106     \textcolor{keywordflow}{if}(!D3DApp::Initialize())}
\DoxyCodeLine{00107         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00108 }
\DoxyCodeLine{00109     \textcolor{comment}{// Reset the command list to prep for initialization commands.}}
\DoxyCodeLine{00110     ThrowIfFailed(mCommandList-\/>Reset(mDirectCmdListAlloc.Get(), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{00111 }
\DoxyCodeLine{00112 }
\DoxyCodeLine{00113     BuildBuffers();}
\DoxyCodeLine{00114     BuildRootSignature();}
\DoxyCodeLine{00115     BuildShadersAndInputLayout();}
\DoxyCodeLine{00116     BuildPSOs();}
\DoxyCodeLine{00117 }
\DoxyCodeLine{00118     \textcolor{comment}{// Execute the initialization commands.}}
\DoxyCodeLine{00119     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00120     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00121     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00122 }
\DoxyCodeLine{00123     \textcolor{comment}{// Wait until initialization is complete.}}
\DoxyCodeLine{00124     FlushCommandQueue();}
\DoxyCodeLine{00125 }
\DoxyCodeLine{00126     DoComputeWork();}
\DoxyCodeLine{00127 }
\DoxyCodeLine{00128     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00129 \}}
\DoxyCodeLine{00130  }
\DoxyCodeLine{00131 \textcolor{keywordtype}{void} ParticleAddCSApp::OnResize()}
\DoxyCodeLine{00132 \{}
\DoxyCodeLine{00133 \}}
\DoxyCodeLine{00134 }
\DoxyCodeLine{00135 \textcolor{keywordtype}{void} ParticleAddCSApp::Update(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00136 \{}
\DoxyCodeLine{00137 \}}
\DoxyCodeLine{00138 }
\DoxyCodeLine{00139 \textcolor{keywordtype}{void} ParticleAddCSApp::Draw(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00140 \{}
\DoxyCodeLine{00141 \}}
\DoxyCodeLine{00142 }
\DoxyCodeLine{00143  }
\DoxyCodeLine{00144 \textcolor{keywordtype}{void} ParticleAddCSApp::DoComputeWork()}
\DoxyCodeLine{00145 \{}
\DoxyCodeLine{00146     \textcolor{comment}{// Reuse the memory associated with command recording.}}
\DoxyCodeLine{00147     \textcolor{comment}{// We can only reset when the associated command lists have finished execution on the GPU.}}
\DoxyCodeLine{00148     ThrowIfFailed(mDirectCmdListAlloc-\/>Reset());}
\DoxyCodeLine{00149 }
\DoxyCodeLine{00150     \textcolor{comment}{// A command list can be reset after it has been added to the command queue via ExecuteCommandList.}}
\DoxyCodeLine{00151     \textcolor{comment}{// Reusing the command list reuses memory.}}
\DoxyCodeLine{00152     ThrowIfFailed(mCommandList-\/>Reset(mDirectCmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}particleAdd"{}}].Get()));}
\DoxyCodeLine{00153 }
\DoxyCodeLine{00154     mCommandList-\/>SetComputeRootSignature(mRootSignature.Get());}
\DoxyCodeLine{00155 }
\DoxyCodeLine{00156     mCommandList-\/>SetComputeRootUnorderedAccessView(0, mInputBufferA-\/>GetGPUVirtualAddress());}
\DoxyCodeLine{00157     mCommandList-\/>SetComputeRootUnorderedAccessView(1, mOutputBuffer-\/>GetGPUVirtualAddress());}
\DoxyCodeLine{00158  }
\DoxyCodeLine{00159     mCommandList-\/>Dispatch(1, 1, 1);}
\DoxyCodeLine{00160 }
\DoxyCodeLine{00161     \textcolor{comment}{// Schedule to copy the data to the default buffer to the readback buffer.}}
\DoxyCodeLine{00162 }
\DoxyCodeLine{00163     \textcolor{comment}{//D3D12\_RESOURCE\_STATE\_COPY\_SOURCE: The resource is used as the source in a copy operation. }}
\DoxyCodeLine{00164     \textcolor{comment}{//D3D12\_RESOURCE\_STATE\_COPY\_DEST: The resource is used as the destination in a copy operation.}}
\DoxyCodeLine{00165 }
\DoxyCodeLine{00166     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mOutputBuffer.Get(), }
\DoxyCodeLine{00167         D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS, D3D12\_RESOURCE\_STATE\_COPY\_SOURCE));}
\DoxyCodeLine{00168 }
\DoxyCodeLine{00169     \textcolor{comment}{//We need to read the data back from the GPU after computer shader does its calculation}}
\DoxyCodeLine{00170     \textcolor{comment}{//mCommandList-\/>CopyResource(Destination: CPUData, Source: GPUData);}}
\DoxyCodeLine{00171     mCommandList-\/>CopyResource(mReadBackBuffer.Get(), mOutputBuffer.Get());}
\DoxyCodeLine{00172 }
\DoxyCodeLine{00173     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mOutputBuffer.Get(),}
\DoxyCodeLine{00174         D3D12\_RESOURCE\_STATE\_COPY\_SOURCE, D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS));}
\DoxyCodeLine{00175 }
\DoxyCodeLine{00176 }
\DoxyCodeLine{00177     \textcolor{comment}{// Done recording commands.}}
\DoxyCodeLine{00178     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00179 }
\DoxyCodeLine{00180     \textcolor{comment}{// Add the command list to the queue for execution.}}
\DoxyCodeLine{00181     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00182     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00183 }
\DoxyCodeLine{00184     \textcolor{comment}{// Wait for the work to finish.}}
\DoxyCodeLine{00185     FlushCommandQueue();}
\DoxyCodeLine{00186 }
\DoxyCodeLine{00187     \textcolor{comment}{// Map the data so we can read it on CPU.}}
\DoxyCodeLine{00188     Particle* mappedData = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00189     ThrowIfFailed(mReadBackBuffer-\/>Map(0, \textcolor{keyword}{nullptr}, \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}**\textcolor{keyword}{>}(\&mappedData)));}
\DoxyCodeLine{00190 }
\DoxyCodeLine{00191     std::ofstream fout(\textcolor{stringliteral}{"{}results.txt"{}});}
\DoxyCodeLine{00192 }
\DoxyCodeLine{00193     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < NumDataElements; ++i)}
\DoxyCodeLine{00194     \{}
\DoxyCodeLine{00195         fout << \textcolor{stringliteral}{"{}("{}} << mappedData[i].Acceleration.x << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Acceleration.y << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Acceleration.z <<}
\DoxyCodeLine{00196             \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Position.x << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Position.y << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Position.z <<}
\DoxyCodeLine{00197             \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Velocity.x << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Velocity.y << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Velocity.z << \textcolor{stringliteral}{"{})"{}} << std::endl;}
\DoxyCodeLine{00198     \}}
\DoxyCodeLine{00199 }
\DoxyCodeLine{00200     mReadBackBuffer-\/>Unmap(0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00201 \}}
\DoxyCodeLine{00202 }
\DoxyCodeLine{00203 \textcolor{keywordtype}{void} ParticleAddCSApp::BuildBuffers()}
\DoxyCodeLine{00204 \{}
\DoxyCodeLine{00205     \textcolor{comment}{// Generate some data.}}
\DoxyCodeLine{00206     std::vector<Particle> dataA(NumDataElements);}
\DoxyCodeLine{00207     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < NumDataElements; ++i)}
\DoxyCodeLine{00208     \{}
\DoxyCodeLine{00209         dataA[i].Acceleration = XMFLOAT3(1.0f, 1.0f, 1.0f);}
\DoxyCodeLine{00210         dataA[i].Position = XMFLOAT3((\textcolor{keywordtype}{float})i, (\textcolor{keywordtype}{float})i, (\textcolor{keywordtype}{float})i);}
\DoxyCodeLine{00211         dataA[i].Velocity = XMFLOAT3(10.0f, 10.0f, 0);}
\DoxyCodeLine{00212     \}}
\DoxyCodeLine{00213 }
\DoxyCodeLine{00214 }
\DoxyCodeLine{00215     std::ofstream fout(\textcolor{stringliteral}{"{}inputs.txt"{}});}
\DoxyCodeLine{00216     fout << \textcolor{stringliteral}{"{}Acceleration(x,y,z), Position(x,y,z), Velocity(x,y,z)"{}} << std::endl;}
\DoxyCodeLine{00217     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDataElements; ++i)}
\DoxyCodeLine{00218     \{}
\DoxyCodeLine{00219         fout << \textcolor{stringliteral}{"{}("{}} << dataA[i].Acceleration.x << \textcolor{stringliteral}{"{}, "{}} << dataA[i].Acceleration.y << \textcolor{stringliteral}{"{}, "{}} << dataA[i].Acceleration.z <<}
\DoxyCodeLine{00220             \textcolor{stringliteral}{"{}, "{}} << dataA[i].Position.x << \textcolor{stringliteral}{"{}, "{}} << dataA[i].Position.y << \textcolor{stringliteral}{"{}, "{}} << dataA[i].Position.z <<}
\DoxyCodeLine{00221             \textcolor{stringliteral}{"{}, "{}} << dataA[i].Velocity.x << \textcolor{stringliteral}{"{}, "{}} << dataA[i].Velocity.y << \textcolor{stringliteral}{"{}, "{}} << dataA[i].Velocity.z << \textcolor{stringliteral}{"{})"{}} << std::endl;}
\DoxyCodeLine{00222     \}}
\DoxyCodeLine{00223 }
\DoxyCodeLine{00224 }
\DoxyCodeLine{00225     UINT64 byteSize = dataA.size()*\textcolor{keyword}{sizeof}(Particle);}
\DoxyCodeLine{00226 }
\DoxyCodeLine{00227     \textcolor{comment}{// Create some buffers to be used as SRV.}}
\DoxyCodeLine{00228     \textcolor{comment}{//mInputBufferA = d3dUtil::CreateDefaultBuffer(}}
\DoxyCodeLine{00229     \textcolor{comment}{//  md3dDevice.Get(),}}
\DoxyCodeLine{00230     \textcolor{comment}{//  mCommandList.Get(),}}
\DoxyCodeLine{00231     \textcolor{comment}{//  dataA.data(),}}
\DoxyCodeLine{00232     \textcolor{comment}{//  byteSize,}}
\DoxyCodeLine{00233     \textcolor{comment}{//  mInputUploadBufferA);}}
\DoxyCodeLine{00234 }
\DoxyCodeLine{00235 }
\DoxyCodeLine{00236     \textcolor{comment}{// Create the actual mInputBufferA buffer resource.}}
\DoxyCodeLine{00237     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00238         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_DEFAULT),}
\DoxyCodeLine{00239         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00240         \&CD3DX12\_RESOURCE\_DESC::Buffer(byteSize, D3D12\_RESOURCE\_FLAG\_ALLOW\_UNORDERED\_ACCESS),}
\DoxyCodeLine{00241         D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS,}
\DoxyCodeLine{00242         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00243         IID\_PPV\_ARGS(\&mInputBufferA)));}
\DoxyCodeLine{00244 }
\DoxyCodeLine{00245     \textcolor{comment}{// In order to copy CPU memory data into our mInputBufferA buffer, we need to create}}
\DoxyCodeLine{00246     \textcolor{comment}{// an intermediate upload heap. }}
\DoxyCodeLine{00247     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00248         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_UPLOAD),}
\DoxyCodeLine{00249         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00250         \&CD3DX12\_RESOURCE\_DESC::Buffer(byteSize),}
\DoxyCodeLine{00251         D3D12\_RESOURCE\_STATE\_GENERIC\_READ,}
\DoxyCodeLine{00252         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00253         IID\_PPV\_ARGS(mInputUploadBufferA.GetAddressOf())));}
\DoxyCodeLine{00254 }
\DoxyCodeLine{00255 }
\DoxyCodeLine{00256     \textcolor{comment}{// Describe the data we want to copy into the mInputBufferA buffer.}}
\DoxyCodeLine{00257     D3D12\_SUBRESOURCE\_DATA subResourceData = \{\};}
\DoxyCodeLine{00258     subResourceData.pData = dataA.data();}
\DoxyCodeLine{00259     subResourceData.RowPitch = byteSize;}
\DoxyCodeLine{00260     subResourceData.SlicePitch = subResourceData.RowPitch;}
\DoxyCodeLine{00261 }
\DoxyCodeLine{00262     \textcolor{comment}{// Schedule to copy the data to the mInputBufferA buffer resource.  At a high level, the helper function UpdateSubresources}}
\DoxyCodeLine{00263     \textcolor{comment}{// will copy the CPU memory into the intermediate upload heap.  Then, using ID3D12CommandList::CopySubresourceRegion,}}
\DoxyCodeLine{00264     \textcolor{comment}{// the intermediate upload heap data will be copied to mBuffer.}}
\DoxyCodeLine{00265     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mInputBufferA.Get(),}
\DoxyCodeLine{00266         D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS, D3D12\_RESOURCE\_STATE\_COPY\_DEST));}
\DoxyCodeLine{00267 }
\DoxyCodeLine{00268     UpdateSubresources(mCommandList.Get(), mInputBufferA.Get(), mInputUploadBufferA.Get(), 0, 0, 1, \&subResourceData);}
\DoxyCodeLine{00269 }
\DoxyCodeLine{00270 }
\DoxyCodeLine{00271     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mInputBufferA.Get(),}
\DoxyCodeLine{00272         D3D12\_RESOURCE\_STATE\_COPY\_DEST, D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS));}
\DoxyCodeLine{00273 }
\DoxyCodeLine{00274 }
\DoxyCodeLine{00275     \textcolor{comment}{// Create the buffer that will be a UAV.}}
\DoxyCodeLine{00276     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00277         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_DEFAULT),}
\DoxyCodeLine{00278         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00279         \&CD3DX12\_RESOURCE\_DESC::Buffer(byteSize, D3D12\_RESOURCE\_FLAG\_ALLOW\_UNORDERED\_ACCESS),}
\DoxyCodeLine{00280         D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS,}
\DoxyCodeLine{00281         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00282         IID\_PPV\_ARGS(\&mOutputBuffer)));}
\DoxyCodeLine{00283     }
\DoxyCodeLine{00284     \textcolor{comment}{//Specifies a heap used for reading back. This heap type has CPU access optimized for reading data back from the GPU, }}
\DoxyCodeLine{00285     \textcolor{comment}{//but does not experience the maximum amount of bandwidth for the GPU. This heap type is best for GPU-\/write-\/once, }}
\DoxyCodeLine{00286     \textcolor{comment}{//CPU-\/readable data. The CPU cache behavior is write-\/back, which is conducive for multiple sub-\/cache-\/line CPU reads.}}
\DoxyCodeLine{00287     \textcolor{comment}{//Resources in this heap must be created with D3D12\_RESOURCE\_STATE\_COPY\_DEST, and cannot be changed away from this}}
\DoxyCodeLine{00288     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00289         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_READBACK),}
\DoxyCodeLine{00290         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00291         \&CD3DX12\_RESOURCE\_DESC::Buffer(byteSize),}
\DoxyCodeLine{00292         D3D12\_RESOURCE\_STATE\_COPY\_DEST,}
\DoxyCodeLine{00293         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00294         IID\_PPV\_ARGS(\&mReadBackBuffer)));}
\DoxyCodeLine{00295 \}}
\DoxyCodeLine{00296 }
\DoxyCodeLine{00297 \textcolor{keywordtype}{void} ParticleAddCSApp::BuildRootSignature()}
\DoxyCodeLine{00298 \{}
\DoxyCodeLine{00299 }
\DoxyCodeLine{00300 }
\DoxyCodeLine{00301     \textcolor{comment}{// Root parameter can be a table, root descriptor or root constants.}}
\DoxyCodeLine{00302     CD3DX12\_ROOT\_PARAMETER slotRootParameter[2];}
\DoxyCodeLine{00303 }
\DoxyCodeLine{00304     \textcolor{comment}{// Perfomance TIP: Order from most frequent to least frequent.}}
\DoxyCodeLine{00305     slotRootParameter[0].InitAsUnorderedAccessView(0);}
\DoxyCodeLine{00306     slotRootParameter[1].InitAsUnorderedAccessView(1);}
\DoxyCodeLine{00307 }
\DoxyCodeLine{00308 }
\DoxyCodeLine{00309     \textcolor{comment}{// A root signature is an array of root parameters.}}
\DoxyCodeLine{00310     CD3DX12\_ROOT\_SIGNATURE\_DESC rootSigDesc(2, slotRootParameter,}
\DoxyCodeLine{00311         0, \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00312         D3D12\_ROOT\_SIGNATURE\_FLAG\_NONE);}
\DoxyCodeLine{00313 }
\DoxyCodeLine{00314     \textcolor{comment}{// create a root signature with a single slot which points to a descriptor range consisting of a single constant buffer}}
\DoxyCodeLine{00315     ComPtr<ID3DBlob> serializedRootSig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00316     ComPtr<ID3DBlob> errorBlob = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00317 }
\DoxyCodeLine{00318 }
\DoxyCodeLine{00319     HRESULT hr = D3D12SerializeRootSignature(\&rootSigDesc, D3D\_ROOT\_SIGNATURE\_VERSION\_1,}
\DoxyCodeLine{00320         serializedRootSig.GetAddressOf(), errorBlob.GetAddressOf());}
\DoxyCodeLine{00321 }
\DoxyCodeLine{00322     \textcolor{keywordflow}{if}(errorBlob != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00323     \{}
\DoxyCodeLine{00324         ::OutputDebugStringA((\textcolor{keywordtype}{char}*)errorBlob-\/>GetBufferPointer());}
\DoxyCodeLine{00325     \}}
\DoxyCodeLine{00326     ThrowIfFailed(hr);}
\DoxyCodeLine{00327 }
\DoxyCodeLine{00328     ThrowIfFailed(md3dDevice-\/>CreateRootSignature(}
\DoxyCodeLine{00329         0,}
\DoxyCodeLine{00330         serializedRootSig-\/>GetBufferPointer(),}
\DoxyCodeLine{00331         serializedRootSig-\/>GetBufferSize(),}
\DoxyCodeLine{00332         IID\_PPV\_ARGS(mRootSignature.GetAddressOf())));}
\DoxyCodeLine{00333 \}}
\DoxyCodeLine{00334 }
\DoxyCodeLine{00335 }
\DoxyCodeLine{00336 \textcolor{keywordtype}{void} ParticleAddCSApp::BuildShadersAndInputLayout()}
\DoxyCodeLine{00337 \{}
\DoxyCodeLine{00338     mShaders[\textcolor{stringliteral}{"{}particleAddCS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)ParticleAdd.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}CS"{}}, \textcolor{stringliteral}{"{}cs\_5\_1"{}});}
\DoxyCodeLine{00339 \}}
\DoxyCodeLine{00340 }
\DoxyCodeLine{00341 \textcolor{keywordtype}{void} ParticleAddCSApp::BuildPSOs()}
\DoxyCodeLine{00342 \{}
\DoxyCodeLine{00343     D3D12\_COMPUTE\_PIPELINE\_STATE\_DESC computePsoDesc = \{\};}
\DoxyCodeLine{00344     computePsoDesc.pRootSignature = mRootSignature.Get();}
\DoxyCodeLine{00345     computePsoDesc.CS =}
\DoxyCodeLine{00346     \{}
\DoxyCodeLine{00347         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}particleAddCS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00348         mShaders[\textcolor{stringliteral}{"{}particleAddCS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00349     \};}
\DoxyCodeLine{00350     computePsoDesc.Flags = D3D12\_PIPELINE\_STATE\_FLAG\_NONE;}
\DoxyCodeLine{00351     ThrowIfFailed(md3dDevice-\/>CreateComputePipelineState(\&computePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}particleAdd"{}}])));}
\DoxyCodeLine{00352 \}}
\DoxyCodeLine{00353 }
\DoxyCodeLine{00354 }
\DoxyCodeLine{00355 }

\end{DoxyCode}
