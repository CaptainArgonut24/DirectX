\doxysection{Gpu\+Waves.\+cpp}
\label{_sobel_filter_2_gpu_waves_8cpp_source}\index{Week8/SobelFilter/GpuWaves.cpp@{Week8/SobelFilter/GpuWaves.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00002 \textcolor{comment}{// GpuWaves.cpp by Frank Luna (C) 2011 All Rights Reserved.}}
\DoxyCodeLine{00003 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00004 }
\DoxyCodeLine{00005 \textcolor{preprocessor}{\#include "{}GpuWaves.h"{}}}
\DoxyCodeLine{00006 \textcolor{preprocessor}{\#include "{}Effects.h"{}}}
\DoxyCodeLine{00007 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{00008 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{00009 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{00010 }
\DoxyCodeLine{00011 GpuWaves::GpuWaves(ID3D12Device* device, ID3D12GraphicsCommandList* cmdList, }
\DoxyCodeLine{00012                    \textcolor{keywordtype}{int} m, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{float} dx, \textcolor{keywordtype}{float} dt, \textcolor{keywordtype}{float} speed, \textcolor{keywordtype}{float} damping)}
\DoxyCodeLine{00013 \{}
\DoxyCodeLine{00014     md3dDevice = device;}
\DoxyCodeLine{00015 }
\DoxyCodeLine{00016     mNumRows = m;}
\DoxyCodeLine{00017     mNumCols = n;}
\DoxyCodeLine{00018 }
\DoxyCodeLine{00019     assert((m*n) \% 256 == 0);}
\DoxyCodeLine{00020 }
\DoxyCodeLine{00021     mVertexCount = m*n;}
\DoxyCodeLine{00022     mTriangleCount = (m -\/ 1)*(n -\/ 1) * 2;}
\DoxyCodeLine{00023 }
\DoxyCodeLine{00024     mTimeStep = dt;}
\DoxyCodeLine{00025     mSpatialStep = dx;}
\DoxyCodeLine{00026 }
\DoxyCodeLine{00027     \textcolor{keywordtype}{float} d = damping*dt + 2.0f;}
\DoxyCodeLine{00028     \textcolor{keywordtype}{float} e = (speed*speed)*(dt*dt) / (dx*dx);}
\DoxyCodeLine{00029     mK[0] = (damping*dt -\/ 2.0f) / d;}
\DoxyCodeLine{00030     mK[1] = (4.0f -\/ 8.0f*e) / d;}
\DoxyCodeLine{00031     mK[2] = (2.0f*e) / d;}
\DoxyCodeLine{00032 }
\DoxyCodeLine{00033     BuildResources(cmdList);}
\DoxyCodeLine{00034 \}}
\DoxyCodeLine{00035 }
\DoxyCodeLine{00036 UINT GpuWaves::RowCount()\textcolor{keyword}{const}}
\DoxyCodeLine{00037 \textcolor{keyword}{}\{}
\DoxyCodeLine{00038     \textcolor{keywordflow}{return} mNumRows;}
\DoxyCodeLine{00039 \}}
\DoxyCodeLine{00040 }
\DoxyCodeLine{00041 UINT GpuWaves::ColumnCount()\textcolor{keyword}{const}}
\DoxyCodeLine{00042 \textcolor{keyword}{}\{}
\DoxyCodeLine{00043     \textcolor{keywordflow}{return} mNumCols;}
\DoxyCodeLine{00044 \}}
\DoxyCodeLine{00045 }
\DoxyCodeLine{00046 UINT GpuWaves::VertexCount()\textcolor{keyword}{const}}
\DoxyCodeLine{00047 \textcolor{keyword}{}\{}
\DoxyCodeLine{00048     \textcolor{keywordflow}{return} mVertexCount;}
\DoxyCodeLine{00049 \}}
\DoxyCodeLine{00050 }
\DoxyCodeLine{00051 UINT GpuWaves::TriangleCount()\textcolor{keyword}{const}}
\DoxyCodeLine{00052 \textcolor{keyword}{}\{}
\DoxyCodeLine{00053     \textcolor{keywordflow}{return} mTriangleCount;}
\DoxyCodeLine{00054 \}}
\DoxyCodeLine{00055 }
\DoxyCodeLine{00056 \textcolor{keywordtype}{float} GpuWaves::Width()\textcolor{keyword}{const}}
\DoxyCodeLine{00057 \textcolor{keyword}{}\{}
\DoxyCodeLine{00058     \textcolor{keywordflow}{return} mNumCols*mSpatialStep;}
\DoxyCodeLine{00059 \}}
\DoxyCodeLine{00060 }
\DoxyCodeLine{00061 \textcolor{keywordtype}{float} GpuWaves::Depth()\textcolor{keyword}{const}}
\DoxyCodeLine{00062 \textcolor{keyword}{}\{}
\DoxyCodeLine{00063     \textcolor{keywordflow}{return} mNumRows*mSpatialStep;}
\DoxyCodeLine{00064 \}}
\DoxyCodeLine{00065 }
\DoxyCodeLine{00066 \textcolor{keywordtype}{float} GpuWaves::SpatialStep()\textcolor{keyword}{const}}
\DoxyCodeLine{00067 \textcolor{keyword}{}\{}
\DoxyCodeLine{00068     \textcolor{keywordflow}{return} mSpatialStep;}
\DoxyCodeLine{00069 \}}
\DoxyCodeLine{00070 }
\DoxyCodeLine{00071 CD3DX12\_GPU\_DESCRIPTOR\_HANDLE GpuWaves::DisplacementMap()\textcolor{keyword}{const}}
\DoxyCodeLine{00072 \textcolor{keyword}{}\{}
\DoxyCodeLine{00073     \textcolor{keywordflow}{return} mCurrSolSrv;}
\DoxyCodeLine{00074 \}}
\DoxyCodeLine{00075 }
\DoxyCodeLine{00076 UINT GpuWaves::DescriptorCount()\textcolor{keyword}{const}}
\DoxyCodeLine{00077 \textcolor{keyword}{}\{}
\DoxyCodeLine{00078     \textcolor{comment}{// Number of descriptors in heap to reserve for GpuWaves.}}
\DoxyCodeLine{00079     \textcolor{keywordflow}{return} 6;}
\DoxyCodeLine{00080 \}}
\DoxyCodeLine{00081 }
\DoxyCodeLine{00082 \textcolor{keywordtype}{void} GpuWaves::BuildResources(ID3D12GraphicsCommandList* cmdList)}
\DoxyCodeLine{00083 \{}
\DoxyCodeLine{00084     \textcolor{comment}{// All the textures for the wave simulation will be bound as a shader resource and}}
\DoxyCodeLine{00085     \textcolor{comment}{// unordered access view at some point since we ping-\/pong the buffers.}}
\DoxyCodeLine{00086 }
\DoxyCodeLine{00087     D3D12\_RESOURCE\_DESC texDesc;}
\DoxyCodeLine{00088     ZeroMemory(\&texDesc, \textcolor{keyword}{sizeof}(D3D12\_RESOURCE\_DESC));}
\DoxyCodeLine{00089     texDesc.Dimension = D3D12\_RESOURCE\_DIMENSION\_TEXTURE2D;}
\DoxyCodeLine{00090     texDesc.Alignment = 0;}
\DoxyCodeLine{00091     texDesc.Width = mNumCols;}
\DoxyCodeLine{00092     texDesc.Height = mNumRows;}
\DoxyCodeLine{00093     texDesc.DepthOrArraySize = 1;}
\DoxyCodeLine{00094     texDesc.MipLevels = 1;}
\DoxyCodeLine{00095     texDesc.Format = DXGI\_FORMAT\_R32\_FLOAT;}
\DoxyCodeLine{00096     texDesc.SampleDesc.Count = 1;}
\DoxyCodeLine{00097     texDesc.SampleDesc.Quality = 0;}
\DoxyCodeLine{00098     texDesc.Layout = D3D12\_TEXTURE\_LAYOUT\_UNKNOWN;}
\DoxyCodeLine{00099     texDesc.Flags = D3D12\_RESOURCE\_FLAG\_ALLOW\_UNORDERED\_ACCESS;}
\DoxyCodeLine{00100 }
\DoxyCodeLine{00101     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00102         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_DEFAULT),}
\DoxyCodeLine{00103         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00104         \&texDesc,}
\DoxyCodeLine{00105         D3D12\_RESOURCE\_STATE\_COMMON,}
\DoxyCodeLine{00106         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00107         IID\_PPV\_ARGS(\&mPrevSol)));}
\DoxyCodeLine{00108 }
\DoxyCodeLine{00109     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00110         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_DEFAULT),}
\DoxyCodeLine{00111         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00112         \&texDesc,}
\DoxyCodeLine{00113         D3D12\_RESOURCE\_STATE\_COMMON,}
\DoxyCodeLine{00114         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00115         IID\_PPV\_ARGS(\&mCurrSol)));}
\DoxyCodeLine{00116 }
\DoxyCodeLine{00117     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00118         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_DEFAULT),}
\DoxyCodeLine{00119         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00120         \&texDesc,}
\DoxyCodeLine{00121         D3D12\_RESOURCE\_STATE\_COMMON,}
\DoxyCodeLine{00122         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00123         IID\_PPV\_ARGS(\&mNextSol)));}
\DoxyCodeLine{00124 }
\DoxyCodeLine{00125     \textcolor{comment}{//}}
\DoxyCodeLine{00126     \textcolor{comment}{// In order to copy CPU memory data into our default buffer, we need to create}}
\DoxyCodeLine{00127     \textcolor{comment}{// an intermediate upload heap. }}
\DoxyCodeLine{00128     \textcolor{comment}{//}}
\DoxyCodeLine{00129 }
\DoxyCodeLine{00130     \textcolor{keyword}{const} UINT num2DSubresources = texDesc.DepthOrArraySize * texDesc.MipLevels;}
\DoxyCodeLine{00131     \textcolor{keyword}{const} UINT64 uploadBufferSize = GetRequiredIntermediateSize(mCurrSol.Get(), 0, num2DSubresources);}
\DoxyCodeLine{00132 }
\DoxyCodeLine{00133     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00134         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_UPLOAD),}
\DoxyCodeLine{00135         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00136         \&CD3DX12\_RESOURCE\_DESC::Buffer(uploadBufferSize),}
\DoxyCodeLine{00137         D3D12\_RESOURCE\_STATE\_GENERIC\_READ,}
\DoxyCodeLine{00138         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00139         IID\_PPV\_ARGS(mPrevUploadBuffer.GetAddressOf())));}
\DoxyCodeLine{00140 }
\DoxyCodeLine{00141     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00142         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_UPLOAD),}
\DoxyCodeLine{00143         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00144         \&CD3DX12\_RESOURCE\_DESC::Buffer(uploadBufferSize),}
\DoxyCodeLine{00145         D3D12\_RESOURCE\_STATE\_GENERIC\_READ,}
\DoxyCodeLine{00146         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00147         IID\_PPV\_ARGS(mCurrUploadBuffer.GetAddressOf())));}
\DoxyCodeLine{00148 }
\DoxyCodeLine{00149     \textcolor{comment}{// Describe the data we want to copy into the default buffer.}}
\DoxyCodeLine{00150     std::vector<float> initData(mNumRows*mNumCols, 0.0f);}
\DoxyCodeLine{00151     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < initData.size(); ++i)}
\DoxyCodeLine{00152         initData[i] = 0.0f;}
\DoxyCodeLine{00153 }
\DoxyCodeLine{00154     D3D12\_SUBRESOURCE\_DATA subResourceData = \{\};}
\DoxyCodeLine{00155     subResourceData.pData = initData.data();}
\DoxyCodeLine{00156     subResourceData.RowPitch = mNumCols*\textcolor{keyword}{sizeof}(float);}
\DoxyCodeLine{00157     subResourceData.SlicePitch = subResourceData.RowPitch * mNumRows;}
\DoxyCodeLine{00158 }
\DoxyCodeLine{00159     \textcolor{comment}{//}}
\DoxyCodeLine{00160     \textcolor{comment}{// Schedule to copy the data to the default resource, and change states.}}
\DoxyCodeLine{00161     \textcolor{comment}{// Note that mCurrSol is put in the GENERIC\_READ state so it can be }}
\DoxyCodeLine{00162     \textcolor{comment}{// read by a shader.}}
\DoxyCodeLine{00163     \textcolor{comment}{//}}
\DoxyCodeLine{00164 }
\DoxyCodeLine{00165     cmdList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mPrevSol.Get(),}
\DoxyCodeLine{00166         D3D12\_RESOURCE\_STATE\_COMMON, D3D12\_RESOURCE\_STATE\_COPY\_DEST));}
\DoxyCodeLine{00167     UpdateSubresources(cmdList, mPrevSol.Get(), mPrevUploadBuffer.Get(), 0, 0, num2DSubresources, \&subResourceData);}
\DoxyCodeLine{00168     cmdList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mPrevSol.Get(),}
\DoxyCodeLine{00169         D3D12\_RESOURCE\_STATE\_COPY\_DEST, D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS));}
\DoxyCodeLine{00170 }
\DoxyCodeLine{00171     cmdList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mCurrSol.Get(),}
\DoxyCodeLine{00172         D3D12\_RESOURCE\_STATE\_COMMON, D3D12\_RESOURCE\_STATE\_COPY\_DEST));}
\DoxyCodeLine{00173     UpdateSubresources(cmdList, mCurrSol.Get(), mCurrUploadBuffer.Get(), 0, 0, num2DSubresources, \&subResourceData);}
\DoxyCodeLine{00174     cmdList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mCurrSol.Get(),}
\DoxyCodeLine{00175         D3D12\_RESOURCE\_STATE\_COPY\_DEST, D3D12\_RESOURCE\_STATE\_GENERIC\_READ));}
\DoxyCodeLine{00176 }
\DoxyCodeLine{00177     cmdList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mNextSol.Get(),}
\DoxyCodeLine{00178         D3D12\_RESOURCE\_STATE\_COMMON, D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS));}
\DoxyCodeLine{00179 \}}
\DoxyCodeLine{00180 }
\DoxyCodeLine{00181 \textcolor{keywordtype}{void} GpuWaves::BuildDescriptors(}
\DoxyCodeLine{00182     CD3DX12\_CPU\_DESCRIPTOR\_HANDLE hCpuDescriptor,}
\DoxyCodeLine{00183     CD3DX12\_GPU\_DESCRIPTOR\_HANDLE hGpuDescriptor,}
\DoxyCodeLine{00184     UINT descriptorSize)}
\DoxyCodeLine{00185 \{}
\DoxyCodeLine{00186     D3D12\_SHADER\_RESOURCE\_VIEW\_DESC srvDesc = \{\};}
\DoxyCodeLine{00187     srvDesc.Shader4ComponentMapping = D3D12\_DEFAULT\_SHADER\_4\_COMPONENT\_MAPPING;}
\DoxyCodeLine{00188     srvDesc.Format = DXGI\_FORMAT\_R32\_FLOAT;}
\DoxyCodeLine{00189     srvDesc.ViewDimension = D3D12\_SRV\_DIMENSION\_TEXTURE2D;}
\DoxyCodeLine{00190     srvDesc.Texture2D.MostDetailedMip = 0;}
\DoxyCodeLine{00191     srvDesc.Texture2D.MipLevels = 1;}
\DoxyCodeLine{00192     }
\DoxyCodeLine{00193     D3D12\_UNORDERED\_ACCESS\_VIEW\_DESC uavDesc = \{\};}
\DoxyCodeLine{00194 }
\DoxyCodeLine{00195     uavDesc.Format = DXGI\_FORMAT\_R32\_FLOAT;}
\DoxyCodeLine{00196     uavDesc.ViewDimension = D3D12\_UAV\_DIMENSION\_TEXTURE2D;}
\DoxyCodeLine{00197     uavDesc.Texture2D.MipSlice = 0;}
\DoxyCodeLine{00198 }
\DoxyCodeLine{00199     md3dDevice-\/>CreateShaderResourceView(mPrevSol.Get(), \&srvDesc, hCpuDescriptor);}
\DoxyCodeLine{00200     md3dDevice-\/>CreateShaderResourceView(mCurrSol.Get(), \&srvDesc, hCpuDescriptor.Offset(1, descriptorSize));}
\DoxyCodeLine{00201     md3dDevice-\/>CreateShaderResourceView(mNextSol.Get(), \&srvDesc, hCpuDescriptor.Offset(1, descriptorSize));}
\DoxyCodeLine{00202 }
\DoxyCodeLine{00203     md3dDevice-\/>CreateUnorderedAccessView(mPrevSol.Get(), \textcolor{keyword}{nullptr}, \&uavDesc, hCpuDescriptor.Offset(1, descriptorSize));}
\DoxyCodeLine{00204     md3dDevice-\/>CreateUnorderedAccessView(mCurrSol.Get(), \textcolor{keyword}{nullptr}, \&uavDesc, hCpuDescriptor.Offset(1, descriptorSize));}
\DoxyCodeLine{00205     md3dDevice-\/>CreateUnorderedAccessView(mNextSol.Get(), \textcolor{keyword}{nullptr}, \&uavDesc, hCpuDescriptor.Offset(1, descriptorSize));}
\DoxyCodeLine{00206 }
\DoxyCodeLine{00207     \textcolor{comment}{// Save references to the GPU descriptors. }}
\DoxyCodeLine{00208     mPrevSolSrv = hGpuDescriptor;}
\DoxyCodeLine{00209     mCurrSolSrv = hGpuDescriptor.Offset(1, descriptorSize);}
\DoxyCodeLine{00210     mNextSolSrv = hGpuDescriptor.Offset(1, descriptorSize);}
\DoxyCodeLine{00211     mPrevSolUav = hGpuDescriptor.Offset(1, descriptorSize);}
\DoxyCodeLine{00212     mCurrSolUav = hGpuDescriptor.Offset(1, descriptorSize);}
\DoxyCodeLine{00213     mNextSolUav = hGpuDescriptor.Offset(1, descriptorSize);}
\DoxyCodeLine{00214 \}}
\DoxyCodeLine{00215 }
\DoxyCodeLine{00216 \textcolor{keywordtype}{void} GpuWaves::Update(}
\DoxyCodeLine{00217     \textcolor{keyword}{const} GameTimer\& gt,}
\DoxyCodeLine{00218     ID3D12GraphicsCommandList* cmdList,}
\DoxyCodeLine{00219     ID3D12RootSignature* rootSig,}
\DoxyCodeLine{00220     ID3D12PipelineState* pso)}
\DoxyCodeLine{00221 \{}
\DoxyCodeLine{00222     \textcolor{keyword}{static} \textcolor{keywordtype}{float} t = 0.0f;}
\DoxyCodeLine{00223 }
\DoxyCodeLine{00224     \textcolor{comment}{// Accumulate time.}}
\DoxyCodeLine{00225     t += gt.DeltaTime();}
\DoxyCodeLine{00226 }
\DoxyCodeLine{00227     cmdList-\/>SetPipelineState(pso);}
\DoxyCodeLine{00228     cmdList-\/>SetComputeRootSignature(rootSig);}
\DoxyCodeLine{00229 }
\DoxyCodeLine{00230     \textcolor{comment}{// Only update the simulation at the specified time step.}}
\DoxyCodeLine{00231     \textcolor{keywordflow}{if}(t >= mTimeStep)}
\DoxyCodeLine{00232     \{}
\DoxyCodeLine{00233         \textcolor{comment}{// Set the update constants.}}
\DoxyCodeLine{00234         cmdList-\/>SetComputeRoot32BitConstants(0, 3, mK, 0);}
\DoxyCodeLine{00235 }
\DoxyCodeLine{00236         cmdList-\/>SetComputeRootDescriptorTable(1, mPrevSolUav);}
\DoxyCodeLine{00237         cmdList-\/>SetComputeRootDescriptorTable(2, mCurrSolUav);}
\DoxyCodeLine{00238         cmdList-\/>SetComputeRootDescriptorTable(3, mNextSolUav);}
\DoxyCodeLine{00239 }
\DoxyCodeLine{00240         \textcolor{comment}{// How many groups do we need to dispatch to cover the wave grid.  }}
\DoxyCodeLine{00241         \textcolor{comment}{// Note that mNumRows and mNumCols should be divisible by 16}}
\DoxyCodeLine{00242         \textcolor{comment}{// so there is no remainder.}}
\DoxyCodeLine{00243         UINT numGroupsX = mNumCols / 16;}
\DoxyCodeLine{00244         UINT numGroupsY = mNumRows / 16;}
\DoxyCodeLine{00245         cmdList-\/>Dispatch(numGroupsX, numGroupsY, 1);}
\DoxyCodeLine{00246  }
\DoxyCodeLine{00247         \textcolor{comment}{//}}
\DoxyCodeLine{00248         \textcolor{comment}{// Ping-\/pong buffers in preparation for the next update.}}
\DoxyCodeLine{00249         \textcolor{comment}{// The previous solution is no longer needed and becomes the target of the next solution in the next update.}}
\DoxyCodeLine{00250         \textcolor{comment}{// The current solution becomes the previous solution.}}
\DoxyCodeLine{00251         \textcolor{comment}{// The next solution becomes the current solution.}}
\DoxyCodeLine{00252         \textcolor{comment}{//}}
\DoxyCodeLine{00253 }
\DoxyCodeLine{00254         \textcolor{keyword}{auto} resTemp = mPrevSol;}
\DoxyCodeLine{00255         mPrevSol = mCurrSol;}
\DoxyCodeLine{00256         mCurrSol = mNextSol;}
\DoxyCodeLine{00257         mNextSol = resTemp;}
\DoxyCodeLine{00258 }
\DoxyCodeLine{00259         \textcolor{keyword}{auto} srvTemp = mPrevSolSrv;}
\DoxyCodeLine{00260         mPrevSolSrv = mCurrSolSrv;}
\DoxyCodeLine{00261         mCurrSolSrv = mNextSolSrv;}
\DoxyCodeLine{00262         mNextSolSrv = srvTemp;}
\DoxyCodeLine{00263 }
\DoxyCodeLine{00264         \textcolor{keyword}{auto} uavTemp = mPrevSolUav;}
\DoxyCodeLine{00265         mPrevSolUav = mCurrSolUav;}
\DoxyCodeLine{00266         mCurrSolUav = mNextSolUav;}
\DoxyCodeLine{00267         mNextSolUav = uavTemp;}
\DoxyCodeLine{00268 }
\DoxyCodeLine{00269         t = 0.0f; \textcolor{comment}{// reset time}}
\DoxyCodeLine{00270 }
\DoxyCodeLine{00271         \textcolor{comment}{// The current solution needs to be able to be read by the vertex shader, so change its state to GENERIC\_READ.}}
\DoxyCodeLine{00272         cmdList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mCurrSol.Get(),}
\DoxyCodeLine{00273             D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS, D3D12\_RESOURCE\_STATE\_GENERIC\_READ));}
\DoxyCodeLine{00274     \}}
\DoxyCodeLine{00275 \}}
\DoxyCodeLine{00276 }
\DoxyCodeLine{00277 \textcolor{keywordtype}{void} GpuWaves::Disturb(}
\DoxyCodeLine{00278     ID3D12GraphicsCommandList* cmdList,}
\DoxyCodeLine{00279     ID3D12RootSignature* rootSig,}
\DoxyCodeLine{00280     ID3D12PipelineState* pso,}
\DoxyCodeLine{00281     UINT i, UINT j,}
\DoxyCodeLine{00282     \textcolor{keywordtype}{float} magnitude)}
\DoxyCodeLine{00283 \{}
\DoxyCodeLine{00284     cmdList-\/>SetPipelineState(pso);}
\DoxyCodeLine{00285     cmdList-\/>SetComputeRootSignature(rootSig);}
\DoxyCodeLine{00286 }
\DoxyCodeLine{00287     \textcolor{comment}{// Set the disturb constants.}}
\DoxyCodeLine{00288     UINT disturbIndex[2] = \{ j, i \};}
\DoxyCodeLine{00289     cmdList-\/>SetComputeRoot32BitConstants(0, 1, \&magnitude, 3);}
\DoxyCodeLine{00290     cmdList-\/>SetComputeRoot32BitConstants(0, 2, disturbIndex, 4);}
\DoxyCodeLine{00291 }
\DoxyCodeLine{00292     cmdList-\/>SetComputeRootDescriptorTable(3, mCurrSolUav);}
\DoxyCodeLine{00293 }
\DoxyCodeLine{00294     \textcolor{comment}{// The current solution is in the GENERIC\_READ state so it can be read by the vertex shader.}}
\DoxyCodeLine{00295     \textcolor{comment}{// Change it to UNORDERED\_ACCESS for the compute shader.  Note that a UAV can still be}}
\DoxyCodeLine{00296     \textcolor{comment}{// read in a compute shader.}}
\DoxyCodeLine{00297     cmdList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mCurrSol.Get(),}
\DoxyCodeLine{00298         D3D12\_RESOURCE\_STATE\_GENERIC\_READ, D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS));}
\DoxyCodeLine{00299 }
\DoxyCodeLine{00300     \textcolor{comment}{// One thread group kicks off one thread, which displaces the height of one}}
\DoxyCodeLine{00301     \textcolor{comment}{// vertex and its neighbors.}}
\DoxyCodeLine{00302     cmdList-\/>Dispatch(1, 1, 1);}
\DoxyCodeLine{00303 \}}
\DoxyCodeLine{00304 }
\DoxyCodeLine{00305 }
\DoxyCodeLine{00306 }
\DoxyCodeLine{00307  }

\end{DoxyCode}
