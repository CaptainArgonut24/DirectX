\doxysection{Picking\+App.\+cpp}
\label{_picking_app_8cpp_source}\index{Week12/Picking/PickingApp.cpp@{Week12/Picking/PickingApp.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00002 \textcolor{comment}{// PickingApp.cpp }}
\DoxyCodeLine{00003 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00004 }
\DoxyCodeLine{00005 \textcolor{preprocessor}{\#include "{}../../Common/d3dApp.h"{}}}
\DoxyCodeLine{00006 \textcolor{preprocessor}{\#include "{}../../Common/MathHelper.h"{}}}
\DoxyCodeLine{00007 \textcolor{preprocessor}{\#include "{}../../Common/UploadBuffer.h"{}}}
\DoxyCodeLine{00008 \textcolor{preprocessor}{\#include "{}../../Common/GeometryGenerator.h"{}}}
\DoxyCodeLine{00009 \textcolor{preprocessor}{\#include "{}../../Common/Camera.h"{}}}
\DoxyCodeLine{00010 \textcolor{preprocessor}{\#include "{}FrameResource.h"{}}}
\DoxyCodeLine{00011 }
\DoxyCodeLine{00012 \textcolor{keyword}{using} Microsoft::WRL::ComPtr;}
\DoxyCodeLine{00013 \textcolor{keyword}{using namespace }DirectX;}
\DoxyCodeLine{00014 \textcolor{keyword}{using namespace }DirectX::PackedVector;}
\DoxyCodeLine{00015 }
\DoxyCodeLine{00016 \textcolor{preprocessor}{\#pragma comment(lib, "{}d3dcompiler.lib"{}})}
\DoxyCodeLine{00017 \textcolor{preprocessor}{\#pragma comment(lib, "{}D3D12.lib"{}})}
\DoxyCodeLine{00018 }
\DoxyCodeLine{00019 \textcolor{keyword}{const} \textcolor{keywordtype}{int} gNumFrameResources = 3;}
\DoxyCodeLine{00020 }
\DoxyCodeLine{00021 \textcolor{comment}{// Lightweight structure stores parameters to draw a shape.  This will}}
\DoxyCodeLine{00022 \textcolor{comment}{// vary from app-\/to-\/app.}}
\DoxyCodeLine{00023 \textcolor{keyword}{struct }RenderItem}
\DoxyCodeLine{00024 \{}
\DoxyCodeLine{00025     RenderItem() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{00026     RenderItem(\textcolor{keyword}{const} RenderItem\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00027 }
\DoxyCodeLine{00028     \textcolor{comment}{//step1: An invisible render-\/item will not be drawn.}}
\DoxyCodeLine{00029     \textcolor{keywordtype}{bool} Visible = \textcolor{keyword}{true};}
\DoxyCodeLine{00030 }
\DoxyCodeLine{00031     BoundingBox Bounds;}
\DoxyCodeLine{00032  }
\DoxyCodeLine{00033     \textcolor{comment}{// World matrix of the shape that describes the object's local space}}
\DoxyCodeLine{00034     \textcolor{comment}{// relative to the world space, which defines the position, orientation,}}
\DoxyCodeLine{00035     \textcolor{comment}{// and scale of the object in the world.}}
\DoxyCodeLine{00036     XMFLOAT4X4 World = MathHelper::Identity4x4();}
\DoxyCodeLine{00037 }
\DoxyCodeLine{00038     XMFLOAT4X4 TexTransform = MathHelper::Identity4x4();}
\DoxyCodeLine{00039 }
\DoxyCodeLine{00040     \textcolor{comment}{// Dirty flag indicating the object data has changed and we need to update the constant buffer.}}
\DoxyCodeLine{00041     \textcolor{comment}{// Because we have an object cbuffer for each FrameResource, we have to apply the}}
\DoxyCodeLine{00042     \textcolor{comment}{// update to each FrameResource.  Thus, when we modify obect data we should set }}
\DoxyCodeLine{00043     \textcolor{comment}{// NumFramesDirty = gNumFrameResources so that each frame resource gets the update.}}
\DoxyCodeLine{00044     \textcolor{keywordtype}{int} NumFramesDirty = gNumFrameResources;}
\DoxyCodeLine{00045 }
\DoxyCodeLine{00046     \textcolor{comment}{// Index into GPU constant buffer corresponding to the ObjectCB for this render item.}}
\DoxyCodeLine{00047     UINT ObjCBIndex = -\/1;}
\DoxyCodeLine{00048 }
\DoxyCodeLine{00049     Material* Mat = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00050     MeshGeometry* Geo = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00051 }
\DoxyCodeLine{00052     \textcolor{comment}{// Primitive topology.}}
\DoxyCodeLine{00053     D3D12\_PRIMITIVE\_TOPOLOGY PrimitiveType = D3D\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{00054 }
\DoxyCodeLine{00055     \textcolor{comment}{// DrawIndexedInstanced parameters.}}
\DoxyCodeLine{00056     UINT IndexCount = 0;}
\DoxyCodeLine{00057     UINT StartIndexLocation = 0;}
\DoxyCodeLine{00058     \textcolor{keywordtype}{int} BaseVertexLocation = 0;}
\DoxyCodeLine{00059 \};}
\DoxyCodeLine{00060 }
\DoxyCodeLine{00061 \textcolor{keyword}{enum class} RenderLayer : int}
\DoxyCodeLine{00062 \{}
\DoxyCodeLine{00063     Opaque = 0,}
\DoxyCodeLine{00064     Highlight,}
\DoxyCodeLine{00065     Count}
\DoxyCodeLine{00066 \};}
\DoxyCodeLine{00067 }
\DoxyCodeLine{00068 \textcolor{keyword}{class }PickingApp : \textcolor{keyword}{public} D3DApp}
\DoxyCodeLine{00069 \{}
\DoxyCodeLine{00070 \textcolor{keyword}{public}:}
\DoxyCodeLine{00071     PickingApp(HINSTANCE hInstance);}
\DoxyCodeLine{00072     PickingApp(\textcolor{keyword}{const} PickingApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00073     PickingApp\& operator=(\textcolor{keyword}{const} PickingApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00074     \string~PickingApp();}
\DoxyCodeLine{00075 }
\DoxyCodeLine{00076     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} Initialize()\textcolor{keyword}{override};}
\DoxyCodeLine{00077 }
\DoxyCodeLine{00078 \textcolor{keyword}{private}:}
\DoxyCodeLine{00079     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnResize()\textcolor{keyword}{override};}
\DoxyCodeLine{00080     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Update(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00081     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Draw(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00082 }
\DoxyCodeLine{00083     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00084     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00085     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00086 }
\DoxyCodeLine{00087     \textcolor{keywordtype}{void} OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00088     \textcolor{keywordtype}{void} AnimateMaterials(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00089     \textcolor{keywordtype}{void} UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00090     \textcolor{keywordtype}{void} UpdateMaterialBuffer(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00091     \textcolor{keywordtype}{void} UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00092 }
\DoxyCodeLine{00093     \textcolor{keywordtype}{void} LoadTextures();}
\DoxyCodeLine{00094     \textcolor{keywordtype}{void} BuildRootSignature();}
\DoxyCodeLine{00095     \textcolor{keywordtype}{void} BuildDescriptorHeaps();}
\DoxyCodeLine{00096     \textcolor{keywordtype}{void} BuildShadersAndInputLayout();}
\DoxyCodeLine{00097     \textcolor{keywordtype}{void} BuildCarGeometry();}
\DoxyCodeLine{00098     \textcolor{keywordtype}{void} BuildPSOs();}
\DoxyCodeLine{00099     \textcolor{keywordtype}{void} BuildFrameResources();}
\DoxyCodeLine{00100     \textcolor{keywordtype}{void} BuildMaterials();}
\DoxyCodeLine{00101     \textcolor{keywordtype}{void} BuildRenderItems();}
\DoxyCodeLine{00102     \textcolor{keywordtype}{void} DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems);}
\DoxyCodeLine{00103     \textcolor{keywordtype}{void} Pick(\textcolor{keywordtype}{int} sx, \textcolor{keywordtype}{int} sy);}
\DoxyCodeLine{00104 }
\DoxyCodeLine{00105     std::array<const CD3DX12\_STATIC\_SAMPLER\_DESC, 6> GetStaticSamplers();}
\DoxyCodeLine{00106 }
\DoxyCodeLine{00107 \textcolor{keyword}{private}:}
\DoxyCodeLine{00108 }
\DoxyCodeLine{00109     std::vector<std::unique\_ptr<FrameResource>> mFrameResources;}
\DoxyCodeLine{00110     FrameResource* mCurrFrameResource = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00111     \textcolor{keywordtype}{int} mCurrFrameResourceIndex = 0;}
\DoxyCodeLine{00112 }
\DoxyCodeLine{00113     UINT mCbvSrvDescriptorSize = 0;}
\DoxyCodeLine{00114 }
\DoxyCodeLine{00115     ComPtr<ID3D12RootSignature> mRootSignature = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00116 }
\DoxyCodeLine{00117     ComPtr<ID3D12DescriptorHeap> mSrvDescriptorHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00118 }
\DoxyCodeLine{00119     std::unordered\_map<std::string, std::unique\_ptr<MeshGeometry>> mGeometries;}
\DoxyCodeLine{00120     std::unordered\_map<std::string, std::unique\_ptr<Material>> mMaterials;}
\DoxyCodeLine{00121     std::unordered\_map<std::string, std::unique\_ptr<Texture>> mTextures;}
\DoxyCodeLine{00122     std::unordered\_map<std::string, ComPtr<ID3DBlob>> mShaders;}
\DoxyCodeLine{00123     std::unordered\_map<std::string, ComPtr<ID3D12PipelineState>> mPSOs;}
\DoxyCodeLine{00124 }
\DoxyCodeLine{00125     std::vector<D3D12\_INPUT\_ELEMENT\_DESC> mInputLayout;}
\DoxyCodeLine{00126  }
\DoxyCodeLine{00127     \textcolor{comment}{// List of all the render items.}}
\DoxyCodeLine{00128     std::vector<std::unique\_ptr<RenderItem>> mAllRitems;}
\DoxyCodeLine{00129 }
\DoxyCodeLine{00130     \textcolor{comment}{// Render items divided by PSO.}}
\DoxyCodeLine{00131     std::vector<RenderItem*> mRitemLayer[(int)RenderLayer::Count];}
\DoxyCodeLine{00132 }
\DoxyCodeLine{00133     \textcolor{comment}{//step2: To render the triangle with a highlight, we need a render-\/item for it.}}
\DoxyCodeLine{00134     RenderItem* mPickedRitem = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00135 }
\DoxyCodeLine{00136     PassConstants mMainPassCB;}
\DoxyCodeLine{00137 }
\DoxyCodeLine{00138     Camera mCamera;}
\DoxyCodeLine{00139 }
\DoxyCodeLine{00140     POINT mLastMousePos;}
\DoxyCodeLine{00141 \};}
\DoxyCodeLine{00142 }
\DoxyCodeLine{00143 \textcolor{keywordtype}{int} WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance,}
\DoxyCodeLine{00144     PSTR cmdLine, \textcolor{keywordtype}{int} showCmd)}
\DoxyCodeLine{00145 \{}
\DoxyCodeLine{00146     \textcolor{comment}{// Enable run-\/time memory check for debug builds.}}
\DoxyCodeLine{00147 \textcolor{preprocessor}{\#if defined(DEBUG) | defined(\_DEBUG)}}
\DoxyCodeLine{00148     \_CrtSetDbgFlag(\_CRTDBG\_ALLOC\_MEM\_DF | \_CRTDBG\_LEAK\_CHECK\_DF);}
\DoxyCodeLine{00149 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00150 }
\DoxyCodeLine{00151     \textcolor{keywordflow}{try}}
\DoxyCodeLine{00152     \{}
\DoxyCodeLine{00153         PickingApp theApp(hInstance);}
\DoxyCodeLine{00154         \textcolor{keywordflow}{if}(!theApp.Initialize())}
\DoxyCodeLine{00155             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00156 }
\DoxyCodeLine{00157         \textcolor{keywordflow}{return} theApp.Run();}
\DoxyCodeLine{00158     \}}
\DoxyCodeLine{00159     \textcolor{keywordflow}{catch}(DxException\& e)}
\DoxyCodeLine{00160     \{}
\DoxyCodeLine{00161         MessageBox(\textcolor{keyword}{nullptr}, e.ToString().c\_str(), L\textcolor{stringliteral}{"{}HR Failed"{}}, MB\_OK);}
\DoxyCodeLine{00162         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00163     \}}
\DoxyCodeLine{00164 \}}
\DoxyCodeLine{00165 }
\DoxyCodeLine{00166 PickingApp::PickingApp(HINSTANCE hInstance)}
\DoxyCodeLine{00167     : D3DApp(hInstance)}
\DoxyCodeLine{00168 \{}
\DoxyCodeLine{00169 \}}
\DoxyCodeLine{00170 }
\DoxyCodeLine{00171 PickingApp::\string~PickingApp()}
\DoxyCodeLine{00172 \{}
\DoxyCodeLine{00173     \textcolor{keywordflow}{if}(md3dDevice != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00174         FlushCommandQueue();}
\DoxyCodeLine{00175 \}}
\DoxyCodeLine{00176 }
\DoxyCodeLine{00177 \textcolor{keywordtype}{bool} PickingApp::Initialize()}
\DoxyCodeLine{00178 \{}
\DoxyCodeLine{00179     \textcolor{keywordflow}{if}(!D3DApp::Initialize())}
\DoxyCodeLine{00180         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00181 }
\DoxyCodeLine{00182     \textcolor{comment}{// Reset the command list to prep for initialization commands.}}
\DoxyCodeLine{00183     ThrowIfFailed(mCommandList-\/>Reset(mDirectCmdListAlloc.Get(), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{00184 }
\DoxyCodeLine{00185     \textcolor{comment}{// Get the increment size of a descriptor in this heap type.  This is hardware specific, }}
\DoxyCodeLine{00186     \textcolor{comment}{// so we have to query this information.}}
\DoxyCodeLine{00187     mCbvSrvDescriptorSize = md3dDevice-\/>GetDescriptorHandleIncrementSize(D3D12\_DESCRIPTOR\_HEAP\_TYPE\_CBV\_SRV\_UAV);}
\DoxyCodeLine{00188 }
\DoxyCodeLine{00189     \textcolor{comment}{//void Camera::LookAt(const XMFLOAT3\& pos, const XMFLOAT3\& target, const XMFLOAT3\& up)}}
\DoxyCodeLine{00190     mCamera.LookAt(}
\DoxyCodeLine{00191         XMFLOAT3(5.0f, 4.0f, -\/15.0f),}
\DoxyCodeLine{00192         XMFLOAT3(0.0f, 0.0f, 0.0f),}
\DoxyCodeLine{00193         XMFLOAT3(0.0f, 1.0f, 0.0f));}
\DoxyCodeLine{00194  }
\DoxyCodeLine{00195     LoadTextures();}
\DoxyCodeLine{00196     BuildRootSignature();}
\DoxyCodeLine{00197     BuildDescriptorHeaps();}
\DoxyCodeLine{00198     BuildShadersAndInputLayout();}
\DoxyCodeLine{00199     BuildCarGeometry();}
\DoxyCodeLine{00200     BuildMaterials();}
\DoxyCodeLine{00201     BuildRenderItems();}
\DoxyCodeLine{00202     BuildFrameResources();}
\DoxyCodeLine{00203     BuildPSOs();}
\DoxyCodeLine{00204 }
\DoxyCodeLine{00205     \textcolor{comment}{// Execute the initialization commands.}}
\DoxyCodeLine{00206     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00207     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00208     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00209 }
\DoxyCodeLine{00210     \textcolor{comment}{// Wait until initialization is complete.}}
\DoxyCodeLine{00211     FlushCommandQueue();}
\DoxyCodeLine{00212 }
\DoxyCodeLine{00213     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00214 \}}
\DoxyCodeLine{00215  }
\DoxyCodeLine{00216 \textcolor{keywordtype}{void} PickingApp::OnResize()}
\DoxyCodeLine{00217 \{}
\DoxyCodeLine{00218     D3DApp::OnResize();}
\DoxyCodeLine{00219 }
\DoxyCodeLine{00220     mCamera.SetLens(0.25f*MathHelper::Pi, AspectRatio(), 1.0f, 1000.0f);}
\DoxyCodeLine{00221 \}}
\DoxyCodeLine{00222 }
\DoxyCodeLine{00223 \textcolor{keywordtype}{void} PickingApp::Update(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00224 \{}
\DoxyCodeLine{00225     OnKeyboardInput(gt);}
\DoxyCodeLine{00226 }
\DoxyCodeLine{00227     \textcolor{comment}{// Cycle through the circular frame resource array.}}
\DoxyCodeLine{00228     mCurrFrameResourceIndex = (mCurrFrameResourceIndex + 1) \% gNumFrameResources;}
\DoxyCodeLine{00229     mCurrFrameResource = mFrameResources[mCurrFrameResourceIndex].get();}
\DoxyCodeLine{00230 }
\DoxyCodeLine{00231     \textcolor{comment}{// Has the GPU finished processing the commands of the current frame resource?}}
\DoxyCodeLine{00232     \textcolor{comment}{// If not, wait until the GPU has completed commands up to this fence point.}}
\DoxyCodeLine{00233     \textcolor{keywordflow}{if}(mCurrFrameResource-\/>Fence != 0 \&\& mFence-\/>GetCompletedValue() < mCurrFrameResource-\/>Fence)}
\DoxyCodeLine{00234     \{}
\DoxyCodeLine{00235         HANDLE eventHandle = CreateEventEx(\textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr}, \textcolor{keyword}{false}, EVENT\_ALL\_ACCESS);}
\DoxyCodeLine{00236         ThrowIfFailed(mFence-\/>SetEventOnCompletion(mCurrFrameResource-\/>Fence, eventHandle));}
\DoxyCodeLine{00237         WaitForSingleObject(eventHandle, INFINITE);}
\DoxyCodeLine{00238         CloseHandle(eventHandle);}
\DoxyCodeLine{00239     \}}
\DoxyCodeLine{00240 }
\DoxyCodeLine{00241     AnimateMaterials(gt);}
\DoxyCodeLine{00242     UpdateObjectCBs(gt);}
\DoxyCodeLine{00243     UpdateMaterialBuffer(gt);}
\DoxyCodeLine{00244     UpdateMainPassCB(gt);}
\DoxyCodeLine{00245 \}}
\DoxyCodeLine{00246 }
\DoxyCodeLine{00247 \textcolor{keywordtype}{void} PickingApp::Draw(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00248 \{}
\DoxyCodeLine{00249     \textcolor{keyword}{auto} cmdListAlloc = mCurrFrameResource-\/>CmdListAlloc;}
\DoxyCodeLine{00250 }
\DoxyCodeLine{00251     \textcolor{comment}{// Reuse the memory associated with command recording.}}
\DoxyCodeLine{00252     \textcolor{comment}{// We can only reset when the associated command lists have finished execution on the GPU.}}
\DoxyCodeLine{00253     ThrowIfFailed(cmdListAlloc-\/>Reset());}
\DoxyCodeLine{00254 }
\DoxyCodeLine{00255     \textcolor{comment}{// A command list can be reset after it has been added to the command queue via ExecuteCommandList.}}
\DoxyCodeLine{00256     \textcolor{comment}{// Reusing the command list reuses memory.}}
\DoxyCodeLine{00257     ThrowIfFailed(mCommandList-\/>Reset(cmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}opaque"{}}].Get()));}
\DoxyCodeLine{00258 }
\DoxyCodeLine{00259     mCommandList-\/>RSSetViewports(1, \&mScreenViewport);}
\DoxyCodeLine{00260     mCommandList-\/>RSSetScissorRects(1, \&mScissorRect);}
\DoxyCodeLine{00261 }
\DoxyCodeLine{00262     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00263     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00264         D3D12\_RESOURCE\_STATE\_PRESENT, D3D12\_RESOURCE\_STATE\_RENDER\_TARGET));}
\DoxyCodeLine{00265 }
\DoxyCodeLine{00266     \textcolor{comment}{// Clear the back buffer and depth buffer.}}
\DoxyCodeLine{00267     mCommandList-\/>ClearRenderTargetView(CurrentBackBufferView(), Colors::LightSteelBlue, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00268     mCommandList-\/>ClearDepthStencilView(DepthStencilView(), D3D12\_CLEAR\_FLAG\_DEPTH | D3D12\_CLEAR\_FLAG\_STENCIL, 1.0f, 0, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00269 }
\DoxyCodeLine{00270     \textcolor{comment}{// Specify the buffers we are going to render to.}}
\DoxyCodeLine{00271     mCommandList-\/>OMSetRenderTargets(1, \&CurrentBackBufferView(), \textcolor{keyword}{true}, \&DepthStencilView());}
\DoxyCodeLine{00272 }
\DoxyCodeLine{00273     ID3D12DescriptorHeap* descriptorHeaps[] = \{ mSrvDescriptorHeap.Get() \};}
\DoxyCodeLine{00274     mCommandList-\/>SetDescriptorHeaps(\_countof(descriptorHeaps), descriptorHeaps);}
\DoxyCodeLine{00275 }
\DoxyCodeLine{00276     mCommandList-\/>SetGraphicsRootSignature(mRootSignature.Get());}
\DoxyCodeLine{00277 }
\DoxyCodeLine{00278     \textcolor{keyword}{auto} passCB = mCurrFrameResource-\/>PassCB-\/>Resource();}
\DoxyCodeLine{00279     mCommandList-\/>SetGraphicsRootConstantBufferView(1, passCB-\/>GetGPUVirtualAddress());}
\DoxyCodeLine{00280 }
\DoxyCodeLine{00281     \textcolor{comment}{// Bind all the materials used in this scene.  For structured buffers, we can bypass the heap and }}
\DoxyCodeLine{00282     \textcolor{comment}{// set as a root descriptor.}}
\DoxyCodeLine{00283     \textcolor{keyword}{auto} matBuffer = mCurrFrameResource-\/>MaterialBuffer-\/>Resource();}
\DoxyCodeLine{00284     mCommandList-\/>SetGraphicsRootShaderResourceView(2, matBuffer-\/>GetGPUVirtualAddress());}
\DoxyCodeLine{00285 }
\DoxyCodeLine{00286     \textcolor{comment}{// Bind all the textures used in this scene.  Observe}}
\DoxyCodeLine{00287     \textcolor{comment}{// that we only have to specify the first descriptor in the table.  }}
\DoxyCodeLine{00288     \textcolor{comment}{// The root signature knows how many descriptors are expected in the table.}}
\DoxyCodeLine{00289     mCommandList-\/>SetGraphicsRootDescriptorTable(3, mSrvDescriptorHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00290 }
\DoxyCodeLine{00291     DrawRenderItems(mCommandList.Get(), mRitemLayer[(\textcolor{keywordtype}{int})RenderLayer::Opaque]);}
\DoxyCodeLine{00292 }
\DoxyCodeLine{00293     \textcolor{comment}{//step7}}
\DoxyCodeLine{00294     mCommandList-\/>SetPipelineState(mPSOs[\textcolor{stringliteral}{"{}highlight"{}}].Get());}
\DoxyCodeLine{00295     DrawRenderItems(mCommandList.Get(), mRitemLayer[(\textcolor{keywordtype}{int})RenderLayer::Highlight]);}
\DoxyCodeLine{00296 }
\DoxyCodeLine{00297     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00298     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00299         D3D12\_RESOURCE\_STATE\_RENDER\_TARGET, D3D12\_RESOURCE\_STATE\_PRESENT));}
\DoxyCodeLine{00300 }
\DoxyCodeLine{00301     \textcolor{comment}{// Done recording commands.}}
\DoxyCodeLine{00302     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00303 }
\DoxyCodeLine{00304     \textcolor{comment}{// Add the command list to the queue for execution.}}
\DoxyCodeLine{00305     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00306     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00307 }
\DoxyCodeLine{00308     \textcolor{comment}{// Swap the back and front buffers}}
\DoxyCodeLine{00309     ThrowIfFailed(mSwapChain-\/>Present(0, 0));}
\DoxyCodeLine{00310     mCurrBackBuffer = (mCurrBackBuffer + 1) \% SwapChainBufferCount;}
\DoxyCodeLine{00311 }
\DoxyCodeLine{00312     \textcolor{comment}{// Advance the fence value to mark commands up to this fence point.}}
\DoxyCodeLine{00313     mCurrFrameResource-\/>Fence = ++mCurrentFence;}
\DoxyCodeLine{00314 }
\DoxyCodeLine{00315     \textcolor{comment}{// Add an instruction to the command queue to set a new fence point. }}
\DoxyCodeLine{00316     \textcolor{comment}{// Because we are on the GPU timeline, the new fence point won't be }}
\DoxyCodeLine{00317     \textcolor{comment}{// set until the GPU finishes processing all the commands prior to this Signal().}}
\DoxyCodeLine{00318     mCommandQueue-\/>Signal(mFence.Get(), mCurrentFence);}
\DoxyCodeLine{00319 \}}
\DoxyCodeLine{00320 }
\DoxyCodeLine{00321 \textcolor{comment}{//step 5}}
\DoxyCodeLine{00322 \textcolor{keywordtype}{void} PickingApp::OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00323 \{}
\DoxyCodeLine{00324     \textcolor{keywordflow}{if}((btnState \& MK\_LBUTTON) != 0)}
\DoxyCodeLine{00325     \{}
\DoxyCodeLine{00326         mLastMousePos.x = x;}
\DoxyCodeLine{00327         mLastMousePos.y = y;}
\DoxyCodeLine{00328 }
\DoxyCodeLine{00329         SetCapture(mhMainWnd);}
\DoxyCodeLine{00330     \}}
\DoxyCodeLine{00331     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}((btnState \& MK\_RBUTTON) != 0)}
\DoxyCodeLine{00332     \{}
\DoxyCodeLine{00333         \textcolor{comment}{//step4}}
\DoxyCodeLine{00334         Pick(x, y);}
\DoxyCodeLine{00335     \}}
\DoxyCodeLine{00336 \}}
\DoxyCodeLine{00337 }
\DoxyCodeLine{00338 \textcolor{keywordtype}{void} PickingApp::OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00339 \{}
\DoxyCodeLine{00340     ReleaseCapture();}
\DoxyCodeLine{00341 \}}
\DoxyCodeLine{00342 }
\DoxyCodeLine{00343 \textcolor{keywordtype}{void} PickingApp::OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00344 \{}
\DoxyCodeLine{00345     \textcolor{keywordflow}{if}((btnState \& MK\_LBUTTON) != 0)}
\DoxyCodeLine{00346     \{}
\DoxyCodeLine{00347         \textcolor{comment}{// Make each pixel correspond to a quarter of a degree.}}
\DoxyCodeLine{00348         \textcolor{keywordtype}{float} dx = XMConvertToRadians(0.25f*\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x -\/ mLastMousePos.x));}
\DoxyCodeLine{00349         \textcolor{keywordtype}{float} dy = XMConvertToRadians(0.25f*\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(y -\/ mLastMousePos.y));}
\DoxyCodeLine{00350 }
\DoxyCodeLine{00351         mCamera.Pitch(dy);}
\DoxyCodeLine{00352         mCamera.RotateY(dx);}
\DoxyCodeLine{00353     \}}
\DoxyCodeLine{00354 }
\DoxyCodeLine{00355     mLastMousePos.x = x;}
\DoxyCodeLine{00356     mLastMousePos.y = y;}
\DoxyCodeLine{00357 \}}
\DoxyCodeLine{00358  }
\DoxyCodeLine{00359 \textcolor{keywordtype}{void} PickingApp::OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00360 \{}
\DoxyCodeLine{00361     \textcolor{keyword}{const} \textcolor{keywordtype}{float} dt = gt.DeltaTime();}
\DoxyCodeLine{00362 }
\DoxyCodeLine{00363     \textcolor{keywordflow}{if}(GetAsyncKeyState(\textcolor{charliteral}{'W'}) \& 0x8000)}
\DoxyCodeLine{00364         mCamera.Walk(10.0f*dt);}
\DoxyCodeLine{00365 }
\DoxyCodeLine{00366     \textcolor{keywordflow}{if}(GetAsyncKeyState(\textcolor{charliteral}{'S'}) \& 0x8000)}
\DoxyCodeLine{00367         mCamera.Walk(-\/10.0f*dt);}
\DoxyCodeLine{00368 }
\DoxyCodeLine{00369     \textcolor{keywordflow}{if}(GetAsyncKeyState(\textcolor{charliteral}{'A'}) \& 0x8000)}
\DoxyCodeLine{00370         mCamera.Strafe(-\/10.0f*dt);}
\DoxyCodeLine{00371 }
\DoxyCodeLine{00372     \textcolor{keywordflow}{if}(GetAsyncKeyState(\textcolor{charliteral}{'D'}) \& 0x8000)}
\DoxyCodeLine{00373         mCamera.Strafe(10.0f*dt);}
\DoxyCodeLine{00374 }
\DoxyCodeLine{00375     mCamera.UpdateViewMatrix();}
\DoxyCodeLine{00376 \}}
\DoxyCodeLine{00377  }
\DoxyCodeLine{00378 \textcolor{keywordtype}{void} PickingApp::AnimateMaterials(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00379 \{}
\DoxyCodeLine{00380     }
\DoxyCodeLine{00381 \}}
\DoxyCodeLine{00382 }
\DoxyCodeLine{00383 \textcolor{keywordtype}{void} PickingApp::UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00384 \{}
\DoxyCodeLine{00385     \textcolor{keyword}{auto} currObjectCB = mCurrFrameResource-\/>ObjectCB.get();}
\DoxyCodeLine{00386     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& e : mAllRitems)}
\DoxyCodeLine{00387     \{}
\DoxyCodeLine{00388         \textcolor{comment}{// Only update the cbuffer data if the constants have changed.  }}
\DoxyCodeLine{00389         \textcolor{comment}{// This needs to be tracked per frame resource.}}
\DoxyCodeLine{00390         \textcolor{keywordflow}{if}(e-\/>NumFramesDirty > 0)}
\DoxyCodeLine{00391         \{}
\DoxyCodeLine{00392             XMMATRIX world = XMLoadFloat4x4(\&e-\/>World);}
\DoxyCodeLine{00393             XMMATRIX texTransform = XMLoadFloat4x4(\&e-\/>TexTransform);}
\DoxyCodeLine{00394 }
\DoxyCodeLine{00395             ObjectConstants objConstants;}
\DoxyCodeLine{00396             XMStoreFloat4x4(\&objConstants.World, XMMatrixTranspose(world));}
\DoxyCodeLine{00397             XMStoreFloat4x4(\&objConstants.TexTransform, XMMatrixTranspose(texTransform));}
\DoxyCodeLine{00398             objConstants.MaterialIndex = e-\/>Mat-\/>MatCBIndex;}
\DoxyCodeLine{00399 }
\DoxyCodeLine{00400             currObjectCB-\/>CopyData(e-\/>ObjCBIndex, objConstants);}
\DoxyCodeLine{00401 }
\DoxyCodeLine{00402             \textcolor{comment}{// Next FrameResource need to be updated too.}}
\DoxyCodeLine{00403             e-\/>NumFramesDirty-\/-\/;}
\DoxyCodeLine{00404         \}}
\DoxyCodeLine{00405     \}}
\DoxyCodeLine{00406 \}}
\DoxyCodeLine{00407 }
\DoxyCodeLine{00408 \textcolor{keywordtype}{void} PickingApp::UpdateMaterialBuffer(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00409 \{}
\DoxyCodeLine{00410     \textcolor{keyword}{auto} currMaterialBuffer = mCurrFrameResource-\/>MaterialBuffer.get();}
\DoxyCodeLine{00411     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& e : mMaterials)}
\DoxyCodeLine{00412     \{}
\DoxyCodeLine{00413         \textcolor{comment}{// Only update the cbuffer data if the constants have changed.  If the cbuffer}}
\DoxyCodeLine{00414         \textcolor{comment}{// data changes, it needs to be updated for each FrameResource.}}
\DoxyCodeLine{00415         Material* mat = e.second.get();}
\DoxyCodeLine{00416         \textcolor{keywordflow}{if}(mat-\/>NumFramesDirty > 0)}
\DoxyCodeLine{00417         \{}
\DoxyCodeLine{00418             XMMATRIX matTransform = XMLoadFloat4x4(\&mat-\/>MatTransform);}
\DoxyCodeLine{00419 }
\DoxyCodeLine{00420             MaterialData matData;}
\DoxyCodeLine{00421             matData.DiffuseAlbedo = mat-\/>DiffuseAlbedo;}
\DoxyCodeLine{00422             matData.FresnelR0 = mat-\/>FresnelR0;}
\DoxyCodeLine{00423             matData.Roughness = mat-\/>Roughness;}
\DoxyCodeLine{00424             XMStoreFloat4x4(\&matData.MatTransform, XMMatrixTranspose(matTransform));}
\DoxyCodeLine{00425             matData.DiffuseMapIndex = mat-\/>DiffuseSrvHeapIndex;}
\DoxyCodeLine{00426 }
\DoxyCodeLine{00427             currMaterialBuffer-\/>CopyData(mat-\/>MatCBIndex, matData);}
\DoxyCodeLine{00428 }
\DoxyCodeLine{00429             \textcolor{comment}{// Next FrameResource need to be updated too.}}
\DoxyCodeLine{00430             mat-\/>NumFramesDirty-\/-\/;}
\DoxyCodeLine{00431         \}}
\DoxyCodeLine{00432     \}}
\DoxyCodeLine{00433 \}}
\DoxyCodeLine{00434 }
\DoxyCodeLine{00435 \textcolor{keywordtype}{void} PickingApp::UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00436 \{}
\DoxyCodeLine{00437     XMMATRIX view = mCamera.GetView();}
\DoxyCodeLine{00438     XMMATRIX proj = mCamera.GetProj();}
\DoxyCodeLine{00439 }
\DoxyCodeLine{00440     XMMATRIX viewProj = XMMatrixMultiply(view, proj);}
\DoxyCodeLine{00441     XMMATRIX invView = XMMatrixInverse(\&XMMatrixDeterminant(view), view);}
\DoxyCodeLine{00442     XMMATRIX invProj = XMMatrixInverse(\&XMMatrixDeterminant(proj), proj);}
\DoxyCodeLine{00443     XMMATRIX invViewProj = XMMatrixInverse(\&XMMatrixDeterminant(viewProj), viewProj);}
\DoxyCodeLine{00444 }
\DoxyCodeLine{00445     XMStoreFloat4x4(\&mMainPassCB.View, XMMatrixTranspose(view));}
\DoxyCodeLine{00446     XMStoreFloat4x4(\&mMainPassCB.InvView, XMMatrixTranspose(invView));}
\DoxyCodeLine{00447     XMStoreFloat4x4(\&mMainPassCB.Proj, XMMatrixTranspose(proj));}
\DoxyCodeLine{00448     XMStoreFloat4x4(\&mMainPassCB.InvProj, XMMatrixTranspose(invProj));}
\DoxyCodeLine{00449     XMStoreFloat4x4(\&mMainPassCB.ViewProj, XMMatrixTranspose(viewProj));}
\DoxyCodeLine{00450     XMStoreFloat4x4(\&mMainPassCB.InvViewProj, XMMatrixTranspose(invViewProj));}
\DoxyCodeLine{00451     mMainPassCB.EyePosW = mCamera.GetPosition3f();}
\DoxyCodeLine{00452     mMainPassCB.RenderTargetSize = XMFLOAT2((\textcolor{keywordtype}{float})mClientWidth, (\textcolor{keywordtype}{float})mClientHeight);}
\DoxyCodeLine{00453     mMainPassCB.InvRenderTargetSize = XMFLOAT2(1.0f / mClientWidth, 1.0f / mClientHeight);}
\DoxyCodeLine{00454     mMainPassCB.NearZ = 1.0f;}
\DoxyCodeLine{00455     mMainPassCB.FarZ = 1000.0f;}
\DoxyCodeLine{00456     mMainPassCB.TotalTime = gt.TotalTime();}
\DoxyCodeLine{00457     mMainPassCB.DeltaTime = gt.DeltaTime();}
\DoxyCodeLine{00458     mMainPassCB.AmbientLight = \{ 0.25f, 0.25f, 0.35f, 1.0f \};}
\DoxyCodeLine{00459     mMainPassCB.Lights[0].Direction = \{ 0.57735f, -\/0.57735f, 0.57735f \};}
\DoxyCodeLine{00460     mMainPassCB.Lights[0].Strength = \{ 0.8f, 0.8f, 0.8f \};}
\DoxyCodeLine{00461     mMainPassCB.Lights[1].Direction = \{ -\/0.57735f, -\/0.57735f, 0.57735f \};}
\DoxyCodeLine{00462     mMainPassCB.Lights[1].Strength = \{ 0.4f, 0.4f, 0.4f \};}
\DoxyCodeLine{00463     mMainPassCB.Lights[2].Direction = \{ 0.0f, -\/0.707f, -\/0.707f \};}
\DoxyCodeLine{00464     mMainPassCB.Lights[2].Strength = \{ 0.2f, 0.2f, 0.2f \};}
\DoxyCodeLine{00465 }
\DoxyCodeLine{00466     \textcolor{keyword}{auto} currPassCB = mCurrFrameResource-\/>PassCB.get();}
\DoxyCodeLine{00467     currPassCB-\/>CopyData(0, mMainPassCB);}
\DoxyCodeLine{00468 \}}
\DoxyCodeLine{00469 }
\DoxyCodeLine{00470 \textcolor{keywordtype}{void} PickingApp::LoadTextures()}
\DoxyCodeLine{00471 \{}
\DoxyCodeLine{00472     \textcolor{keyword}{auto} defaultDiffuseTex = std::make\_unique<Texture>();}
\DoxyCodeLine{00473     defaultDiffuseTex-\/>Name = \textcolor{stringliteral}{"{}defaultDiffuseTex"{}};}
\DoxyCodeLine{00474     defaultDiffuseTex-\/>Filename = L\textcolor{stringliteral}{"{}../../Textures/white1x1.dds"{}};}
\DoxyCodeLine{00475     ThrowIfFailed(DirectX::CreateDDSTextureFromFile12(md3dDevice.Get(),}
\DoxyCodeLine{00476         mCommandList.Get(), defaultDiffuseTex-\/>Filename.c\_str(),}
\DoxyCodeLine{00477         defaultDiffuseTex-\/>Resource, defaultDiffuseTex-\/>UploadHeap));}
\DoxyCodeLine{00478     }
\DoxyCodeLine{00479     mTextures[defaultDiffuseTex-\/>Name] = std::move(defaultDiffuseTex);}
\DoxyCodeLine{00480 \}}
\DoxyCodeLine{00481 }
\DoxyCodeLine{00482 \textcolor{keywordtype}{void} PickingApp::BuildRootSignature()}
\DoxyCodeLine{00483 \{}
\DoxyCodeLine{00484     CD3DX12\_DESCRIPTOR\_RANGE texTable;}
\DoxyCodeLine{00485     texTable.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_SRV, 4, 0, 0);}
\DoxyCodeLine{00486 }
\DoxyCodeLine{00487     \textcolor{comment}{// Root parameter can be a table, root descriptor or root constants.}}
\DoxyCodeLine{00488     CD3DX12\_ROOT\_PARAMETER slotRootParameter[4];}
\DoxyCodeLine{00489 }
\DoxyCodeLine{00490     \textcolor{comment}{// Perfomance TIP: Order from most frequent to least frequent.}}
\DoxyCodeLine{00491     slotRootParameter[0].InitAsConstantBufferView(0);}
\DoxyCodeLine{00492     slotRootParameter[1].InitAsConstantBufferView(1);}
\DoxyCodeLine{00493     slotRootParameter[2].InitAsShaderResourceView(0, 1);}
\DoxyCodeLine{00494     slotRootParameter[3].InitAsDescriptorTable(1, \&texTable, D3D12\_SHADER\_VISIBILITY\_PIXEL);}
\DoxyCodeLine{00495 }
\DoxyCodeLine{00496 }
\DoxyCodeLine{00497     \textcolor{keyword}{auto} staticSamplers = GetStaticSamplers();}
\DoxyCodeLine{00498 }
\DoxyCodeLine{00499     \textcolor{comment}{// A root signature is an array of root parameters.}}
\DoxyCodeLine{00500     CD3DX12\_ROOT\_SIGNATURE\_DESC rootSigDesc(4, slotRootParameter,}
\DoxyCodeLine{00501         (UINT)staticSamplers.size(), staticSamplers.data(),}
\DoxyCodeLine{00502         D3D12\_ROOT\_SIGNATURE\_FLAG\_ALLOW\_INPUT\_ASSEMBLER\_INPUT\_LAYOUT);}
\DoxyCodeLine{00503 }
\DoxyCodeLine{00504     \textcolor{comment}{// create a root signature with a single slot which points to a descriptor range consisting of a single constant buffer}}
\DoxyCodeLine{00505     ComPtr<ID3DBlob> serializedRootSig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00506     ComPtr<ID3DBlob> errorBlob = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00507     HRESULT hr = D3D12SerializeRootSignature(\&rootSigDesc, D3D\_ROOT\_SIGNATURE\_VERSION\_1,}
\DoxyCodeLine{00508         serializedRootSig.GetAddressOf(), errorBlob.GetAddressOf());}
\DoxyCodeLine{00509 }
\DoxyCodeLine{00510     \textcolor{keywordflow}{if}(errorBlob != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00511     \{}
\DoxyCodeLine{00512         ::OutputDebugStringA((\textcolor{keywordtype}{char}*)errorBlob-\/>GetBufferPointer());}
\DoxyCodeLine{00513     \}}
\DoxyCodeLine{00514     ThrowIfFailed(hr);}
\DoxyCodeLine{00515 }
\DoxyCodeLine{00516     ThrowIfFailed(md3dDevice-\/>CreateRootSignature(}
\DoxyCodeLine{00517         0,}
\DoxyCodeLine{00518         serializedRootSig-\/>GetBufferPointer(),}
\DoxyCodeLine{00519         serializedRootSig-\/>GetBufferSize(),}
\DoxyCodeLine{00520         IID\_PPV\_ARGS(mRootSignature.GetAddressOf())));}
\DoxyCodeLine{00521 \}}
\DoxyCodeLine{00522 }
\DoxyCodeLine{00523 \textcolor{keywordtype}{void} PickingApp::BuildDescriptorHeaps()}
\DoxyCodeLine{00524 \{}
\DoxyCodeLine{00525     \textcolor{comment}{//}}
\DoxyCodeLine{00526     \textcolor{comment}{// Create the SRV heap.}}
\DoxyCodeLine{00527     \textcolor{comment}{//}}
\DoxyCodeLine{00528     D3D12\_DESCRIPTOR\_HEAP\_DESC srvHeapDesc = \{\};}
\DoxyCodeLine{00529     srvHeapDesc.NumDescriptors = 1;}
\DoxyCodeLine{00530     srvHeapDesc.Type = D3D12\_DESCRIPTOR\_HEAP\_TYPE\_CBV\_SRV\_UAV;}
\DoxyCodeLine{00531     srvHeapDesc.Flags = D3D12\_DESCRIPTOR\_HEAP\_FLAG\_SHADER\_VISIBLE;}
\DoxyCodeLine{00532     ThrowIfFailed(md3dDevice-\/>CreateDescriptorHeap(\&srvHeapDesc, IID\_PPV\_ARGS(\&mSrvDescriptorHeap)));}
\DoxyCodeLine{00533 }
\DoxyCodeLine{00534     \textcolor{comment}{//}}
\DoxyCodeLine{00535     \textcolor{comment}{// Fill out the heap with actual descriptors.}}
\DoxyCodeLine{00536     \textcolor{comment}{//}}
\DoxyCodeLine{00537     CD3DX12\_CPU\_DESCRIPTOR\_HANDLE hDescriptor(mSrvDescriptorHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00538 }
\DoxyCodeLine{00539     \textcolor{keyword}{auto} defaultDiffuseTex = mTextures[\textcolor{stringliteral}{"{}defaultDiffuseTex"{}}]-\/>Resource;}
\DoxyCodeLine{00540 }
\DoxyCodeLine{00541     D3D12\_SHADER\_RESOURCE\_VIEW\_DESC srvDesc = \{\};}
\DoxyCodeLine{00542     srvDesc.Shader4ComponentMapping = D3D12\_DEFAULT\_SHADER\_4\_COMPONENT\_MAPPING;}
\DoxyCodeLine{00543     srvDesc.Format = defaultDiffuseTex-\/>GetDesc().Format;}
\DoxyCodeLine{00544     srvDesc.ViewDimension = D3D12\_SRV\_DIMENSION\_TEXTURE2D;}
\DoxyCodeLine{00545     srvDesc.Texture2D.MostDetailedMip = 0;}
\DoxyCodeLine{00546     srvDesc.Texture2D.MipLevels = defaultDiffuseTex-\/>GetDesc().MipLevels;}
\DoxyCodeLine{00547     srvDesc.Texture2D.ResourceMinLODClamp = 0.0f;}
\DoxyCodeLine{00548     md3dDevice-\/>CreateShaderResourceView(defaultDiffuseTex.Get(), \&srvDesc, hDescriptor);}
\DoxyCodeLine{00549 \}}
\DoxyCodeLine{00550 }
\DoxyCodeLine{00551 \textcolor{keywordtype}{void} PickingApp::BuildShadersAndInputLayout()}
\DoxyCodeLine{00552 \{}
\DoxyCodeLine{00553     \textcolor{keyword}{const} D3D\_SHADER\_MACRO alphaTestDefines[] =}
\DoxyCodeLine{00554     \{}
\DoxyCodeLine{00555         \textcolor{stringliteral}{"{}ALPHA\_TEST"{}}, \textcolor{stringliteral}{"{}1"{}},}
\DoxyCodeLine{00556         NULL, NULL}
\DoxyCodeLine{00557     \};}
\DoxyCodeLine{00558 }
\DoxyCodeLine{00559     mShaders[\textcolor{stringliteral}{"{}standardVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Default.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{00560     mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Default.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{00561     }
\DoxyCodeLine{00562     mInputLayout =}
\DoxyCodeLine{00563     \{}
\DoxyCodeLine{00564         \{ \textcolor{stringliteral}{"{}POSITION"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 0, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00565         \{ \textcolor{stringliteral}{"{}NORMAL"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 12, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00566         \{ \textcolor{stringliteral}{"{}TEXCOORD"{}}, 0, DXGI\_FORMAT\_R32G32\_FLOAT, 0, 24, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00567     \};}
\DoxyCodeLine{00568 \}}
\DoxyCodeLine{00569 }
\DoxyCodeLine{00570 \textcolor{keywordtype}{void} PickingApp::BuildCarGeometry()}
\DoxyCodeLine{00571 \{}
\DoxyCodeLine{00572     std::ifstream fin(\textcolor{stringliteral}{"{}Models/car.txt"{}});}
\DoxyCodeLine{00573 }
\DoxyCodeLine{00574     \textcolor{keywordflow}{if}(!fin)}
\DoxyCodeLine{00575     \{}
\DoxyCodeLine{00576         MessageBox(0, L\textcolor{stringliteral}{"{}Models/car.txt not found."{}}, 0, 0);}
\DoxyCodeLine{00577         \textcolor{keywordflow}{return};}
\DoxyCodeLine{00578     \}}
\DoxyCodeLine{00579 }
\DoxyCodeLine{00580     UINT vcount = 0;}
\DoxyCodeLine{00581     UINT tcount = 0;}
\DoxyCodeLine{00582     std::string ignore;}
\DoxyCodeLine{00583 }
\DoxyCodeLine{00584     fin >> ignore >> vcount;}
\DoxyCodeLine{00585     fin >> ignore >> tcount;}
\DoxyCodeLine{00586     fin >> ignore >> ignore >> ignore >> ignore;}
\DoxyCodeLine{00587 }
\DoxyCodeLine{00588     XMFLOAT3 vMinf3(+MathHelper::Infinity, +MathHelper::Infinity, +MathHelper::Infinity);}
\DoxyCodeLine{00589     XMFLOAT3 vMaxf3(-\/MathHelper::Infinity, -\/MathHelper::Infinity, -\/MathHelper::Infinity);}
\DoxyCodeLine{00590 }
\DoxyCodeLine{00591     XMVECTOR vMin = XMLoadFloat3(\&vMinf3);}
\DoxyCodeLine{00592     XMVECTOR vMax = XMLoadFloat3(\&vMaxf3);}
\DoxyCodeLine{00593 }
\DoxyCodeLine{00594     std::vector<Vertex> vertices(vcount);}
\DoxyCodeLine{00595     \textcolor{keywordflow}{for}(UINT i = 0; i < vcount; ++i)}
\DoxyCodeLine{00596     \{}
\DoxyCodeLine{00597         fin >> vertices[i].Pos.x >> vertices[i].Pos.y >> vertices[i].Pos.z;}
\DoxyCodeLine{00598         fin >> vertices[i].Normal.x >> vertices[i].Normal.y >> vertices[i].Normal.z;}
\DoxyCodeLine{00599 }
\DoxyCodeLine{00600         XMVECTOR P = XMLoadFloat3(\&vertices[i].Pos);}
\DoxyCodeLine{00601 }
\DoxyCodeLine{00602         vertices[i].TexC = \{ 0.0f, 0.0f \};}
\DoxyCodeLine{00603 }
\DoxyCodeLine{00604         vMin = XMVectorMin(vMin, P);}
\DoxyCodeLine{00605         vMax = XMVectorMax(vMax, P);}
\DoxyCodeLine{00606     \}}
\DoxyCodeLine{00607 }
\DoxyCodeLine{00608     BoundingBox bounds;}
\DoxyCodeLine{00609     XMStoreFloat3(\&bounds.Center, 0.5f*(vMin + vMax));}
\DoxyCodeLine{00610     XMStoreFloat3(\&bounds.Extents, 0.5f*(vMax -\/ vMin));}
\DoxyCodeLine{00611 }
\DoxyCodeLine{00612     fin >> ignore;}
\DoxyCodeLine{00613     fin >> ignore;}
\DoxyCodeLine{00614     fin >> ignore;}
\DoxyCodeLine{00615 }
\DoxyCodeLine{00616     std::vector<std::int32\_t> indices(3 * tcount);}
\DoxyCodeLine{00617     \textcolor{keywordflow}{for}(UINT i = 0; i < tcount; ++i)}
\DoxyCodeLine{00618     \{}
\DoxyCodeLine{00619         fin >> indices[i * 3 + 0] >> indices[i * 3 + 1] >> indices[i * 3 + 2];}
\DoxyCodeLine{00620     \}}
\DoxyCodeLine{00621 }
\DoxyCodeLine{00622     fin.close();}
\DoxyCodeLine{00623 }
\DoxyCodeLine{00624     \textcolor{comment}{//}}
\DoxyCodeLine{00625     \textcolor{comment}{// Pack the indices of all the meshes into one index buffer.}}
\DoxyCodeLine{00626     \textcolor{comment}{//}}
\DoxyCodeLine{00627 }
\DoxyCodeLine{00628     \textcolor{keyword}{const} UINT vbByteSize = (UINT)vertices.size() * \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{00629 }
\DoxyCodeLine{00630     \textcolor{keyword}{const} UINT ibByteSize = (UINT)indices.size() * \textcolor{keyword}{sizeof}(std::int32\_t);}
\DoxyCodeLine{00631 }
\DoxyCodeLine{00632     \textcolor{keyword}{auto} geo = std::make\_unique<MeshGeometry>();}
\DoxyCodeLine{00633     geo-\/>Name = \textcolor{stringliteral}{"{}carGeo"{}};}
\DoxyCodeLine{00634 }
\DoxyCodeLine{00635     ThrowIfFailed(D3DCreateBlob(vbByteSize, \&geo-\/>VertexBufferCPU));}
\DoxyCodeLine{00636     CopyMemory(geo-\/>VertexBufferCPU-\/>GetBufferPointer(), vertices.data(), vbByteSize);}
\DoxyCodeLine{00637 }
\DoxyCodeLine{00638     ThrowIfFailed(D3DCreateBlob(ibByteSize, \&geo-\/>IndexBufferCPU));}
\DoxyCodeLine{00639     CopyMemory(geo-\/>IndexBufferCPU-\/>GetBufferPointer(), indices.data(), ibByteSize);}
\DoxyCodeLine{00640 }
\DoxyCodeLine{00641     geo-\/>VertexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{00642         mCommandList.Get(), vertices.data(), vbByteSize, geo-\/>VertexBufferUploader);}
\DoxyCodeLine{00643 }
\DoxyCodeLine{00644     geo-\/>IndexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{00645         mCommandList.Get(), indices.data(), ibByteSize, geo-\/>IndexBufferUploader);}
\DoxyCodeLine{00646 }
\DoxyCodeLine{00647     geo-\/>VertexByteStride = \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{00648     geo-\/>VertexBufferByteSize = vbByteSize;}
\DoxyCodeLine{00649     geo-\/>IndexFormat = DXGI\_FORMAT\_R32\_UINT;}
\DoxyCodeLine{00650     geo-\/>IndexBufferByteSize = ibByteSize;}
\DoxyCodeLine{00651 }
\DoxyCodeLine{00652     SubmeshGeometry submesh;}
\DoxyCodeLine{00653     submesh.IndexCount = (UINT)indices.size();}
\DoxyCodeLine{00654     submesh.StartIndexLocation = 0;}
\DoxyCodeLine{00655     submesh.BaseVertexLocation = 0;}
\DoxyCodeLine{00656     submesh.Bounds = bounds;}
\DoxyCodeLine{00657 }
\DoxyCodeLine{00658     geo-\/>DrawArgs[\textcolor{stringliteral}{"{}car"{}}] = submesh;}
\DoxyCodeLine{00659 }
\DoxyCodeLine{00660     mGeometries[geo-\/>Name] = std::move(geo);}
\DoxyCodeLine{00661 \}}
\DoxyCodeLine{00662 }
\DoxyCodeLine{00663 \textcolor{keywordtype}{void} PickingApp::BuildPSOs()}
\DoxyCodeLine{00664 \{}
\DoxyCodeLine{00665     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC opaquePsoDesc;}
\DoxyCodeLine{00666 }
\DoxyCodeLine{00667     \textcolor{comment}{//}}
\DoxyCodeLine{00668     \textcolor{comment}{// PSO for opaque objects.}}
\DoxyCodeLine{00669     \textcolor{comment}{//}}
\DoxyCodeLine{00670     ZeroMemory(\&opaquePsoDesc, \textcolor{keyword}{sizeof}(D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC));}
\DoxyCodeLine{00671     opaquePsoDesc.InputLayout = \{ mInputLayout.data(), (UINT)mInputLayout.size() \};}
\DoxyCodeLine{00672     opaquePsoDesc.pRootSignature = mRootSignature.Get();}
\DoxyCodeLine{00673     opaquePsoDesc.VS = }
\DoxyCodeLine{00674     \{ }
\DoxyCodeLine{00675         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferPointer()), }
\DoxyCodeLine{00676         mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00677     \};}
\DoxyCodeLine{00678     opaquePsoDesc.PS = }
\DoxyCodeLine{00679     \{ }
\DoxyCodeLine{00680         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00681         mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00682     \};}
\DoxyCodeLine{00683     opaquePsoDesc.RasterizerState = CD3DX12\_RASTERIZER\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00684     opaquePsoDesc.BlendState = CD3DX12\_BLEND\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00685     opaquePsoDesc.DepthStencilState = CD3DX12\_DEPTH\_STENCIL\_DESC(D3D12\_DEFAULT);  \textcolor{comment}{//by default, opaquePsoDesc.DepthStencilState.DepthFunc = D3D12\_COMPARISON\_FUNC\_LESS}}
\DoxyCodeLine{00686     opaquePsoDesc.SampleMask = UINT\_MAX;}
\DoxyCodeLine{00687     opaquePsoDesc.PrimitiveTopologyType = D3D12\_PRIMITIVE\_TOPOLOGY\_TYPE\_TRIANGLE;}
\DoxyCodeLine{00688     opaquePsoDesc.NumRenderTargets = 1;}
\DoxyCodeLine{00689     opaquePsoDesc.RTVFormats[0] = mBackBufferFormat;}
\DoxyCodeLine{00690     opaquePsoDesc.SampleDesc.Count = m4xMsaaState ? 4 : 1;}
\DoxyCodeLine{00691     opaquePsoDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality -\/ 1) : 0;}
\DoxyCodeLine{00692     opaquePsoDesc.DSVFormat = mDepthStencilFormat;}
\DoxyCodeLine{00693     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&opaquePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}opaque"{}}])));}
\DoxyCodeLine{00694 }
\DoxyCodeLine{00695     \textcolor{comment}{// Step6}}
\DoxyCodeLine{00696     \textcolor{comment}{// PSO for highlight objects}}
\DoxyCodeLine{00697     \textcolor{comment}{//}}
\DoxyCodeLine{00698 }
\DoxyCodeLine{00699     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC highlightPsoDesc = opaquePsoDesc;}
\DoxyCodeLine{00700 }
\DoxyCodeLine{00701     \textcolor{comment}{// Change the depth test from < to <= so that if we draw the same triangle twice, it will}}
\DoxyCodeLine{00702     \textcolor{comment}{// still pass the depth test.  This is needed because we redraw the picked triangle with a}}
\DoxyCodeLine{00703     \textcolor{comment}{// different material to highlight it.  If we do not use <=, the triangle will fail the }}
\DoxyCodeLine{00704     \textcolor{comment}{// depth test the 2nd time we try and draw it.}}
\DoxyCodeLine{00705     highlightPsoDesc.DepthStencilState.DepthFunc = D3D12\_COMPARISON\_FUNC\_LESS\_EQUAL;}
\DoxyCodeLine{00706 }
\DoxyCodeLine{00707     \textcolor{comment}{// Standard transparency blending.}}
\DoxyCodeLine{00708     D3D12\_RENDER\_TARGET\_BLEND\_DESC transparencyBlendDesc;}
\DoxyCodeLine{00709     transparencyBlendDesc.BlendEnable = \textcolor{keyword}{true};}
\DoxyCodeLine{00710     transparencyBlendDesc.LogicOpEnable = \textcolor{keyword}{false};}
\DoxyCodeLine{00711     transparencyBlendDesc.SrcBlend = D3D12\_BLEND\_SRC\_ALPHA;}
\DoxyCodeLine{00712     transparencyBlendDesc.DestBlend = D3D12\_BLEND\_INV\_SRC\_ALPHA;}
\DoxyCodeLine{00713     transparencyBlendDesc.BlendOp = D3D12\_BLEND\_OP\_ADD;}
\DoxyCodeLine{00714     transparencyBlendDesc.SrcBlendAlpha = D3D12\_BLEND\_ONE;}
\DoxyCodeLine{00715     transparencyBlendDesc.DestBlendAlpha = D3D12\_BLEND\_ZERO;}
\DoxyCodeLine{00716     transparencyBlendDesc.BlendOpAlpha = D3D12\_BLEND\_OP\_ADD;}
\DoxyCodeLine{00717     transparencyBlendDesc.LogicOp = D3D12\_LOGIC\_OP\_NOOP;}
\DoxyCodeLine{00718     transparencyBlendDesc.RenderTargetWriteMask = D3D12\_COLOR\_WRITE\_ENABLE\_ALL;}
\DoxyCodeLine{00719 }
\DoxyCodeLine{00720     highlightPsoDesc.BlendState.RenderTarget[0] = transparencyBlendDesc;}
\DoxyCodeLine{00721     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&highlightPsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}highlight"{}}])));}
\DoxyCodeLine{00722 \}}
\DoxyCodeLine{00723 }
\DoxyCodeLine{00724 \textcolor{keywordtype}{void} PickingApp::BuildFrameResources()}
\DoxyCodeLine{00725 \{}
\DoxyCodeLine{00726     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < gNumFrameResources; ++i)}
\DoxyCodeLine{00727     \{}
\DoxyCodeLine{00728         mFrameResources.push\_back(std::make\_unique<FrameResource>(md3dDevice.Get(),}
\DoxyCodeLine{00729             1, (UINT)mAllRitems.size(), (UINT)mMaterials.size()));}
\DoxyCodeLine{00730     \}}
\DoxyCodeLine{00731 \}}
\DoxyCodeLine{00732 }
\DoxyCodeLine{00733 \textcolor{keywordtype}{void} PickingApp::BuildMaterials()}
\DoxyCodeLine{00734 \{}
\DoxyCodeLine{00735     \textcolor{keyword}{auto} gray0 = std::make\_unique<Material>();}
\DoxyCodeLine{00736     gray0-\/>Name = \textcolor{stringliteral}{"{}gray0"{}};}
\DoxyCodeLine{00737     gray0-\/>MatCBIndex = 0;}
\DoxyCodeLine{00738     gray0-\/>DiffuseSrvHeapIndex = 0;}
\DoxyCodeLine{00739     gray0-\/>DiffuseAlbedo = XMFLOAT4(0.7f, 0.7f, 0.7f, 1.0f);}
\DoxyCodeLine{00740     gray0-\/>FresnelR0 = XMFLOAT3(0.04f, 0.04f, 0.04f);}
\DoxyCodeLine{00741     gray0-\/>Roughness = 0.0f;}
\DoxyCodeLine{00742 }
\DoxyCodeLine{00743     \textcolor{keyword}{auto} highlight0 = std::make\_unique<Material>();}
\DoxyCodeLine{00744     highlight0-\/>Name = \textcolor{stringliteral}{"{}highlight0"{}};}
\DoxyCodeLine{00745     highlight0-\/>MatCBIndex = 1;}
\DoxyCodeLine{00746     highlight0-\/>DiffuseSrvHeapIndex = 0;}
\DoxyCodeLine{00747     highlight0-\/>DiffuseAlbedo = XMFLOAT4(1.0f, 1.0f, 0.0f, 0.6f);}
\DoxyCodeLine{00748     highlight0-\/>FresnelR0 = XMFLOAT3(0.06f, 0.06f, 0.06f);}
\DoxyCodeLine{00749     highlight0-\/>Roughness = 0.0f;}
\DoxyCodeLine{00750 }
\DoxyCodeLine{00751     }
\DoxyCodeLine{00752     mMaterials[\textcolor{stringliteral}{"{}gray0"{}}] = std::move(gray0);}
\DoxyCodeLine{00753     mMaterials[\textcolor{stringliteral}{"{}highlight0"{}}] = std::move(highlight0);}
\DoxyCodeLine{00754 \}}
\DoxyCodeLine{00755 }
\DoxyCodeLine{00756 \textcolor{keywordtype}{void} PickingApp::BuildRenderItems()}
\DoxyCodeLine{00757 \{}
\DoxyCodeLine{00758     \textcolor{keyword}{auto} carRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{00759     XMStoreFloat4x4(\&carRitem-\/>World, XMMatrixScaling(1.0f, 1.0f, 1.0f)*XMMatrixTranslation(0.0f, 1.0f, 0.0f));}
\DoxyCodeLine{00760     XMStoreFloat4x4(\&carRitem-\/>TexTransform, XMMatrixScaling(1.0f, 1.0f, 1.0f));}
\DoxyCodeLine{00761     carRitem-\/>ObjCBIndex = 0;}
\DoxyCodeLine{00762     carRitem-\/>Mat = mMaterials[\textcolor{stringliteral}{"{}gray0"{}}].get();}
\DoxyCodeLine{00763     carRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}carGeo"{}}].get();}
\DoxyCodeLine{00764     carRitem-\/>PrimitiveType = D3D\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{00765     carRitem-\/>Bounds = carRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}car"{}}].Bounds;}
\DoxyCodeLine{00766     carRitem-\/>IndexCount = carRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}car"{}}].IndexCount;}
\DoxyCodeLine{00767     carRitem-\/>StartIndexLocation = carRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}car"{}}].StartIndexLocation;}
\DoxyCodeLine{00768     carRitem-\/>BaseVertexLocation = carRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}car"{}}].BaseVertexLocation;}
\DoxyCodeLine{00769     mRitemLayer[(int)RenderLayer::Opaque].push\_back(carRitem.get());}
\DoxyCodeLine{00770 }
\DoxyCodeLine{00771     \textcolor{comment}{//step7}}
\DoxyCodeLine{00772 }
\DoxyCodeLine{00773     \textcolor{keyword}{auto} pickedRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{00774     pickedRitem-\/>World = MathHelper::Identity4x4();}
\DoxyCodeLine{00775     pickedRitem-\/>TexTransform = MathHelper::Identity4x4();}
\DoxyCodeLine{00776     pickedRitem-\/>ObjCBIndex = 1;}
\DoxyCodeLine{00777     pickedRitem-\/>Mat = mMaterials[\textcolor{stringliteral}{"{}highlight0"{}}].get();}
\DoxyCodeLine{00778     pickedRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}carGeo"{}}].get();}
\DoxyCodeLine{00779     pickedRitem-\/>PrimitiveType = D3D\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{00780 }
\DoxyCodeLine{00781     \textcolor{comment}{// Picked triangle is not visible until one is picked.}}
\DoxyCodeLine{00782     pickedRitem-\/>Visible = \textcolor{keyword}{false};}
\DoxyCodeLine{00783 }
\DoxyCodeLine{00784     \textcolor{comment}{// DrawCall parameters are filled out when a triangle is picked.}}
\DoxyCodeLine{00785     pickedRitem-\/>IndexCount = 0;}
\DoxyCodeLine{00786     pickedRitem-\/>StartIndexLocation = 0;}
\DoxyCodeLine{00787     pickedRitem-\/>BaseVertexLocation = 0;}
\DoxyCodeLine{00788     mPickedRitem = pickedRitem.get();}
\DoxyCodeLine{00789     mRitemLayer[(int)RenderLayer::Highlight].push\_back(pickedRitem.get());}
\DoxyCodeLine{00790 }
\DoxyCodeLine{00791 }
\DoxyCodeLine{00792     mAllRitems.push\_back(std::move(carRitem));}
\DoxyCodeLine{00793     mAllRitems.push\_back(std::move(pickedRitem));}
\DoxyCodeLine{00794 \}}
\DoxyCodeLine{00795 }
\DoxyCodeLine{00796 \textcolor{keywordtype}{void} PickingApp::DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems)}
\DoxyCodeLine{00797 \{}
\DoxyCodeLine{00798     UINT objCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(ObjectConstants));}
\DoxyCodeLine{00799  }
\DoxyCodeLine{00800     \textcolor{keyword}{auto} objectCB = mCurrFrameResource-\/>ObjectCB-\/>Resource();}
\DoxyCodeLine{00801 }
\DoxyCodeLine{00802     \textcolor{comment}{// For each render item...}}
\DoxyCodeLine{00803     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < ritems.size(); ++i)}
\DoxyCodeLine{00804     \{}
\DoxyCodeLine{00805         \textcolor{keyword}{auto} ri = ritems[i];}
\DoxyCodeLine{00806 }
\DoxyCodeLine{00807         \textcolor{keywordflow}{if}(ri-\/>Visible == \textcolor{keyword}{false})}
\DoxyCodeLine{00808             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{00809 }
\DoxyCodeLine{00810         cmdList-\/>IASetVertexBuffers(0, 1, \&ri-\/>Geo-\/>VertexBufferView());}
\DoxyCodeLine{00811         cmdList-\/>IASetIndexBuffer(\&ri-\/>Geo-\/>IndexBufferView());}
\DoxyCodeLine{00812         cmdList-\/>IASetPrimitiveTopology(ri-\/>PrimitiveType);}
\DoxyCodeLine{00813 }
\DoxyCodeLine{00814         D3D12\_GPU\_VIRTUAL\_ADDRESS objCBAddress = objectCB-\/>GetGPUVirtualAddress() + ri-\/>ObjCBIndex*objCBByteSize;}
\DoxyCodeLine{00815 }
\DoxyCodeLine{00816         cmdList-\/>SetGraphicsRootConstantBufferView(0, objCBAddress);}
\DoxyCodeLine{00817 }
\DoxyCodeLine{00818         cmdList-\/>DrawIndexedInstanced(ri-\/>IndexCount, 1, ri-\/>StartIndexLocation, ri-\/>BaseVertexLocation, 0);}
\DoxyCodeLine{00819     \}}
\DoxyCodeLine{00820 \}}
\DoxyCodeLine{00821 }
\DoxyCodeLine{00822 std::array<const CD3DX12\_STATIC\_SAMPLER\_DESC, 6> PickingApp::GetStaticSamplers()}
\DoxyCodeLine{00823 \{}
\DoxyCodeLine{00824     \textcolor{comment}{// Applications usually only need a handful of samplers.  So just define them all up front}}
\DoxyCodeLine{00825     \textcolor{comment}{// and keep them available as part of the root signature.  }}
\DoxyCodeLine{00826 }
\DoxyCodeLine{00827     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC pointWrap(}
\DoxyCodeLine{00828         0, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00829         D3D12\_FILTER\_MIN\_MAG\_MIP\_POINT, \textcolor{comment}{// filter}}
\DoxyCodeLine{00830         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00831         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00832         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{00833 }
\DoxyCodeLine{00834     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC pointClamp(}
\DoxyCodeLine{00835         1, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00836         D3D12\_FILTER\_MIN\_MAG\_MIP\_POINT, \textcolor{comment}{// filter}}
\DoxyCodeLine{00837         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00838         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00839         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{00840 }
\DoxyCodeLine{00841     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC linearWrap(}
\DoxyCodeLine{00842         2, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00843         D3D12\_FILTER\_MIN\_MAG\_MIP\_LINEAR, \textcolor{comment}{// filter}}
\DoxyCodeLine{00844         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00845         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00846         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{00847 }
\DoxyCodeLine{00848     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC linearClamp(}
\DoxyCodeLine{00849         3, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00850         D3D12\_FILTER\_MIN\_MAG\_MIP\_LINEAR, \textcolor{comment}{// filter}}
\DoxyCodeLine{00851         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00852         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00853         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{00854 }
\DoxyCodeLine{00855     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC anisotropicWrap(}
\DoxyCodeLine{00856         4, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00857         D3D12\_FILTER\_ANISOTROPIC, \textcolor{comment}{// filter}}
\DoxyCodeLine{00858         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00859         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00860         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressW}}
\DoxyCodeLine{00861         0.0f,                             \textcolor{comment}{// mipLODBias}}
\DoxyCodeLine{00862         8);                               \textcolor{comment}{// maxAnisotropy}}
\DoxyCodeLine{00863 }
\DoxyCodeLine{00864     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC anisotropicClamp(}
\DoxyCodeLine{00865         5, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00866         D3D12\_FILTER\_ANISOTROPIC, \textcolor{comment}{// filter}}
\DoxyCodeLine{00867         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00868         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00869         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressW}}
\DoxyCodeLine{00870         0.0f,                              \textcolor{comment}{// mipLODBias}}
\DoxyCodeLine{00871         8);                                \textcolor{comment}{// maxAnisotropy}}
\DoxyCodeLine{00872 }
\DoxyCodeLine{00873     \textcolor{keywordflow}{return} \{ }
\DoxyCodeLine{00874         pointWrap, pointClamp,}
\DoxyCodeLine{00875         linearWrap, linearClamp, }
\DoxyCodeLine{00876         anisotropicWrap, anisotropicClamp \};}
\DoxyCodeLine{00877 \}}
\DoxyCodeLine{00878 }
\DoxyCodeLine{00879 \textcolor{comment}{//step3: Assuming sx and xy are the screen coordinates where user picked an object (clicked)}}
\DoxyCodeLine{00880 \textcolor{comment}{//recall that d3dApp.h, we defined a screen size }}
\DoxyCodeLine{00881 \textcolor{comment}{//int mClientWidth = 800;}}
\DoxyCodeLine{00882 \textcolor{comment}{//int mClientHeight = 600;}}
\DoxyCodeLine{00883 }
\DoxyCodeLine{00884 }
\DoxyCodeLine{00885 \textcolor{keywordtype}{void} PickingApp::Pick(\textcolor{keywordtype}{int} sx, \textcolor{keywordtype}{int} sy)}
\DoxyCodeLine{00886 \{}
\DoxyCodeLine{00887     XMFLOAT4X4 P = mCamera.GetProj4x4f();   }
\DoxyCodeLine{00888 }
\DoxyCodeLine{00889 }
\DoxyCodeLine{00890     \textcolor{comment}{// Compute picking ray in view space.}}
\DoxyCodeLine{00891     \textcolor{comment}{//we can shoot our picking ray through the point (v'x, v'y, 1) instead. Note that this yields the same picking ray as the one shot through the point (xv, yv, d) on the projection window.}}
\DoxyCodeLine{00892 }
\DoxyCodeLine{00893     \textcolor{keywordtype}{float} vx = (+2.0f*sx / mClientWidth -\/ 1.0f) / P(0, 0);}
\DoxyCodeLine{00894     \textcolor{keywordtype}{float} vy = (-\/2.0f*sy / mClientHeight + 1.0f) / P(1, 1);}
\DoxyCodeLine{00895 }
\DoxyCodeLine{00896     \textcolor{comment}{// Ray definition in view space.}}
\DoxyCodeLine{00897     XMVECTOR rayOrigin = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f);}
\DoxyCodeLine{00898     XMVECTOR rayDir = XMVectorSet(vx, vy, 1.0f, 0.0f);}
\DoxyCodeLine{00899     }
\DoxyCodeLine{00900     XMMATRIX V = mCamera.GetView();}
\DoxyCodeLine{00901     XMMATRIX invView = XMMatrixInverse(\&XMMatrixDeterminant(V), V);}
\DoxyCodeLine{00902 }
\DoxyCodeLine{00903     \textcolor{comment}{//Generally, each object in the scene has its own local space. Therefore, the ray must be transformed to the local space of each scene object to do the intersection test.}}
\DoxyCodeLine{00904     \textcolor{comment}{//The following code shows how the picking ray is transformed from view space to the local space of an object :}}
\DoxyCodeLine{00905 }
\DoxyCodeLine{00906 }
\DoxyCodeLine{00907     \textcolor{comment}{// Assume nothing is picked to start, so the picked render-\/item is invisible.}}
\DoxyCodeLine{00908     mPickedRitem-\/>Visible = \textcolor{keyword}{false};}
\DoxyCodeLine{00909 }
\DoxyCodeLine{00910     \textcolor{comment}{// Check if we picked an opaque render item.  A real app might keep a separate "{}picking list"{}}}
\DoxyCodeLine{00911     \textcolor{comment}{// of objects that can be selected.   }}
\DoxyCodeLine{00912     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} ri : mRitemLayer[(\textcolor{keywordtype}{int})RenderLayer::Opaque])}
\DoxyCodeLine{00913     \{}
\DoxyCodeLine{00914         \textcolor{keyword}{auto} geo = ri-\/>Geo;}
\DoxyCodeLine{00915 }
\DoxyCodeLine{00916         \textcolor{comment}{// Skip invisible render-\/items.}}
\DoxyCodeLine{00917         \textcolor{keywordflow}{if}(ri-\/>Visible == \textcolor{keyword}{false})}
\DoxyCodeLine{00918             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{00919 }
\DoxyCodeLine{00920         XMMATRIX W = XMLoadFloat4x4(\&ri-\/>World);}
\DoxyCodeLine{00921 }
\DoxyCodeLine{00922         \textcolor{comment}{//If W is the world matrix of an object, the matrix W−1 transforms geometry from world space to the local space of the object.}}
\DoxyCodeLine{00923         XMMATRIX invWorld = XMMatrixInverse(\&XMMatrixDeterminant(W), W);}
\DoxyCodeLine{00924 }
\DoxyCodeLine{00925         \textcolor{comment}{//Because the view matrix transforms geometry from world space to view space, the inverse of the view matrix transforms geometry from view space to world space. }}
\DoxyCodeLine{00926         XMMATRIX toLocal = XMMatrixMultiply(invView, invWorld);}
\DoxyCodeLine{00927 }
\DoxyCodeLine{00928         \textcolor{comment}{//Generally, each object in the scene has its own local space. Therefore, the ray must be transformed to the local space of each scene object to do the intersection test.}}
\DoxyCodeLine{00929         rayOrigin = XMVector3TransformCoord(rayOrigin, toLocal);}
\DoxyCodeLine{00930         rayDir = XMVector3TransformNormal(rayDir, toLocal);}
\DoxyCodeLine{00931 }
\DoxyCodeLine{00932         \textcolor{comment}{// Make the ray direction unit length for the intersection tests.}}
\DoxyCodeLine{00933         rayDir = XMVector3Normalize(rayDir);}
\DoxyCodeLine{00934 }
\DoxyCodeLine{00935         \textcolor{comment}{// If we hit the bounding box of the Mesh, then we might have picked a Mesh triangle,}}
\DoxyCodeLine{00936         \textcolor{comment}{// so do the ray/triangle tests.}}
\DoxyCodeLine{00937         \textcolor{comment}{//}}
\DoxyCodeLine{00938         \textcolor{comment}{// If we did not hit the bounding box, then it is impossible that we hit }}
\DoxyCodeLine{00939         \textcolor{comment}{// the Mesh, so do not waste effort doing ray/triangle tests.}}
\DoxyCodeLine{00940         \textcolor{keywordtype}{float} tmin = 0.0f;}
\DoxyCodeLine{00941         \textcolor{keywordflow}{if}(ri-\/>Bounds.Intersects(rayOrigin, rayDir, tmin))}
\DoxyCodeLine{00942         \{}
\DoxyCodeLine{00943             \textcolor{comment}{// NOTE: For the demo, we know what to cast the vertex/index data to.  If we were mixing}}
\DoxyCodeLine{00944             \textcolor{comment}{// formats, some metadata would be needed to figure out what to cast it to.}}
\DoxyCodeLine{00945             \textcolor{keyword}{auto} vertices = (Vertex*)geo-\/>VertexBufferCPU-\/>GetBufferPointer();}
\DoxyCodeLine{00946             \textcolor{keyword}{auto} indices = (std::uint32\_t*)geo-\/>IndexBufferCPU-\/>GetBufferPointer();}
\DoxyCodeLine{00947             UINT triCount = ri-\/>IndexCount / 3;}
\DoxyCodeLine{00948 }
\DoxyCodeLine{00949             \textcolor{comment}{// Find the nearest ray/triangle intersection.}}
\DoxyCodeLine{00950             tmin = MathHelper::Infinity;}
\DoxyCodeLine{00951             \textcolor{keywordflow}{for}(UINT i = 0; i < triCount; ++i)}
\DoxyCodeLine{00952             \{}
\DoxyCodeLine{00953                 \textcolor{comment}{// Indices for this triangle.}}
\DoxyCodeLine{00954                 UINT i0 = indices[i * 3 + 0];}
\DoxyCodeLine{00955                 UINT i1 = indices[i * 3 + 1];}
\DoxyCodeLine{00956                 UINT i2 = indices[i * 3 + 2];}
\DoxyCodeLine{00957 }
\DoxyCodeLine{00958                 \textcolor{comment}{// Vertices for this triangle.}}
\DoxyCodeLine{00959                 XMVECTOR v0 = XMLoadFloat3(\&vertices[i0].Pos);}
\DoxyCodeLine{00960                 XMVECTOR v1 = XMLoadFloat3(\&vertices[i1].Pos);}
\DoxyCodeLine{00961                 XMVECTOR v2 = XMLoadFloat3(\&vertices[i2].Pos);}
\DoxyCodeLine{00962 }
\DoxyCodeLine{00963                 \textcolor{comment}{// We have to iterate over all the triangles in order to find the nearest intersection.}}
\DoxyCodeLine{00964                 \textcolor{keywordtype}{float} t = 0.0f;}
\DoxyCodeLine{00965                 \textcolor{keywordflow}{if}(TriangleTests::Intersects(rayOrigin, rayDir, v0, v1, v2, t))}
\DoxyCodeLine{00966                 \{}
\DoxyCodeLine{00967                     \textcolor{keywordflow}{if}(t < tmin)}
\DoxyCodeLine{00968                     \{}
\DoxyCodeLine{00969                         \textcolor{comment}{// This is the new nearest picked triangle.}}
\DoxyCodeLine{00970                         tmin = t;}
\DoxyCodeLine{00971                         UINT pickedTriangle = i;}
\DoxyCodeLine{00972 }
\DoxyCodeLine{00973                         mPickedRitem-\/>Visible = \textcolor{keyword}{true};}
\DoxyCodeLine{00974                         mPickedRitem-\/>IndexCount = 3;}
\DoxyCodeLine{00975                         mPickedRitem-\/>BaseVertexLocation = 0;}
\DoxyCodeLine{00976 }
\DoxyCodeLine{00977                         \textcolor{comment}{// Picked render item needs same world matrix as object picked.}}
\DoxyCodeLine{00978                         mPickedRitem-\/>World = ri-\/>World;}
\DoxyCodeLine{00979                         mPickedRitem-\/>NumFramesDirty = gNumFrameResources;}
\DoxyCodeLine{00980 }
\DoxyCodeLine{00981                         \textcolor{comment}{// Offset to the picked triangle in the mesh index buffer.}}
\DoxyCodeLine{00982                         mPickedRitem-\/>StartIndexLocation = 3 * pickedTriangle;}
\DoxyCodeLine{00983                     \}}
\DoxyCodeLine{00984                 \}}
\DoxyCodeLine{00985             \}}
\DoxyCodeLine{00986         \}}
\DoxyCodeLine{00987     \}}
\DoxyCodeLine{00988 \}}

\end{DoxyCode}
