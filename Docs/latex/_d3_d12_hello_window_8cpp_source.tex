\doxysection{D3\+D12\+Hello\+Window.\+cpp}
\label{_d3_d12_hello_window_8cpp_source}\index{Week2/Week2-\/7-\/Hello World/D3D12HelloWindow.cpp@{Week2/Week2-\/7-\/Hello World/D3D12HelloWindow.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{//*********************************************************}}
\DoxyCodeLine{00002 \textcolor{comment}{//}}
\DoxyCodeLine{00003 \textcolor{comment}{// Copyright (c) Microsoft. All rights reserved.}}
\DoxyCodeLine{00004 \textcolor{comment}{// This code is licensed under the MIT License (MIT).}}
\DoxyCodeLine{00005 \textcolor{comment}{// THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF}}
\DoxyCodeLine{00006 \textcolor{comment}{// ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY}}
\DoxyCodeLine{00007 \textcolor{comment}{// IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR}}
\DoxyCodeLine{00008 \textcolor{comment}{// PURPOSE, MERCHANTABILITY, OR NON-\/INFRINGEMENT.}}
\DoxyCodeLine{00009 \textcolor{comment}{//}}
\DoxyCodeLine{00010 \textcolor{comment}{//*********************************************************}}
\DoxyCodeLine{00011 }
\DoxyCodeLine{00012 \textcolor{preprocessor}{\#include "{}stdafx.h"{}}}
\DoxyCodeLine{00013 \textcolor{preprocessor}{\#include "{}D3D12HelloWindow.h"{}}}
\DoxyCodeLine{00014 }
\DoxyCodeLine{00015 D3D12HelloWindow::D3D12HelloWindow(UINT width, UINT height, std::wstring name) :}
\DoxyCodeLine{00016     DXSample(width, height, name),}
\DoxyCodeLine{00017     m\_frameIndex(0),}
\DoxyCodeLine{00018     m\_rtvDescriptorSize(0)}
\DoxyCodeLine{00019 \{}
\DoxyCodeLine{00020 \}}
\DoxyCodeLine{00021 }
\DoxyCodeLine{00022 \textcolor{comment}{//Step 1: Initialization involves first setting up the global variables and classes, and an initialize function must prepare the pipeline and assets.}}
\DoxyCodeLine{00023 \textcolor{keywordtype}{void} D3D12HelloWindow::OnInit()}
\DoxyCodeLine{00024 \{}
\DoxyCodeLine{00025     LoadPipeline();}
\DoxyCodeLine{00026     LoadAssets();}
\DoxyCodeLine{00027 \}}
\DoxyCodeLine{00028 }
\DoxyCodeLine{00029 \textcolor{comment}{// Load the rendering pipeline dependencies.}}
\DoxyCodeLine{00030 \textcolor{keywordtype}{void} D3D12HelloWindow::LoadPipeline()}
\DoxyCodeLine{00031 \{}
\DoxyCodeLine{00032     UINT dxgiFactoryFlags = 0;}
\DoxyCodeLine{00033 }
\DoxyCodeLine{00034 \textcolor{preprocessor}{\#if defined(\_DEBUG)}}
\DoxyCodeLine{00035     \textcolor{comment}{// Step2: Enable the debug layer (requires the Graphics Tools "{}optional feature"{}).}}
\DoxyCodeLine{00036     \textcolor{comment}{// NOTE: Enabling the debug layer after device creation will invalidate the active device.}}
\DoxyCodeLine{00037     \{}
\DoxyCodeLine{00038         ComPtr<ID3D12Debug> debugController;}
\DoxyCodeLine{00039         \textcolor{keywordflow}{if} (SUCCEEDED(D3D12GetDebugInterface(IID\_PPV\_ARGS(\&debugController))))}
\DoxyCodeLine{00040         \{}
\DoxyCodeLine{00041             debugController-\/>EnableDebugLayer();}
\DoxyCodeLine{00042 }
\DoxyCodeLine{00043             \textcolor{comment}{// Enable additional debug layers.}}
\DoxyCodeLine{00044             dxgiFactoryFlags |= DXGI\_CREATE\_FACTORY\_DEBUG;}
\DoxyCodeLine{00045         \}}
\DoxyCodeLine{00046     \}}
\DoxyCodeLine{00047 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00048 }
\DoxyCodeLine{00049     \textcolor{comment}{//step3: Enables creating Microsoft DirectX Graphics Infrastructure (DXGI) objects}}
\DoxyCodeLine{00050     ComPtr<IDXGIFactory4> factory;}
\DoxyCodeLine{00051     ThrowIfFailed(CreateDXGIFactory2(dxgiFactoryFlags, IID\_PPV\_ARGS(\&factory)));}
\DoxyCodeLine{00052 }
\DoxyCodeLine{00053     \textcolor{comment}{//step4: create a Windows Advanced Rasterization Platform (WARP) WARP enables Rendering When Direct3D Hardware is Not Available}}
\DoxyCodeLine{00054 }
\DoxyCodeLine{00055     \textcolor{keywordflow}{if} (m\_useWarpDevice)}
\DoxyCodeLine{00056     \{}
\DoxyCodeLine{00057         ComPtr<IDXGIAdapter> warpAdapter;}
\DoxyCodeLine{00058         ThrowIfFailed(factory-\/>EnumWarpAdapter(IID\_PPV\_ARGS(\&warpAdapter)));}
\DoxyCodeLine{00059 }
\DoxyCodeLine{00060         ThrowIfFailed(D3D12CreateDevice(}
\DoxyCodeLine{00061             warpAdapter.Get(),}
\DoxyCodeLine{00062             D3D\_FEATURE\_LEVEL\_11\_0,}
\DoxyCodeLine{00063             IID\_PPV\_ARGS(\&m\_device)}
\DoxyCodeLine{00064             ));}
\DoxyCodeLine{00065     \}}
\DoxyCodeLine{00066     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00067     \{}
\DoxyCodeLine{00068         \textcolor{comment}{//step5: The IDXGIAdapter interface represents a display subsystem (including one or more GPUs, DACs and video memory).}}
\DoxyCodeLine{00069         ComPtr<IDXGIAdapter1> hardwareAdapter;}
\DoxyCodeLine{00070         GetHardwareAdapter(factory.Get(), \&hardwareAdapter);}
\DoxyCodeLine{00071 }
\DoxyCodeLine{00072         \textcolor{comment}{//step6: Creates a device that represents the display adapter.}}
\DoxyCodeLine{00073         ThrowIfFailed(D3D12CreateDevice(}
\DoxyCodeLine{00074             hardwareAdapter.Get(),}
\DoxyCodeLine{00075             D3D\_FEATURE\_LEVEL\_11\_0,}
\DoxyCodeLine{00076             IID\_PPV\_ARGS(\&m\_device)}
\DoxyCodeLine{00077             ));}
\DoxyCodeLine{00078     \}}
\DoxyCodeLine{00079 }
\DoxyCodeLine{00080     \textcolor{comment}{// step7: Describe and create the command queue. Fill out a command queue description, then create the command queue:}}
\DoxyCodeLine{00081     D3D12\_COMMAND\_QUEUE\_DESC queueDesc = \{\};}
\DoxyCodeLine{00082     queueDesc.Flags = D3D12\_COMMAND\_QUEUE\_FLAG\_NONE;}
\DoxyCodeLine{00083     queueDesc.Type = D3D12\_COMMAND\_LIST\_TYPE\_DIRECT;}
\DoxyCodeLine{00084 }
\DoxyCodeLine{00085     ThrowIfFailed(m\_device-\/>CreateCommandQueue(\&queueDesc, IID\_PPV\_ARGS(\&m\_commandQueue)));}
\DoxyCodeLine{00086 }
\DoxyCodeLine{00087     \textcolor{comment}{// step8: Describe and create the swap chain. Fill out a swapchain description, then create the swap chain}}
\DoxyCodeLine{00088     DXGI\_SWAP\_CHAIN\_DESC1 swapChainDesc = \{\};}
\DoxyCodeLine{00089     swapChainDesc.BufferCount = FrameCount;}
\DoxyCodeLine{00090     swapChainDesc.Width = m\_width;}
\DoxyCodeLine{00091     swapChainDesc.Height = m\_height;}
\DoxyCodeLine{00092     swapChainDesc.Format = DXGI\_FORMAT\_R8G8B8A8\_UNORM;}
\DoxyCodeLine{00093     swapChainDesc.BufferUsage = DXGI\_USAGE\_RENDER\_TARGET\_OUTPUT;}
\DoxyCodeLine{00094     swapChainDesc.SwapEffect = DXGI\_SWAP\_EFFECT\_FLIP\_DISCARD;}
\DoxyCodeLine{00095     swapChainDesc.SampleDesc.Count = 1;}
\DoxyCodeLine{00096 }
\DoxyCodeLine{00097     ComPtr<IDXGISwapChain1> swapChain;}
\DoxyCodeLine{00098     ThrowIfFailed(factory-\/>CreateSwapChainForHwnd(}
\DoxyCodeLine{00099         m\_commandQueue.Get(),        \textcolor{comment}{// Swap chain needs the queue so that it can force a flush on it.}}
\DoxyCodeLine{00100         Win32Application::GetHwnd(),}
\DoxyCodeLine{00101         \&swapChainDesc,}
\DoxyCodeLine{00102         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00103         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00104         \&swapChain}
\DoxyCodeLine{00105         ));}
\DoxyCodeLine{00106 }
\DoxyCodeLine{00107     \textcolor{comment}{// This sample does not support fullscreen transitions.}}
\DoxyCodeLine{00108     ThrowIfFailed(factory-\/>MakeWindowAssociation(Win32Application::GetHwnd(), DXGI\_MWA\_NO\_ALT\_ENTER));}
\DoxyCodeLine{00109 }
\DoxyCodeLine{00110     ThrowIfFailed(swapChain.As(\&m\_swapChain));}
\DoxyCodeLine{00111     m\_frameIndex = m\_swapChain-\/>GetCurrentBackBufferIndex();}
\DoxyCodeLine{00112 }
\DoxyCodeLine{00113     \textcolor{comment}{// step9: Create descriptor heaps. Fill out a heap description. then create a descriptor heap:}}
\DoxyCodeLine{00114     \{}
\DoxyCodeLine{00115         \textcolor{comment}{// Describe and create a render target view (RTV) descriptor heap.}}
\DoxyCodeLine{00116         D3D12\_DESCRIPTOR\_HEAP\_DESC rtvHeapDesc = \{\};}
\DoxyCodeLine{00117         rtvHeapDesc.NumDescriptors = FrameCount;}
\DoxyCodeLine{00118         rtvHeapDesc.Type = D3D12\_DESCRIPTOR\_HEAP\_TYPE\_RTV;}
\DoxyCodeLine{00119         rtvHeapDesc.Flags = D3D12\_DESCRIPTOR\_HEAP\_FLAG\_NONE;}
\DoxyCodeLine{00120         ThrowIfFailed(m\_device-\/>CreateDescriptorHeap(\&rtvHeapDesc, IID\_PPV\_ARGS(\&m\_rtvHeap)));}
\DoxyCodeLine{00121 }
\DoxyCodeLine{00122         m\_rtvDescriptorSize = m\_device-\/>GetDescriptorHandleIncrementSize(D3D12\_DESCRIPTOR\_HEAP\_TYPE\_RTV);}
\DoxyCodeLine{00123     \}}
\DoxyCodeLine{00124 }
\DoxyCodeLine{00125     \textcolor{comment}{// step10 : Create frame resources. Create the render target view:}}
\DoxyCodeLine{00126     \{}
\DoxyCodeLine{00127         CD3DX12\_CPU\_DESCRIPTOR\_HANDLE rtvHandle(m\_rtvHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00128 }
\DoxyCodeLine{00129         \textcolor{comment}{// Create a RTV for each frame.}}
\DoxyCodeLine{00130         \textcolor{keywordflow}{for} (UINT n = 0; n < FrameCount; n++)}
\DoxyCodeLine{00131         \{}
\DoxyCodeLine{00132             ThrowIfFailed(m\_swapChain-\/>GetBuffer(n, IID\_PPV\_ARGS(\&m\_renderTargets[n])));}
\DoxyCodeLine{00133             m\_device-\/>CreateRenderTargetView(m\_renderTargets[n].Get(), \textcolor{keyword}{nullptr}, rtvHandle);}
\DoxyCodeLine{00134             rtvHandle.Offset(1, m\_rtvDescriptorSize);}
\DoxyCodeLine{00135         \}}
\DoxyCodeLine{00136     \}}
\DoxyCodeLine{00137 }
\DoxyCodeLine{00138     ThrowIfFailed(m\_device-\/>CreateCommandAllocator(D3D12\_COMMAND\_LIST\_TYPE\_DIRECT, IID\_PPV\_ARGS(\&m\_commandAllocator)));}
\DoxyCodeLine{00139 \}}
\DoxyCodeLine{00140 }
\DoxyCodeLine{00141 \textcolor{comment}{// Load the sample assets.}}
\DoxyCodeLine{00142 \textcolor{keywordtype}{void} D3D12HelloWindow::LoadAssets()}
\DoxyCodeLine{00143 \{}
\DoxyCodeLine{00144     \textcolor{comment}{// Create the command list.}}
\DoxyCodeLine{00145     ThrowIfFailed(m\_device-\/>CreateCommandList(0, D3D12\_COMMAND\_LIST\_TYPE\_DIRECT, m\_commandAllocator.Get(), \textcolor{keyword}{nullptr}, IID\_PPV\_ARGS(\&m\_commandList)));}
\DoxyCodeLine{00146 }
\DoxyCodeLine{00147     \textcolor{comment}{// Command lists are created in the recording state, but there is nothing}}
\DoxyCodeLine{00148     \textcolor{comment}{// to record yet. The main loop expects it to be closed, so close it now.}}
\DoxyCodeLine{00149     ThrowIfFailed(m\_commandList-\/>Close());}
\DoxyCodeLine{00150 }
\DoxyCodeLine{00151     \textcolor{comment}{// Create synchronization objects.}}
\DoxyCodeLine{00152     \{}
\DoxyCodeLine{00153         ThrowIfFailed(m\_device-\/>CreateFence(0, D3D12\_FENCE\_FLAG\_NONE, IID\_PPV\_ARGS(\&m\_fence)));}
\DoxyCodeLine{00154         m\_fenceValue = 1;}
\DoxyCodeLine{00155 }
\DoxyCodeLine{00156         \textcolor{comment}{// Create an event handle to use for frame synchronization.}}
\DoxyCodeLine{00157         m\_fenceEvent = CreateEvent(\textcolor{keyword}{nullptr}, FALSE, FALSE, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00158         \textcolor{keywordflow}{if} (m\_fenceEvent == \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00159         \{}
\DoxyCodeLine{00160             ThrowIfFailed(HRESULT\_FROM\_WIN32(GetLastError()));}
\DoxyCodeLine{00161         \}}
\DoxyCodeLine{00162     \}}
\DoxyCodeLine{00163 \}}
\DoxyCodeLine{00164 }
\DoxyCodeLine{00165 \textcolor{comment}{// Update frame-\/based values.}}
\DoxyCodeLine{00166 \textcolor{keywordtype}{void} D3D12HelloWindow::OnUpdate()}
\DoxyCodeLine{00167 \{}
\DoxyCodeLine{00168 \}}
\DoxyCodeLine{00169 }
\DoxyCodeLine{00170 \textcolor{comment}{// Render the scene.}}
\DoxyCodeLine{00171 \textcolor{keywordtype}{void} D3D12HelloWindow::OnRender()}
\DoxyCodeLine{00172 \{}
\DoxyCodeLine{00173     \textcolor{comment}{// Record all the commands we need to render the scene into the command list.}}
\DoxyCodeLine{00174     PopulateCommandList();}
\DoxyCodeLine{00175 }
\DoxyCodeLine{00176     \textcolor{comment}{// Execute the command list.}}
\DoxyCodeLine{00177     ID3D12CommandList* ppCommandLists[] = \{ m\_commandList.Get() \};}
\DoxyCodeLine{00178     m\_commandQueue-\/>ExecuteCommandLists(\_countof(ppCommandLists), ppCommandLists);}
\DoxyCodeLine{00179 }
\DoxyCodeLine{00180     \textcolor{comment}{// Present the frame.}}
\DoxyCodeLine{00181     ThrowIfFailed(m\_swapChain-\/>Present(1, 0));}
\DoxyCodeLine{00182 }
\DoxyCodeLine{00183     WaitForPreviousFrame();}
\DoxyCodeLine{00184 \}}
\DoxyCodeLine{00185 }
\DoxyCodeLine{00186 \textcolor{keywordtype}{void} D3D12HelloWindow::OnDestroy()}
\DoxyCodeLine{00187 \{}
\DoxyCodeLine{00188     \textcolor{comment}{// Ensure that the GPU is no longer referencing resources that are about to be}}
\DoxyCodeLine{00189     \textcolor{comment}{// cleaned up by the destructor.}}
\DoxyCodeLine{00190     WaitForPreviousFrame();}
\DoxyCodeLine{00191 }
\DoxyCodeLine{00192     CloseHandle(m\_fenceEvent);}
\DoxyCodeLine{00193 \}}
\DoxyCodeLine{00194 }
\DoxyCodeLine{00195 \textcolor{keywordtype}{void} D3D12HelloWindow::PopulateCommandList()}
\DoxyCodeLine{00196 \{}
\DoxyCodeLine{00197     \textcolor{comment}{// Command list allocators can only be reset when the associated }}
\DoxyCodeLine{00198     \textcolor{comment}{// command lists have finished execution on the GPU; apps should use }}
\DoxyCodeLine{00199     \textcolor{comment}{// fences to determine GPU execution progress.}}
\DoxyCodeLine{00200     ThrowIfFailed(m\_commandAllocator-\/>Reset());}
\DoxyCodeLine{00201 }
\DoxyCodeLine{00202     \textcolor{comment}{// However, when ExecuteCommandList() is called on a particular command }}
\DoxyCodeLine{00203     \textcolor{comment}{// list, that command list can then be reset at any time and must be before }}
\DoxyCodeLine{00204     \textcolor{comment}{// re-\/recording.}}
\DoxyCodeLine{00205     ThrowIfFailed(m\_commandList-\/>Reset(m\_commandAllocator.Get(), m\_pipelineState.Get()));}
\DoxyCodeLine{00206 }
\DoxyCodeLine{00207     \textcolor{comment}{// Indicate that the back buffer will be used as a render target.}}
\DoxyCodeLine{00208     m\_commandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(m\_renderTargets[m\_frameIndex].Get(), D3D12\_RESOURCE\_STATE\_PRESENT, D3D12\_RESOURCE\_STATE\_RENDER\_TARGET));}
\DoxyCodeLine{00209 }
\DoxyCodeLine{00210     CD3DX12\_CPU\_DESCRIPTOR\_HANDLE rtvHandle(m\_rtvHeap-\/>GetCPUDescriptorHandleForHeapStart(), m\_frameIndex, m\_rtvDescriptorSize);}
\DoxyCodeLine{00211 }
\DoxyCodeLine{00212     \textcolor{comment}{// Record commands.}}
\DoxyCodeLine{00213     \textcolor{keyword}{const} \textcolor{keywordtype}{float} clearColor[] = \{ 0.0f, 0.2f, 0.4f, 1.0f \};}
\DoxyCodeLine{00214     m\_commandList-\/>ClearRenderTargetView(rtvHandle, clearColor, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00215 }
\DoxyCodeLine{00216     \textcolor{comment}{// Indicate that the back buffer will now be used to present.}}
\DoxyCodeLine{00217     m\_commandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(m\_renderTargets[m\_frameIndex].Get(), D3D12\_RESOURCE\_STATE\_RENDER\_TARGET, D3D12\_RESOURCE\_STATE\_PRESENT));}
\DoxyCodeLine{00218 }
\DoxyCodeLine{00219     ThrowIfFailed(m\_commandList-\/>Close());}
\DoxyCodeLine{00220 \}}
\DoxyCodeLine{00221 }
\DoxyCodeLine{00222 \textcolor{keywordtype}{void} D3D12HelloWindow::WaitForPreviousFrame()}
\DoxyCodeLine{00223 \{}
\DoxyCodeLine{00224     \textcolor{comment}{// WAITING FOR THE FRAME TO COMPLETE BEFORE CONTINUING IS NOT BEST PRACTICE.}}
\DoxyCodeLine{00225     \textcolor{comment}{// This is code implemented as such for simplicity. The D3D12HelloFrameBuffering}}
\DoxyCodeLine{00226     \textcolor{comment}{// sample illustrates how to use fences for efficient resource usage and to}}
\DoxyCodeLine{00227     \textcolor{comment}{// maximize GPU utilization.}}
\DoxyCodeLine{00228 }
\DoxyCodeLine{00229     \textcolor{comment}{// Signal and increment the fence value.}}
\DoxyCodeLine{00230     \textcolor{keyword}{const} UINT64 fence = m\_fenceValue;}
\DoxyCodeLine{00231     ThrowIfFailed(m\_commandQueue-\/>Signal(m\_fence.Get(), fence));}
\DoxyCodeLine{00232     m\_fenceValue++;}
\DoxyCodeLine{00233 }
\DoxyCodeLine{00234     \textcolor{comment}{// Wait until the previous frame is finished.}}
\DoxyCodeLine{00235     \textcolor{keywordflow}{if} (m\_fence-\/>GetCompletedValue() < fence)}
\DoxyCodeLine{00236     \{}
\DoxyCodeLine{00237         ThrowIfFailed(m\_fence-\/>SetEventOnCompletion(fence, m\_fenceEvent));}
\DoxyCodeLine{00238         WaitForSingleObject(m\_fenceEvent, INFINITE);}
\DoxyCodeLine{00239     \}}
\DoxyCodeLine{00240 }
\DoxyCodeLine{00241     m\_frameIndex = m\_swapChain-\/>GetCurrentBackBufferIndex();}
\DoxyCodeLine{00242 \}}

\end{DoxyCode}
