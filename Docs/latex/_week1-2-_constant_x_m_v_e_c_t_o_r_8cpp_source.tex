\doxysection{Week1-\/2-\/\+Constant\+XMVECTOR.cpp}
\label{_week1-2-_constant_x_m_v_e_c_t_o_r_8cpp_source}\index{Week1/DirectXMath Examples/Week1-\/2-\/ConstantXMVECTOR.cpp@{Week1/DirectXMath Examples/Week1-\/2-\/ConstantXMVECTOR.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 }
\DoxyCodeLine{00016 \textcolor{preprocessor}{\#include <windows.h>} \textcolor{comment}{// for XMVerifyCPUSupport}}
\DoxyCodeLine{00017 \textcolor{preprocessor}{\#include <DirectXMath.h>}}
\DoxyCodeLine{00018 \textcolor{preprocessor}{\#include <DirectXPackedVector.h>}}
\DoxyCodeLine{00019 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{00020 }
\DoxyCodeLine{00021 \textcolor{keyword}{using namespace }std;}
\DoxyCodeLine{00022 \textcolor{keyword}{using namespace }DirectX;}
\DoxyCodeLine{00023 \textcolor{keyword}{using namespace }DirectX::PackedVector;}
\DoxyCodeLine{00024 }
\DoxyCodeLine{00025 \textcolor{comment}{// Overload the  "{}<<"{} operators so that we can use cout to }}
\DoxyCodeLine{00026 \textcolor{comment}{// output XMVECTOR objects.}}
\DoxyCodeLine{00027 ostream\& XM\_CALLCONV operator << (ostream\& os, FXMVECTOR v)}
\DoxyCodeLine{00028 \{}
\DoxyCodeLine{00029     XMFLOAT3 dest;}
\DoxyCodeLine{00030     XMStoreFloat3(\&dest, v);}
\DoxyCodeLine{00031 }
\DoxyCodeLine{00032     os << \textcolor{stringliteral}{"{}("{}} << dest.x << \textcolor{stringliteral}{"{}, "{}} << dest.y << \textcolor{stringliteral}{"{}, "{}} << dest.z << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00033     \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{00034 \}}
\DoxyCodeLine{00035 }
\DoxyCodeLine{00036 \textcolor{keywordtype}{int} main()}
\DoxyCodeLine{00037 \{}
\DoxyCodeLine{00038 }
\DoxyCodeLine{00039     \textcolor{comment}{// Check support for SSE2 (Pentium4, AMD K8, and above).}}
\DoxyCodeLine{00040     \textcolor{keywordflow}{if} (!XMVerifyCPUSupport())}
\DoxyCodeLine{00041     \{}
\DoxyCodeLine{00042         cout << \textcolor{stringliteral}{"{}directx math not supported"{}} << endl;}
\DoxyCodeLine{00043         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00044     \}}
\DoxyCodeLine{00045 }
\DoxyCodeLine{00046     \textcolor{comment}{//Constant XMVECTOR instances should use the XMVECTORF32 type.}}
\DoxyCodeLine{00047     \textcolor{keyword}{static} \textcolor{keyword}{const} XMVECTORF32 g\_vHalfVector = \{ 0.5f, 0.5f, 0.5f, 0.5f \};}
\DoxyCodeLine{00048     \textcolor{keyword}{static} \textcolor{keyword}{const} XMVECTORF32 g\_vZero = \{ 0.0f, 0.0f, 0.0f, 0.0f \};}
\DoxyCodeLine{00049 }
\DoxyCodeLine{00050     \textcolor{comment}{//The XMVECTORF32, XMVECTORU32, XMVECTORI32, and XMVECTORU8 structures are provided as a mechanism }}
\DoxyCodeLine{00051     \textcolor{comment}{//for creating XMVECTOR from different constant data types (floating point, unsigned integer, integer, and byte) using initializers.}}
\DoxyCodeLine{00052     \textcolor{keyword}{static} \textcolor{keyword}{const} XMVECTORU32 vGrabY = \{ 0x00000000,0xEFFFFFFF,0x00000000,0x00000000 \};}
\DoxyCodeLine{00053     XMVECTOR data;}
\DoxyCodeLine{00054     data = vGrabY;}
\DoxyCodeLine{00055     cout << \textcolor{stringliteral}{"{}data = "{}} << data << endl;}
\DoxyCodeLine{00056 }
\DoxyCodeLine{00057     \textcolor{comment}{// Returns the zero vector 0}}
\DoxyCodeLine{00058     XMVECTOR p = XMVectorZero();}
\DoxyCodeLine{00059 }
\DoxyCodeLine{00060     \textcolor{comment}{// Returns the vector (1, 1, 1, 1)}}
\DoxyCodeLine{00061     XMVECTOR q = XMVectorSplatOne();}
\DoxyCodeLine{00062 }
\DoxyCodeLine{00063     \textcolor{comment}{// Returns the vector (x, y, z, w)}}
\DoxyCodeLine{00064     XMVECTOR u = XMVectorSet(1.0f, 2.0f, 3.0f, 0.0f);}
\DoxyCodeLine{00065 }
\DoxyCodeLine{00066     \textcolor{comment}{// Returns the vector (s, s, s, s)}}
\DoxyCodeLine{00067     XMVECTOR v = XMVectorReplicate(-\/2.0f);}
\DoxyCodeLine{00068 }
\DoxyCodeLine{00069     \textcolor{comment}{// Returns the vector (wz, wz, wz, wz)}}
\DoxyCodeLine{00070     XMVECTOR w = XMVectorSplatZ(u);}
\DoxyCodeLine{00071 }
\DoxyCodeLine{00072     cout << \textcolor{stringliteral}{"{}p = "{}} << p << endl;}
\DoxyCodeLine{00073     cout << \textcolor{stringliteral}{"{}q = "{}} << q << endl;}
\DoxyCodeLine{00074     cout << \textcolor{stringliteral}{"{}u = "{}} << u << endl;}
\DoxyCodeLine{00075     cout << \textcolor{stringliteral}{"{}v = "{}} << v << endl;}
\DoxyCodeLine{00076     cout << \textcolor{stringliteral}{"{}w = "{}} << w << endl;}
\DoxyCodeLine{00077 }
\DoxyCodeLine{00078     \textcolor{keyword}{const} \textcolor{keywordtype}{double} d = 1.2345678901234;}
\DoxyCodeLine{00079     std::cout << \textcolor{stringliteral}{"{}The  default precision is "{}} << std::cout.precision() << endl;}
\DoxyCodeLine{00080     std::cout << \textcolor{stringliteral}{"{}With default precision d is "{}} << d << endl;}
\DoxyCodeLine{00081     std::cout.precision(12);}
\DoxyCodeLine{00082     std::cout << \textcolor{stringliteral}{"{}With high    precision d is "{}} << d << endl;}
\DoxyCodeLine{00083 }
\DoxyCodeLine{00084 }
\DoxyCodeLine{00085     \textcolor{comment}{//Manages the precision (i.e. how many digits are generated) of floating point output}}
\DoxyCodeLine{00086     cout.precision(8);}
\DoxyCodeLine{00087 }
\DoxyCodeLine{00088     XMVECTOR n = XMVector3Normalize(u);}
\DoxyCodeLine{00089 }
\DoxyCodeLine{00090     \textcolor{keywordtype}{float} LU = XMVectorGetX(XMVector3Length(n));}
\DoxyCodeLine{00091 }
\DoxyCodeLine{00092     \textcolor{comment}{// Mathematically, the length should be 1. Is it numerically ?}}
\DoxyCodeLine{00093     cout << \textcolor{stringliteral}{"{}LU = "{}} << LU << endl;}
\DoxyCodeLine{00094     \textcolor{keywordflow}{if} (LU == 1.0f)}
\DoxyCodeLine{00095         cout << \textcolor{stringliteral}{"{}Length 1"{}} << endl;}
\DoxyCodeLine{00096     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00097         cout << \textcolor{stringliteral}{"{}Length not 1"{}} << endl;}
\DoxyCodeLine{00098 }
\DoxyCodeLine{00099     \textcolor{comment}{// Raising 1 to any power should still be 1. Is it?}}
\DoxyCodeLine{00100     \textcolor{keywordtype}{float} powLU = powf(LU, 1.0e6f);}
\DoxyCodeLine{00101     cout << \textcolor{stringliteral}{"{}LU \string^ (10 \string^ 6) = "{}} << powLU << endl;}
\DoxyCodeLine{00102 }
\DoxyCodeLine{00103     \textcolor{comment}{//To compensate for floating-\/point imprecision, we test if two floating-\/point numbers}}
\DoxyCodeLine{00104     \textcolor{comment}{//are approximately equal.We do this by defining an Epsilon constant, which is a very small}}
\DoxyCodeLine{00105     \textcolor{comment}{//value we use as a “buffer.”}}
\DoxyCodeLine{00106 }
\DoxyCodeLine{00107     \textcolor{keyword}{const} \textcolor{keywordtype}{float} Epsilon = 0.001f;}
\DoxyCodeLine{00108     \textcolor{comment}{//bool Equals(float lhs, float rhs)}}
\DoxyCodeLine{00109     \textcolor{comment}{//\{}}
\DoxyCodeLine{00110     \textcolor{comment}{//  // Is the distance between lhs and rhs less than EPSILON ?}}
\DoxyCodeLine{00111     \textcolor{comment}{//      return fabs(lhs -\/ rhs) < Epsilon ? true : false;}}
\DoxyCodeLine{00112     \textcolor{comment}{//\}}}
\DoxyCodeLine{00113 }
\DoxyCodeLine{00114     \textcolor{comment}{//The DirectX Math library provides the XMVector3NearEqual function when}}
\DoxyCodeLine{00115     \textcolor{comment}{//  testing the equality of vectors with an allowed tolerance Epsilon parameter :}}
\DoxyCodeLine{00116     \textcolor{comment}{// Returns}}
\DoxyCodeLine{00117     \textcolor{comment}{// abs(U.x – V.x) <= Epsilon.x \&\&}}
\DoxyCodeLine{00118     \textcolor{comment}{// abs(U.y – V.y) <= Epsilon.y \&\&}}
\DoxyCodeLine{00119     \textcolor{comment}{// abs(U.z – V.z) <= Epsilon.z}}
\DoxyCodeLine{00120     \textcolor{comment}{//XMFINLINE bool XM\_CALLCONV XMVector3NearEqual(    FXMVECTOR U,FXMVECTOR V, FXMVECTOR Epsilon);}}
\DoxyCodeLine{00121 }
\DoxyCodeLine{00122     \textcolor{comment}{//When the boolalpha format flag is set, bool values are inserted / extracted by their textual representation : either true or false, instead of integral values}}
\DoxyCodeLine{00123     cout.setf(ios\_base::boolalpha);}
\DoxyCodeLine{00124     cout << \textcolor{stringliteral}{"{}LU and q vectors are almost equal? "{}} << XMVector3NearEqual(XMVectorReplicate(LU), q, XMVectorReplicate(Epsilon)) << endl;}
\DoxyCodeLine{00125 }
\DoxyCodeLine{00126 }
\DoxyCodeLine{00127     p = XMVectorSet(2.0f, 2.0f, 1.0f, 0.0f);}
\DoxyCodeLine{00128     q = XMVectorSet(2.0f, -\/0.5f, 0.5f, 0.1f);}
\DoxyCodeLine{00129     u = XMVectorSet(1.0f, 2.0f, 4.0f, 8.0f);}
\DoxyCodeLine{00130     v = XMVectorSet(-\/2.0f, 1.0f, -\/3.0f, 2.5f);}
\DoxyCodeLine{00131     w = XMVectorSet(0.0f, XM\_PIDIV4, XM\_PIDIV2, XM\_PI);}
\DoxyCodeLine{00132 }
\DoxyCodeLine{00133     cout << \textcolor{stringliteral}{"{}XMVectorAbs(v) = "{}} << XMVectorAbs(v) << endl;}
\DoxyCodeLine{00134     cout << \textcolor{stringliteral}{"{}XMVectorCos(w) = "{}} << XMVectorCos(w) << endl;}
\DoxyCodeLine{00135     cout << \textcolor{stringliteral}{"{}XMVectorLog(u) = "{}} << XMVectorLog(u) << endl;}
\DoxyCodeLine{00136     cout << \textcolor{stringliteral}{"{}XMVectorExp(p) = "{}} << XMVectorExp(p) << endl;}
\DoxyCodeLine{00137     cout << \textcolor{stringliteral}{"{}XMVectorPow(u, p) = "{}} << XMVectorPow(u, p) << endl;}
\DoxyCodeLine{00138     cout << \textcolor{stringliteral}{"{}XMVectorSqrt(u) = "{}} << XMVectorSqrt(u) << endl;}
\DoxyCodeLine{00139     cout << \textcolor{stringliteral}{"{}XMVectorSwizzle(u, 2, 2, 1, 3) = "{}} << XMVectorSwizzle(u, 2, 2, 1, 3) << endl;}
\DoxyCodeLine{00140     cout << \textcolor{stringliteral}{"{}XMVectorSwizzle(u, 2, 1, 0, 3) = "{}} << XMVectorSwizzle(u, 2, 1, 0, 3) << endl;}
\DoxyCodeLine{00141     cout << \textcolor{stringliteral}{"{}XMVectorMultiply(u, v) = "{}} << XMVectorMultiply(u, v) << endl;}
\DoxyCodeLine{00142     cout << \textcolor{stringliteral}{"{}XMVectorSaturate(q) = "{}} << XMVectorSaturate(q) << endl;}
\DoxyCodeLine{00143     cout << \textcolor{stringliteral}{"{}XMVectorMin(p, v) = "{}} << XMVectorMin(p, v) << endl;}
\DoxyCodeLine{00144     cout << \textcolor{stringliteral}{"{}XMVectorMax(p, v) = "{}} << XMVectorMax(p, v) << endl;}
\DoxyCodeLine{00145 }
\DoxyCodeLine{00146     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00147 \}}

\end{DoxyCode}
