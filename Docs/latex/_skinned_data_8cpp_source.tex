\doxysection{Skinned\+Data.\+cpp}
\label{_skinned_data_8cpp_source}\index{Week15/SkinnedMesh/SkinnedData.cpp@{Week15/SkinnedMesh/SkinnedData.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{preprocessor}{\#include "{}SkinnedData.h"{}}}
\DoxyCodeLine{00002 }
\DoxyCodeLine{00003 \textcolor{keyword}{using namespace }DirectX;}
\DoxyCodeLine{00004 }
\DoxyCodeLine{00005 Keyframe::Keyframe()}
\DoxyCodeLine{00006     : TimePos(0.0f),}
\DoxyCodeLine{00007     Translation(0.0f, 0.0f, 0.0f),}
\DoxyCodeLine{00008     Scale(1.0f, 1.0f, 1.0f),}
\DoxyCodeLine{00009     RotationQuat(0.0f, 0.0f, 0.0f, 1.0f)}
\DoxyCodeLine{00010 \{}
\DoxyCodeLine{00011 \}}
\DoxyCodeLine{00012 }
\DoxyCodeLine{00013 Keyframe::\string~Keyframe()}
\DoxyCodeLine{00014 \{}
\DoxyCodeLine{00015 \}}
\DoxyCodeLine{00016  }
\DoxyCodeLine{00017 \textcolor{keywordtype}{float} BoneAnimation::GetStartTime()\textcolor{keyword}{const}}
\DoxyCodeLine{00018 \textcolor{keyword}{}\{}
\DoxyCodeLine{00019     \textcolor{comment}{// Keyframes are sorted by time, so first keyframe gives start time.}}
\DoxyCodeLine{00020     \textcolor{keywordflow}{return} Keyframes.front().TimePos;}
\DoxyCodeLine{00021 \}}
\DoxyCodeLine{00022 }
\DoxyCodeLine{00023 \textcolor{keywordtype}{float} BoneAnimation::GetEndTime()\textcolor{keyword}{const}}
\DoxyCodeLine{00024 \textcolor{keyword}{}\{}
\DoxyCodeLine{00025     \textcolor{comment}{// Keyframes are sorted by time, so last keyframe gives end time.}}
\DoxyCodeLine{00026     \textcolor{keywordtype}{float} f = Keyframes.back().TimePos;}
\DoxyCodeLine{00027 }
\DoxyCodeLine{00028     \textcolor{keywordflow}{return} f;}
\DoxyCodeLine{00029 \}}
\DoxyCodeLine{00030 }
\DoxyCodeLine{00031 \textcolor{keywordtype}{void} BoneAnimation::Interpolate(\textcolor{keywordtype}{float} t, XMFLOAT4X4\& M)\textcolor{keyword}{const}}
\DoxyCodeLine{00032 \textcolor{keyword}{}\{}
\DoxyCodeLine{00033     \textcolor{keywordflow}{if}( t <= Keyframes.front().TimePos )}
\DoxyCodeLine{00034     \{}
\DoxyCodeLine{00035         XMVECTOR S = XMLoadFloat3(\&Keyframes.front().Scale);}
\DoxyCodeLine{00036         XMVECTOR P = XMLoadFloat3(\&Keyframes.front().Translation);}
\DoxyCodeLine{00037         XMVECTOR Q = XMLoadFloat4(\&Keyframes.front().RotationQuat);}
\DoxyCodeLine{00038 }
\DoxyCodeLine{00039         XMVECTOR zero = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f);}
\DoxyCodeLine{00040         XMStoreFloat4x4(\&M, XMMatrixAffineTransformation(S, zero, Q, P));}
\DoxyCodeLine{00041     \}}
\DoxyCodeLine{00042     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( t >= Keyframes.back().TimePos )}
\DoxyCodeLine{00043     \{}
\DoxyCodeLine{00044         XMVECTOR S = XMLoadFloat3(\&Keyframes.back().Scale);}
\DoxyCodeLine{00045         XMVECTOR P = XMLoadFloat3(\&Keyframes.back().Translation);}
\DoxyCodeLine{00046         XMVECTOR Q = XMLoadFloat4(\&Keyframes.back().RotationQuat);}
\DoxyCodeLine{00047 }
\DoxyCodeLine{00048         XMVECTOR zero = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f);}
\DoxyCodeLine{00049         XMStoreFloat4x4(\&M, XMMatrixAffineTransformation(S, zero, Q, P));}
\DoxyCodeLine{00050     \}}
\DoxyCodeLine{00051     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00052     \{}
\DoxyCodeLine{00053         \textcolor{keywordflow}{for}(UINT i = 0; i < Keyframes.size()-\/1; ++i)}
\DoxyCodeLine{00054         \{}
\DoxyCodeLine{00055             \textcolor{keywordflow}{if}( t >= Keyframes[i].TimePos \&\& t <= Keyframes[i+1].TimePos )}
\DoxyCodeLine{00056             \{}
\DoxyCodeLine{00057                 \textcolor{keywordtype}{float} lerpPercent = (t -\/ Keyframes[i].TimePos) / (Keyframes[i+1].TimePos -\/ Keyframes[i].TimePos);}
\DoxyCodeLine{00058 }
\DoxyCodeLine{00059                 XMVECTOR s0 = XMLoadFloat3(\&Keyframes[i].Scale);}
\DoxyCodeLine{00060                 XMVECTOR s1 = XMLoadFloat3(\&Keyframes[i+1].Scale);}
\DoxyCodeLine{00061 }
\DoxyCodeLine{00062                 XMVECTOR p0 = XMLoadFloat3(\&Keyframes[i].Translation);}
\DoxyCodeLine{00063                 XMVECTOR p1 = XMLoadFloat3(\&Keyframes[i+1].Translation);}
\DoxyCodeLine{00064 }
\DoxyCodeLine{00065                 XMVECTOR q0 = XMLoadFloat4(\&Keyframes[i].RotationQuat);}
\DoxyCodeLine{00066                 XMVECTOR q1 = XMLoadFloat4(\&Keyframes[i+1].RotationQuat);}
\DoxyCodeLine{00067 }
\DoxyCodeLine{00068                 XMVECTOR S = XMVectorLerp(s0, s1, lerpPercent);}
\DoxyCodeLine{00069                 XMVECTOR P = XMVectorLerp(p0, p1, lerpPercent);}
\DoxyCodeLine{00070                 XMVECTOR Q = XMQuaternionSlerp(q0, q1, lerpPercent);}
\DoxyCodeLine{00071 }
\DoxyCodeLine{00072                 XMVECTOR zero = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f);}
\DoxyCodeLine{00073                 XMStoreFloat4x4(\&M, XMMatrixAffineTransformation(S, zero, Q, P));}
\DoxyCodeLine{00074 }
\DoxyCodeLine{00075                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{00076             \}}
\DoxyCodeLine{00077         \}}
\DoxyCodeLine{00078     \}}
\DoxyCodeLine{00079 \}}
\DoxyCodeLine{00080 }
\DoxyCodeLine{00081 \textcolor{keywordtype}{float} AnimationClip::GetClipStartTime()\textcolor{keyword}{const}}
\DoxyCodeLine{00082 \textcolor{keyword}{}\{}
\DoxyCodeLine{00083     \textcolor{comment}{// Find smallest start time over all bones in this clip.}}
\DoxyCodeLine{00084     \textcolor{keywordtype}{float} t = MathHelper::Infinity;}
\DoxyCodeLine{00085     \textcolor{keywordflow}{for}(UINT i = 0; i < BoneAnimations.size(); ++i)}
\DoxyCodeLine{00086     \{}
\DoxyCodeLine{00087         t = MathHelper::Min(t, BoneAnimations[i].GetStartTime());}
\DoxyCodeLine{00088     \}}
\DoxyCodeLine{00089 }
\DoxyCodeLine{00090     \textcolor{keywordflow}{return} t;}
\DoxyCodeLine{00091 \}}
\DoxyCodeLine{00092 }
\DoxyCodeLine{00093 \textcolor{keywordtype}{float} AnimationClip::GetClipEndTime()\textcolor{keyword}{const}}
\DoxyCodeLine{00094 \textcolor{keyword}{}\{}
\DoxyCodeLine{00095     \textcolor{comment}{// Find largest end time over all bones in this clip.}}
\DoxyCodeLine{00096     \textcolor{keywordtype}{float} t = 0.0f;}
\DoxyCodeLine{00097     \textcolor{keywordflow}{for}(UINT i = 0; i < BoneAnimations.size(); ++i)}
\DoxyCodeLine{00098     \{}
\DoxyCodeLine{00099         t = MathHelper::Max(t, BoneAnimations[i].GetEndTime());}
\DoxyCodeLine{00100     \}}
\DoxyCodeLine{00101 }
\DoxyCodeLine{00102     \textcolor{keywordflow}{return} t;}
\DoxyCodeLine{00103 \}}
\DoxyCodeLine{00104 }
\DoxyCodeLine{00105 \textcolor{keywordtype}{void} AnimationClip::Interpolate(\textcolor{keywordtype}{float} t, std::vector<XMFLOAT4X4>\& boneTransforms)\textcolor{keyword}{const}}
\DoxyCodeLine{00106 \textcolor{keyword}{}\{}
\DoxyCodeLine{00107     \textcolor{keywordflow}{for}(UINT i = 0; i < BoneAnimations.size(); ++i)}
\DoxyCodeLine{00108     \{}
\DoxyCodeLine{00109         BoneAnimations[i].Interpolate(t, boneTransforms[i]);}
\DoxyCodeLine{00110     \}}
\DoxyCodeLine{00111 \}}
\DoxyCodeLine{00112 }
\DoxyCodeLine{00113 \textcolor{keywordtype}{float} SkinnedData::GetClipStartTime(\textcolor{keyword}{const} std::string\& clipName)\textcolor{keyword}{const}}
\DoxyCodeLine{00114 \textcolor{keyword}{}\{}
\DoxyCodeLine{00115     \textcolor{keyword}{auto} clip = mAnimations.find(clipName);}
\DoxyCodeLine{00116     \textcolor{keywordflow}{return} clip-\/>second.GetClipStartTime();}
\DoxyCodeLine{00117 \}}
\DoxyCodeLine{00118 }
\DoxyCodeLine{00119 \textcolor{keywordtype}{float} SkinnedData::GetClipEndTime(\textcolor{keyword}{const} std::string\& clipName)\textcolor{keyword}{const}}
\DoxyCodeLine{00120 \textcolor{keyword}{}\{}
\DoxyCodeLine{00121     \textcolor{keyword}{auto} clip = mAnimations.find(clipName);}
\DoxyCodeLine{00122     \textcolor{keywordflow}{return} clip-\/>second.GetClipEndTime();}
\DoxyCodeLine{00123 \}}
\DoxyCodeLine{00124 }
\DoxyCodeLine{00125 UINT SkinnedData::BoneCount()\textcolor{keyword}{const}}
\DoxyCodeLine{00126 \textcolor{keyword}{}\{}
\DoxyCodeLine{00127     \textcolor{keywordflow}{return} mBoneHierarchy.size();}
\DoxyCodeLine{00128 \}}
\DoxyCodeLine{00129 }
\DoxyCodeLine{00130 \textcolor{keywordtype}{void} SkinnedData::Set(std::vector<int>\& boneHierarchy, }
\DoxyCodeLine{00131                       std::vector<XMFLOAT4X4>\& boneOffsets,}
\DoxyCodeLine{00132                       std::unordered\_map<std::string, AnimationClip>\& animations)}
\DoxyCodeLine{00133 \{}
\DoxyCodeLine{00134     mBoneHierarchy = boneHierarchy;}
\DoxyCodeLine{00135     mBoneOffsets   = boneOffsets;}
\DoxyCodeLine{00136     mAnimations    = animations;}
\DoxyCodeLine{00137 \}}
\DoxyCodeLine{00138  }
\DoxyCodeLine{00139 \textcolor{keywordtype}{void} SkinnedData::GetFinalTransforms(\textcolor{keyword}{const} std::string\& clipName, \textcolor{keywordtype}{float} timePos,  std::vector<XMFLOAT4X4>\& finalTransforms)\textcolor{keyword}{const}}
\DoxyCodeLine{00140 \textcolor{keyword}{}\{}
\DoxyCodeLine{00141     UINT numBones = mBoneOffsets.size();}
\DoxyCodeLine{00142 }
\DoxyCodeLine{00143     std::vector<XMFLOAT4X4> toParentTransforms(numBones);}
\DoxyCodeLine{00144 }
\DoxyCodeLine{00145     \textcolor{comment}{// Interpolate all the bones of this clip at the given time instance.}}
\DoxyCodeLine{00146     \textcolor{keyword}{auto} clip = mAnimations.find(clipName);}
\DoxyCodeLine{00147     clip-\/>second.Interpolate(timePos, toParentTransforms);}
\DoxyCodeLine{00148 }
\DoxyCodeLine{00149     \textcolor{comment}{//}}
\DoxyCodeLine{00150     \textcolor{comment}{// Traverse the hierarchy and transform all the bones to the root space.}}
\DoxyCodeLine{00151     \textcolor{comment}{//}}
\DoxyCodeLine{00152 }
\DoxyCodeLine{00153     std::vector<XMFLOAT4X4> toRootTransforms(numBones);}
\DoxyCodeLine{00154 }
\DoxyCodeLine{00155     \textcolor{comment}{// The root bone has index 0.  The root bone has no parent, so its toRootTransform}}
\DoxyCodeLine{00156     \textcolor{comment}{// is just its local bone transform.}}
\DoxyCodeLine{00157     toRootTransforms[0] = toParentTransforms[0];}
\DoxyCodeLine{00158 }
\DoxyCodeLine{00159     \textcolor{comment}{// Now find the toRootTransform of the children.}}
\DoxyCodeLine{00160     \textcolor{keywordflow}{for}(UINT i = 1; i < numBones; ++i)}
\DoxyCodeLine{00161     \{}
\DoxyCodeLine{00162         XMMATRIX toParent = XMLoadFloat4x4(\&toParentTransforms[i]);}
\DoxyCodeLine{00163 }
\DoxyCodeLine{00164         \textcolor{keywordtype}{int} parentIndex = mBoneHierarchy[i];}
\DoxyCodeLine{00165         XMMATRIX parentToRoot = XMLoadFloat4x4(\&toRootTransforms[parentIndex]);}
\DoxyCodeLine{00166 }
\DoxyCodeLine{00167         XMMATRIX toRoot = XMMatrixMultiply(toParent, parentToRoot);}
\DoxyCodeLine{00168 }
\DoxyCodeLine{00169         XMStoreFloat4x4(\&toRootTransforms[i], toRoot);}
\DoxyCodeLine{00170     \}}
\DoxyCodeLine{00171 }
\DoxyCodeLine{00172     \textcolor{comment}{// Premultiply by the bone offset transform to get the final transform.}}
\DoxyCodeLine{00173     \textcolor{keywordflow}{for}(UINT i = 0; i < numBones; ++i)}
\DoxyCodeLine{00174     \{}
\DoxyCodeLine{00175         XMMATRIX offset = XMLoadFloat4x4(\&mBoneOffsets[i]);}
\DoxyCodeLine{00176         XMMATRIX toRoot = XMLoadFloat4x4(\&toRootTransforms[i]);}
\DoxyCodeLine{00177         XMMATRIX finalTransform = XMMatrixMultiply(offset, toRoot);}
\DoxyCodeLine{00178         XMStoreFloat4x4(\&finalTransforms[i], XMMatrixTranspose(finalTransform));}
\DoxyCodeLine{00179     \}}
\DoxyCodeLine{00180 \}}

\end{DoxyCode}
