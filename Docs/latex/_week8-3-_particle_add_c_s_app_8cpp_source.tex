\doxysection{Week8-\/3-\/\+Particle\+Add\+CSApp.cpp}
\label{_week8-3-_particle_add_c_s_app_8cpp_source}\index{Week8/VecAdd/Week8-\/3-\/ParticleAddCSApp.cpp@{Week8/VecAdd/Week8-\/3-\/ParticleAddCSApp.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00002 \textcolor{comment}{// particleAddCSApp.cpp }}
\DoxyCodeLine{00004 \textcolor{comment}{}\textcolor{comment}{// It will increment the counter when append is called and decrement the counter when consume is called.}}
\DoxyCodeLine{00005 \textcolor{comment}{//So, in this program, I have 256 particles. Every particle is a structure of 36 bytes. I have two UAVs associated to the append and consume structures.}}
\DoxyCodeLine{00006 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00007 }
\DoxyCodeLine{00008 \textcolor{preprocessor}{\#include "{}../../Common/d3dApp.h"{}}}
\DoxyCodeLine{00009 \textcolor{preprocessor}{\#include "{}../../Common/UploadBuffer.h"{}}}
\DoxyCodeLine{00010 }
\DoxyCodeLine{00011 \textcolor{keyword}{using} Microsoft::WRL::ComPtr;}
\DoxyCodeLine{00012 \textcolor{keyword}{using namespace }DirectX;}
\DoxyCodeLine{00013 \textcolor{keyword}{using namespace }DirectX::PackedVector;}
\DoxyCodeLine{00014 }
\DoxyCodeLine{00015 \textcolor{preprocessor}{\#pragma comment(lib, "{}d3dcompiler.lib"{}})}
\DoxyCodeLine{00016 \textcolor{preprocessor}{\#pragma comment(lib, "{}D3D12.lib"{}})}
\DoxyCodeLine{00017 }
\DoxyCodeLine{00018 }
\DoxyCodeLine{00019 \textcolor{keyword}{struct }Particle}
\DoxyCodeLine{00020 \{}
\DoxyCodeLine{00021     XMFLOAT3 Position;}
\DoxyCodeLine{00022     XMFLOAT3 Velocity;}
\DoxyCodeLine{00023     XMFLOAT3 Acceleration;}
\DoxyCodeLine{00024 \};}
\DoxyCodeLine{00025 }
\DoxyCodeLine{00026 \textcolor{keyword}{class }ParticleAddCSApp : \textcolor{keyword}{public} D3DApp}
\DoxyCodeLine{00027 \{}
\DoxyCodeLine{00028 \textcolor{keyword}{public}:}
\DoxyCodeLine{00029     ParticleAddCSApp(HINSTANCE hInstance);}
\DoxyCodeLine{00030     ParticleAddCSApp(\textcolor{keyword}{const} ParticleAddCSApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00031     ParticleAddCSApp\& operator=(\textcolor{keyword}{const} ParticleAddCSApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00032     \string~ParticleAddCSApp();}
\DoxyCodeLine{00033 }
\DoxyCodeLine{00034     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} Initialize()\textcolor{keyword}{override};}
\DoxyCodeLine{00035 }
\DoxyCodeLine{00036 \textcolor{keyword}{private}:}
\DoxyCodeLine{00037     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnResize()\textcolor{keyword}{override};}
\DoxyCodeLine{00038     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Update(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00039     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Draw(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00040 }
\DoxyCodeLine{00041     \textcolor{keywordtype}{void} DoComputeWork();}
\DoxyCodeLine{00042 }
\DoxyCodeLine{00043     \textcolor{keywordtype}{void} BuildBuffers();}
\DoxyCodeLine{00044     \textcolor{keywordtype}{void} BuildRootSignature();}
\DoxyCodeLine{00045     \textcolor{keywordtype}{void} BuildShadersAndInputLayout();}
\DoxyCodeLine{00046     \textcolor{keywordtype}{void} BuildDescriptors();}
\DoxyCodeLine{00047     \textcolor{keywordtype}{void} BuildDescriptorHeaps();}
\DoxyCodeLine{00048     \textcolor{keywordtype}{void} BuildPSOs();}
\DoxyCodeLine{00049 }
\DoxyCodeLine{00050 \textcolor{keyword}{private}:}
\DoxyCodeLine{00051 }
\DoxyCodeLine{00052     ComPtr<ID3D12RootSignature> mRootSignature = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00053 }
\DoxyCodeLine{00054     ComPtr<ID3D12DescriptorHeap> mUavHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00055 }
\DoxyCodeLine{00056     std::unordered\_map<std::string, ComPtr<ID3DBlob>> mShaders;}
\DoxyCodeLine{00057     std::unordered\_map<std::string, ComPtr<ID3D12PipelineState>> mPSOs;}
\DoxyCodeLine{00058 }
\DoxyCodeLine{00059     std::vector<D3D12\_INPUT\_ELEMENT\_DESC> mInputLayout;}
\DoxyCodeLine{00060 }
\DoxyCodeLine{00061     \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDataElements = 16 * 16;}
\DoxyCodeLine{00062 }
\DoxyCodeLine{00063     ComPtr<ID3D12Resource> mInputBufferA = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00064     ComPtr<ID3D12Resource> mInputUploadBufferA = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00065     ComPtr<ID3D12Resource> mOutputBuffer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00066     ComPtr<ID3D12Resource> mReadBackBuffer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00067 }
\DoxyCodeLine{00068     UINT mCbvSrvUavDescriptorSize = 0;}
\DoxyCodeLine{00069 }
\DoxyCodeLine{00070 \};}
\DoxyCodeLine{00071 }
\DoxyCodeLine{00072 \textcolor{keywordtype}{int} WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance,}
\DoxyCodeLine{00073     PSTR cmdLine, \textcolor{keywordtype}{int} showCmd)}
\DoxyCodeLine{00074 \{}
\DoxyCodeLine{00075     \textcolor{comment}{// Enable run-\/time memory check for debug builds.}}
\DoxyCodeLine{00076 \textcolor{preprocessor}{\#if defined(DEBUG) | defined(\_DEBUG)}}
\DoxyCodeLine{00077     \_CrtSetDbgFlag(\_CRTDBG\_ALLOC\_MEM\_DF | \_CRTDBG\_LEAK\_CHECK\_DF);}
\DoxyCodeLine{00078 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00079 }
\DoxyCodeLine{00080     \textcolor{keywordflow}{try}}
\DoxyCodeLine{00081     \{}
\DoxyCodeLine{00082         ParticleAddCSApp theApp(hInstance);}
\DoxyCodeLine{00083         \textcolor{keywordflow}{if} (!theApp.Initialize())}
\DoxyCodeLine{00084             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00085 }
\DoxyCodeLine{00086         \textcolor{comment}{// return theApp.Run();}}
\DoxyCodeLine{00087         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00088     \}}
\DoxyCodeLine{00089     \textcolor{keywordflow}{catch} (DxException \& e)}
\DoxyCodeLine{00090     \{}
\DoxyCodeLine{00091         MessageBox(\textcolor{keyword}{nullptr}, e.ToString().c\_str(), L\textcolor{stringliteral}{"{}HR Failed"{}}, MB\_OK);}
\DoxyCodeLine{00092         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00093     \}}
\DoxyCodeLine{00094 \}}
\DoxyCodeLine{00095 }
\DoxyCodeLine{00096 ParticleAddCSApp::ParticleAddCSApp(HINSTANCE hInstance)}
\DoxyCodeLine{00097     : D3DApp(hInstance)}
\DoxyCodeLine{00098 \{}
\DoxyCodeLine{00099 \}}
\DoxyCodeLine{00100 }
\DoxyCodeLine{00101 ParticleAddCSApp::\string~ParticleAddCSApp()}
\DoxyCodeLine{00102 \{}
\DoxyCodeLine{00103     \textcolor{keywordflow}{if} (md3dDevice != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00104         FlushCommandQueue();}
\DoxyCodeLine{00105 \}}
\DoxyCodeLine{00106 }
\DoxyCodeLine{00107 \textcolor{keywordtype}{bool} ParticleAddCSApp::Initialize()}
\DoxyCodeLine{00108 \{}
\DoxyCodeLine{00109     \textcolor{keywordflow}{if} (!D3DApp::Initialize())}
\DoxyCodeLine{00110         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00111 }
\DoxyCodeLine{00112     \textcolor{comment}{// Reset the command list to prep for initialization commands.}}
\DoxyCodeLine{00113     ThrowIfFailed(mCommandList-\/>Reset(mDirectCmdListAlloc.Get(), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{00114 }
\DoxyCodeLine{00115     \textcolor{comment}{// Get the increment size of a descriptor in this heap type.  This is hardware specific, }}
\DoxyCodeLine{00116 \textcolor{comment}{// so we have to query this information.}}
\DoxyCodeLine{00117     mCbvSrvUavDescriptorSize = md3dDevice-\/>GetDescriptorHandleIncrementSize(D3D12\_DESCRIPTOR\_HEAP\_TYPE\_CBV\_SRV\_UAV);}
\DoxyCodeLine{00118 }
\DoxyCodeLine{00119 }
\DoxyCodeLine{00120     BuildBuffers();}
\DoxyCodeLine{00121     BuildRootSignature();}
\DoxyCodeLine{00122     BuildShadersAndInputLayout();}
\DoxyCodeLine{00123     BuildDescriptorHeaps();}
\DoxyCodeLine{00124     BuildDescriptors();}
\DoxyCodeLine{00125     BuildPSOs();}
\DoxyCodeLine{00126 }
\DoxyCodeLine{00127     \textcolor{comment}{// Execute the initialization commands.}}
\DoxyCodeLine{00128     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00129     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00130     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00131 }
\DoxyCodeLine{00132     \textcolor{comment}{// Wait until initialization is complete.}}
\DoxyCodeLine{00133     FlushCommandQueue();}
\DoxyCodeLine{00134 }
\DoxyCodeLine{00135     DoComputeWork();}
\DoxyCodeLine{00136 }
\DoxyCodeLine{00137     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00138 \}}
\DoxyCodeLine{00139 }
\DoxyCodeLine{00140 \textcolor{keywordtype}{void} ParticleAddCSApp::OnResize()}
\DoxyCodeLine{00141 \{}
\DoxyCodeLine{00142 \}}
\DoxyCodeLine{00143 }
\DoxyCodeLine{00144 \textcolor{keywordtype}{void} ParticleAddCSApp::Update(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00145 \{}
\DoxyCodeLine{00146 \}}
\DoxyCodeLine{00147 }
\DoxyCodeLine{00148 \textcolor{keywordtype}{void} ParticleAddCSApp::Draw(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00149 \{}
\DoxyCodeLine{00150 \}}
\DoxyCodeLine{00151 }
\DoxyCodeLine{00152 }
\DoxyCodeLine{00153 \textcolor{keywordtype}{void} ParticleAddCSApp::DoComputeWork()}
\DoxyCodeLine{00154 \{}
\DoxyCodeLine{00155     \textcolor{comment}{// Reuse the memory associated with command recording.}}
\DoxyCodeLine{00156     \textcolor{comment}{// We can only reset when the associated command lists have finished execution on the GPU.}}
\DoxyCodeLine{00157     ThrowIfFailed(mDirectCmdListAlloc-\/>Reset());}
\DoxyCodeLine{00158 }
\DoxyCodeLine{00159     \textcolor{comment}{// A command list can be reset after it has been added to the command queue via ExecuteCommandList.}}
\DoxyCodeLine{00160     \textcolor{comment}{// Reusing the command list reuses memory.}}
\DoxyCodeLine{00161     ThrowIfFailed(mCommandList-\/>Reset(mDirectCmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}particleAdd"{}}].Get()));}
\DoxyCodeLine{00162 }
\DoxyCodeLine{00163     ID3D12DescriptorHeap* descriptorHeaps[] = \{ mUavHeap.Get() \};}
\DoxyCodeLine{00164     mCommandList-\/>SetDescriptorHeaps(\_countof(descriptorHeaps), descriptorHeaps);}
\DoxyCodeLine{00165 }
\DoxyCodeLine{00166 }
\DoxyCodeLine{00167     mCommandList-\/>SetComputeRootSignature(mRootSignature.Get());}
\DoxyCodeLine{00168 }
\DoxyCodeLine{00169     \textcolor{comment}{//mCommandList-\/>SetComputeRootUnorderedAccessView(0, mInputBufferA-\/>GetGPUVirtualAddress());}}
\DoxyCodeLine{00170     \textcolor{comment}{//mCommandList-\/>SetComputeRootUnorderedAccessView(1, mOutputBuffer-\/>GetGPUVirtualAddress());}}
\DoxyCodeLine{00171 }
\DoxyCodeLine{00172     \textcolor{keywordtype}{int} passUavIndex = 0;}
\DoxyCodeLine{00173     \textcolor{keyword}{auto} passUavHandle = CD3DX12\_GPU\_DESCRIPTOR\_HANDLE(mUavHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00174 }
\DoxyCodeLine{00175     mCommandList-\/>SetComputeRootDescriptorTable(0, passUavHandle);  \textcolor{comment}{//mInputBufferA-\/>GetGPUVirtualAddress()}}
\DoxyCodeLine{00176     passUavHandle.Offset(passUavIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00177     mCommandList-\/>SetComputeRootDescriptorTable(1, passUavHandle); \textcolor{comment}{//mOutputBuffer-\/>GetGPUVirtualAddress()}}
\DoxyCodeLine{00178 }
\DoxyCodeLine{00179     mCommandList-\/>Dispatch(1, 1, 1);}
\DoxyCodeLine{00180 }
\DoxyCodeLine{00181     \textcolor{comment}{// Schedule to copy the data to the default buffer to the readback buffer.}}
\DoxyCodeLine{00182 }
\DoxyCodeLine{00183     \textcolor{comment}{//D3D12\_RESOURCE\_STATE\_COPY\_SOURCE: The resource is used as the source in a copy operation. }}
\DoxyCodeLine{00184     \textcolor{comment}{//D3D12\_RESOURCE\_STATE\_COPY\_DEST: The resource is used as the destination in a copy operation.}}
\DoxyCodeLine{00185 }
\DoxyCodeLine{00186     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mOutputBuffer.Get(),}
\DoxyCodeLine{00187         D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS, D3D12\_RESOURCE\_STATE\_COPY\_SOURCE));}
\DoxyCodeLine{00188 }
\DoxyCodeLine{00189     \textcolor{comment}{//We need to read the data back from the GPU after computer shader does its calculation}}
\DoxyCodeLine{00190     \textcolor{comment}{//mCommandList-\/>CopyResource(Destination: CPUData, Source: GPUData);}}
\DoxyCodeLine{00191     mCommandList-\/>CopyResource(mReadBackBuffer.Get(), mOutputBuffer.Get());}
\DoxyCodeLine{00192 }
\DoxyCodeLine{00193     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mOutputBuffer.Get(),}
\DoxyCodeLine{00194         D3D12\_RESOURCE\_STATE\_COPY\_SOURCE, D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS));}
\DoxyCodeLine{00195 }
\DoxyCodeLine{00196 }
\DoxyCodeLine{00197     \textcolor{comment}{// Done recording commands.}}
\DoxyCodeLine{00198     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00199 }
\DoxyCodeLine{00200     \textcolor{comment}{// Add the command list to the queue for execution.}}
\DoxyCodeLine{00201     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00202     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00203 }
\DoxyCodeLine{00204     \textcolor{comment}{// Wait for the work to finish.}}
\DoxyCodeLine{00205     \textcolor{comment}{//FlushCommandQueue();}}
\DoxyCodeLine{00206 }
\DoxyCodeLine{00207     \textcolor{comment}{// Map the data so we can read it on CPU.}}
\DoxyCodeLine{00208     Particle* mappedData = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00209     CD3DX12\_RANGE readRange(0, 0);        \textcolor{comment}{// We do not intend to read from this resource on the CPU.}}
\DoxyCodeLine{00210     ThrowIfFailed(mReadBackBuffer-\/>Map(0, \textcolor{keyword}{nullptr}, \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}**\textcolor{keyword}{>}(\&mappedData)));}
\DoxyCodeLine{00211 }
\DoxyCodeLine{00212     std::ofstream fout(\textcolor{stringliteral}{"{}results.txt"{}});}
\DoxyCodeLine{00213 }
\DoxyCodeLine{00214     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDataElements; ++i)}
\DoxyCodeLine{00215     \{}
\DoxyCodeLine{00216         fout << \textcolor{stringliteral}{"{}("{}} << mappedData[i].Acceleration.x << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Acceleration.y << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Acceleration.z <<}
\DoxyCodeLine{00217             \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Position.x << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Position.y << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Position.z <<}
\DoxyCodeLine{00218             \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Velocity.x << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Velocity.y << \textcolor{stringliteral}{"{}, "{}} << mappedData[i].Velocity.z << \textcolor{stringliteral}{"{})"{}} << std::endl;}
\DoxyCodeLine{00219     \}}
\DoxyCodeLine{00220 }
\DoxyCodeLine{00221     mReadBackBuffer-\/>Unmap(0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00222 \}}
\DoxyCodeLine{00223 }
\DoxyCodeLine{00224 \textcolor{keywordtype}{void} ParticleAddCSApp::BuildBuffers()}
\DoxyCodeLine{00225 \{}
\DoxyCodeLine{00226     \textcolor{comment}{// Generate some data.}}
\DoxyCodeLine{00227     std::vector<Particle> dataA(NumDataElements);}
\DoxyCodeLine{00228     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDataElements; ++i)}
\DoxyCodeLine{00229     \{}
\DoxyCodeLine{00230         dataA[i].Acceleration = XMFLOAT3(1.0f, 1.0f, 1.0f);}
\DoxyCodeLine{00231         dataA[i].Position = XMFLOAT3((\textcolor{keywordtype}{float})i, (\textcolor{keywordtype}{float})i, (\textcolor{keywordtype}{float})i);}
\DoxyCodeLine{00232         dataA[i].Velocity = XMFLOAT3(10.0f, 10.0f, 0);}
\DoxyCodeLine{00233     \}}
\DoxyCodeLine{00234 }
\DoxyCodeLine{00235     UINT64 byteSize = dataA.size() * \textcolor{keyword}{sizeof}(Particle);}
\DoxyCodeLine{00236 }
\DoxyCodeLine{00237 }
\DoxyCodeLine{00238     \textcolor{comment}{// Create the actual input buffer resource.}}
\DoxyCodeLine{00239     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00240         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_DEFAULT),}
\DoxyCodeLine{00241         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00242         \&CD3DX12\_RESOURCE\_DESC::Buffer(byteSize, D3D12\_RESOURCE\_FLAG\_ALLOW\_UNORDERED\_ACCESS),}
\DoxyCodeLine{00243         D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS,}
\DoxyCodeLine{00244         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00245         IID\_PPV\_ARGS(\&mInputBufferA)));}
\DoxyCodeLine{00246 }
\DoxyCodeLine{00247     \textcolor{comment}{// In order to copy CPU memory data into our default buffer, we need to create}}
\DoxyCodeLine{00248     \textcolor{comment}{// an intermediate upload heap. }}
\DoxyCodeLine{00249     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00250         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_UPLOAD),}
\DoxyCodeLine{00251         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00252         \&CD3DX12\_RESOURCE\_DESC::Buffer(byteSize),}
\DoxyCodeLine{00253         D3D12\_RESOURCE\_STATE\_GENERIC\_READ,}
\DoxyCodeLine{00254         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00255         IID\_PPV\_ARGS(mInputUploadBufferA.GetAddressOf())));}
\DoxyCodeLine{00256 }
\DoxyCodeLine{00257 }
\DoxyCodeLine{00258     \textcolor{comment}{// Describe the data we want to copy into the default buffer.}}
\DoxyCodeLine{00259     D3D12\_SUBRESOURCE\_DATA subResourceData = \{\};}
\DoxyCodeLine{00260     subResourceData.pData = dataA.data();}
\DoxyCodeLine{00261     subResourceData.RowPitch = byteSize;}
\DoxyCodeLine{00262     subResourceData.SlicePitch = subResourceData.RowPitch;}
\DoxyCodeLine{00263 }
\DoxyCodeLine{00264     \textcolor{comment}{// Schedule to copy the data to the default buffer resource.  At a high level, the helper function UpdateSubresources}}
\DoxyCodeLine{00265     \textcolor{comment}{// will copy the CPU memory into the intermediate upload heap.  Then, using ID3D12CommandList::CopySubresourceRegion,}}
\DoxyCodeLine{00266     \textcolor{comment}{// the intermediate upload heap data will be copied to mBuffer.}}
\DoxyCodeLine{00267     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mInputBufferA.Get(),}
\DoxyCodeLine{00268         D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS, D3D12\_RESOURCE\_STATE\_COPY\_DEST));}
\DoxyCodeLine{00269 }
\DoxyCodeLine{00270     UpdateSubresources(mCommandList.Get(), mInputBufferA.Get(), mInputUploadBufferA.Get(), 0, 0, 1, \&subResourceData);}
\DoxyCodeLine{00271 }
\DoxyCodeLine{00272 }
\DoxyCodeLine{00273     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mInputBufferA.Get(),}
\DoxyCodeLine{00274         D3D12\_RESOURCE\_STATE\_COPY\_DEST, D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS));}
\DoxyCodeLine{00275 }
\DoxyCodeLine{00276 }
\DoxyCodeLine{00277     \textcolor{comment}{// Create the buffer that will be a UAV.}}
\DoxyCodeLine{00278     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00279         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_DEFAULT),}
\DoxyCodeLine{00280         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00281         \&CD3DX12\_RESOURCE\_DESC::Buffer(byteSize, D3D12\_RESOURCE\_FLAG\_ALLOW\_UNORDERED\_ACCESS),}
\DoxyCodeLine{00282         D3D12\_RESOURCE\_STATE\_UNORDERED\_ACCESS,}
\DoxyCodeLine{00283         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00284         IID\_PPV\_ARGS(\&mOutputBuffer)));}
\DoxyCodeLine{00285 }
\DoxyCodeLine{00286     \textcolor{comment}{//Specifies a heap used for reading back. This heap type has CPU access optimized for reading data back from the GPU, }}
\DoxyCodeLine{00287     \textcolor{comment}{//but does not experience the maximum amount of bandwidth for the GPU. This heap type is best for GPU-\/write-\/once, }}
\DoxyCodeLine{00288     \textcolor{comment}{//CPU-\/readable data. The CPU cache behavior is write-\/back, which is conducive for multiple sub-\/cache-\/line CPU reads.}}
\DoxyCodeLine{00289     \textcolor{comment}{//Resources in this heap must be created with D3D12\_RESOURCE\_STATE\_COPY\_DEST, and cannot be changed away from this}}
\DoxyCodeLine{00290     ThrowIfFailed(md3dDevice-\/>CreateCommittedResource(}
\DoxyCodeLine{00291         \&CD3DX12\_HEAP\_PROPERTIES(D3D12\_HEAP\_TYPE\_READBACK),}
\DoxyCodeLine{00292         D3D12\_HEAP\_FLAG\_NONE,}
\DoxyCodeLine{00293         \&CD3DX12\_RESOURCE\_DESC::Buffer(byteSize),}
\DoxyCodeLine{00294         D3D12\_RESOURCE\_STATE\_COPY\_DEST,}
\DoxyCodeLine{00295         \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00296         IID\_PPV\_ARGS(\&mReadBackBuffer)));}
\DoxyCodeLine{00297 \}}
\DoxyCodeLine{00298 }
\DoxyCodeLine{00299 \textcolor{keywordtype}{void} ParticleAddCSApp::BuildRootSignature()}
\DoxyCodeLine{00300 \{}
\DoxyCodeLine{00301 }
\DoxyCodeLine{00302 }
\DoxyCodeLine{00303     CD3DX12\_DESCRIPTOR\_RANGE uavTable0;}
\DoxyCodeLine{00304     uavTable0.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_UAV, 1, 0);}
\DoxyCodeLine{00305 }
\DoxyCodeLine{00306     CD3DX12\_DESCRIPTOR\_RANGE uavTable1;}
\DoxyCodeLine{00307     uavTable1.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_UAV, 1, 1);}
\DoxyCodeLine{00308 }
\DoxyCodeLine{00309     \textcolor{comment}{// Root parameter can be a table, root descriptor or root constants.}}
\DoxyCodeLine{00310     CD3DX12\_ROOT\_PARAMETER slotRootParameter[2];}
\DoxyCodeLine{00311 }
\DoxyCodeLine{00312     \textcolor{comment}{// Create root CBVs.}}
\DoxyCodeLine{00313     slotRootParameter[0].InitAsDescriptorTable(1, \&uavTable0);}
\DoxyCodeLine{00314     slotRootParameter[1].InitAsDescriptorTable(1, \&uavTable1);}
\DoxyCodeLine{00315 }
\DoxyCodeLine{00316 }
\DoxyCodeLine{00317     \textcolor{comment}{// A root signature is an array of root parameters.}}
\DoxyCodeLine{00318     CD3DX12\_ROOT\_SIGNATURE\_DESC rootSigDesc(2, slotRootParameter,}
\DoxyCodeLine{00319         0, \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00320         D3D12\_ROOT\_SIGNATURE\_FLAG\_NONE);}
\DoxyCodeLine{00321 }
\DoxyCodeLine{00322     \textcolor{comment}{// create a root signature with a single slot which points to a descriptor range consisting of a single constant buffer}}
\DoxyCodeLine{00323     ComPtr<ID3DBlob> serializedRootSig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00324     ComPtr<ID3DBlob> errorBlob = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00325 }
\DoxyCodeLine{00326 }
\DoxyCodeLine{00327     HRESULT hr = D3D12SerializeRootSignature(\&rootSigDesc, D3D\_ROOT\_SIGNATURE\_VERSION\_1,}
\DoxyCodeLine{00328         serializedRootSig.GetAddressOf(), errorBlob.GetAddressOf());}
\DoxyCodeLine{00329 }
\DoxyCodeLine{00330     \textcolor{keywordflow}{if} (errorBlob != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00331     \{}
\DoxyCodeLine{00332         ::OutputDebugStringA((\textcolor{keywordtype}{char}*)errorBlob-\/>GetBufferPointer());}
\DoxyCodeLine{00333     \}}
\DoxyCodeLine{00334     ThrowIfFailed(hr);}
\DoxyCodeLine{00335 }
\DoxyCodeLine{00336     ThrowIfFailed(md3dDevice-\/>CreateRootSignature(}
\DoxyCodeLine{00337         0,}
\DoxyCodeLine{00338         serializedRootSig-\/>GetBufferPointer(),}
\DoxyCodeLine{00339         serializedRootSig-\/>GetBufferSize(),}
\DoxyCodeLine{00340         IID\_PPV\_ARGS(mRootSignature.GetAddressOf())));}
\DoxyCodeLine{00341 \}}
\DoxyCodeLine{00342 }
\DoxyCodeLine{00343 }
\DoxyCodeLine{00344 \textcolor{keywordtype}{void} ParticleAddCSApp::BuildShadersAndInputLayout()}
\DoxyCodeLine{00345 \{}
\DoxyCodeLine{00346     mShaders[\textcolor{stringliteral}{"{}particleAddCS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)ParticleAdd.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}CS"{}}, \textcolor{stringliteral}{"{}cs\_5\_1"{}});}
\DoxyCodeLine{00347 \}}
\DoxyCodeLine{00348 }
\DoxyCodeLine{00349 \textcolor{keywordtype}{void} ParticleAddCSApp::BuildPSOs()}
\DoxyCodeLine{00350 \{}
\DoxyCodeLine{00351     D3D12\_COMPUTE\_PIPELINE\_STATE\_DESC computePsoDesc = \{\};}
\DoxyCodeLine{00352     computePsoDesc.pRootSignature = mRootSignature.Get();}
\DoxyCodeLine{00353     computePsoDesc.CS =}
\DoxyCodeLine{00354     \{}
\DoxyCodeLine{00355         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}particleAddCS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00356         mShaders[\textcolor{stringliteral}{"{}particleAddCS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00357     \};}
\DoxyCodeLine{00358     computePsoDesc.Flags = D3D12\_PIPELINE\_STATE\_FLAG\_NONE;}
\DoxyCodeLine{00359     ThrowIfFailed(md3dDevice-\/>CreateComputePipelineState(\&computePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}particleAdd"{}}])));}
\DoxyCodeLine{00360 \}}
\DoxyCodeLine{00361 }
\DoxyCodeLine{00362 }
\DoxyCodeLine{00363 \textcolor{keywordtype}{void} ParticleAddCSApp::BuildDescriptorHeaps()}
\DoxyCodeLine{00364 }
\DoxyCodeLine{00365 \{}
\DoxyCodeLine{00366 }
\DoxyCodeLine{00367     D3D12\_DESCRIPTOR\_HEAP\_DESC uavHeapDesc;}
\DoxyCodeLine{00368 }
\DoxyCodeLine{00369     uavHeapDesc.NumDescriptors = 2;}
\DoxyCodeLine{00370 }
\DoxyCodeLine{00371     uavHeapDesc.Type = D3D12\_DESCRIPTOR\_HEAP\_TYPE\_CBV\_SRV\_UAV;}
\DoxyCodeLine{00372 }
\DoxyCodeLine{00373     uavHeapDesc.Flags = D3D12\_DESCRIPTOR\_HEAP\_FLAG\_SHADER\_VISIBLE;}
\DoxyCodeLine{00374 }
\DoxyCodeLine{00375     uavHeapDesc.NodeMask = 0;}
\DoxyCodeLine{00376 }
\DoxyCodeLine{00377     ThrowIfFailed(md3dDevice-\/>CreateDescriptorHeap(\&uavHeapDesc, IID\_PPV\_ARGS(\&mUavHeap)));}
\DoxyCodeLine{00378 }
\DoxyCodeLine{00379 \}}
\DoxyCodeLine{00380 }
\DoxyCodeLine{00381 }
\DoxyCodeLine{00382 \textcolor{keywordtype}{void} ParticleAddCSApp::BuildDescriptors()}
\DoxyCodeLine{00383 \{}
\DoxyCodeLine{00384 }
\DoxyCodeLine{00385     CD3DX12\_CPU\_DESCRIPTOR\_HANDLE hDescriptor(mUavHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00386 }
\DoxyCodeLine{00387 }
\DoxyCodeLine{00388     D3D12\_UNORDERED\_ACCESS\_VIEW\_DESC uavDesc = \{\};}
\DoxyCodeLine{00389     uavDesc.Format = DXGI\_FORMAT\_UNKNOWN;}
\DoxyCodeLine{00390     uavDesc.ViewDimension = D3D12\_UAV\_DIMENSION\_BUFFER;}
\DoxyCodeLine{00391     uavDesc.Buffer.FirstElement = 0;  \textcolor{comment}{//The zero-\/based index of the first element to be accessed.}}
\DoxyCodeLine{00392     uavDesc.Buffer.NumElements = 256;  \textcolor{comment}{//Count! The number of elements in the resource. For structured buffers, this is the number of structures in the buffer.}}
\DoxyCodeLine{00393     uavDesc.Buffer.StructureByteStride = 36;  \textcolor{comment}{//The size of each element in the buffer structure (in bytes) when the buffer represents a structured buffer}}
\DoxyCodeLine{00394     uavDesc.Buffer.CounterOffsetInBytes = 4096; \textcolor{comment}{//CounterOffsetInBytes must be a multiple of 4096}}
\DoxyCodeLine{00395     uavDesc.Buffer.Flags = D3D12\_BUFFER\_UAV\_FLAG\_NONE;}
\DoxyCodeLine{00396 }
\DoxyCodeLine{00397 }
\DoxyCodeLine{00398     md3dDevice-\/>CreateUnorderedAccessView(mInputBufferA.Get(), mInputBufferA.Get(), \&uavDesc, hDescriptor);}
\DoxyCodeLine{00399 }
\DoxyCodeLine{00400 }
\DoxyCodeLine{00401     \textcolor{comment}{//D3D12\_UNORDERED\_ACCESS\_VIEW\_DESC uavDesc1 = \{\};}}
\DoxyCodeLine{00402     \textcolor{comment}{//uavDesc1.Format = DXGI\_FORMAT\_UNKNOWN;}}
\DoxyCodeLine{00403     \textcolor{comment}{//uavDesc1.ViewDimension = D3D12\_UAV\_DIMENSION\_BUFFER;}}
\DoxyCodeLine{00404     \textcolor{comment}{//uavDesc1.Buffer.FirstElement = 0;  //The zero-\/based index of the first element to be accessed.}}
\DoxyCodeLine{00405     \textcolor{comment}{//uavDesc1.Buffer.NumElements = 1;  //Count! The number of elements in the resource. For structured buffers, this is the number of structures in the buffer.}}
\DoxyCodeLine{00406     \textcolor{comment}{//uavDesc1.Buffer.StructureByteStride = 36;  //The size of each element in the buffer structure (in bytes) when the buffer represents a structured buffer}}
\DoxyCodeLine{00407     \textcolor{comment}{//uavDesc1.Buffer.CounterOffsetInBytes = 4096; //CounterOffsetInBytes must be a multiple of 4096}}
\DoxyCodeLine{00408     \textcolor{comment}{//uavDesc1.Buffer.Flags = D3D12\_BUFFER\_UAV\_FLAG\_NONE;}}
\DoxyCodeLine{00409     md3dDevice-\/>CreateUnorderedAccessView(mOutputBuffer.Get(), mOutputBuffer.Get(), \&uavDesc, hDescriptor.Offset(1, mCbvSrvUavDescriptorSize));}
\DoxyCodeLine{00410 }
\DoxyCodeLine{00411 \}}
\DoxyCodeLine{00412 }
\DoxyCodeLine{00413 }

\end{DoxyCode}
