\doxysection{Skinned\+Mesh\+App.\+cpp}
\label{_skinned_mesh_app_8cpp_source}\index{Week15/SkinnedMesh/SkinnedMeshApp.cpp@{Week15/SkinnedMesh/SkinnedMeshApp.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00002 \textcolor{comment}{// SkinnedMeshApp.cpp by Frank Luna (C) 2015 All Rights Reserved.}}
\DoxyCodeLine{00003 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00004 }
\DoxyCodeLine{00005 \textcolor{preprocessor}{\#include "{}../../Common/d3dApp.h"{}}}
\DoxyCodeLine{00006 \textcolor{preprocessor}{\#include "{}../../Common/MathHelper.h"{}}}
\DoxyCodeLine{00007 \textcolor{preprocessor}{\#include "{}../../Common/UploadBuffer.h"{}}}
\DoxyCodeLine{00008 \textcolor{preprocessor}{\#include "{}../../Common/GeometryGenerator.h"{}}}
\DoxyCodeLine{00009 \textcolor{preprocessor}{\#include "{}../../Common/Camera.h"{}}}
\DoxyCodeLine{00010 \textcolor{preprocessor}{\#include "{}FrameResource.h"{}}}
\DoxyCodeLine{00011 \textcolor{preprocessor}{\#include "{}ShadowMap.h"{}}}
\DoxyCodeLine{00012 \textcolor{preprocessor}{\#include "{}Ssao.h"{}}}
\DoxyCodeLine{00013 \textcolor{preprocessor}{\#include "{}SkinnedData.h"{}}}
\DoxyCodeLine{00014 \textcolor{preprocessor}{\#include "{}LoadM3d.h"{}}}
\DoxyCodeLine{00015 }
\DoxyCodeLine{00016 \textcolor{keyword}{using} Microsoft::WRL::ComPtr;}
\DoxyCodeLine{00017 \textcolor{keyword}{using namespace }DirectX;}
\DoxyCodeLine{00018 \textcolor{keyword}{using namespace }DirectX::PackedVector;}
\DoxyCodeLine{00019 }
\DoxyCodeLine{00020 \textcolor{keyword}{const} \textcolor{keywordtype}{int} gNumFrameResources = 3;}
\DoxyCodeLine{00021 }
\DoxyCodeLine{00022 \textcolor{keyword}{struct }SkinnedModelInstance}
\DoxyCodeLine{00023 \{}
\DoxyCodeLine{00024     SkinnedData* SkinnedInfo = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00025     std::vector<DirectX::XMFLOAT4X4> FinalTransforms;}
\DoxyCodeLine{00026     std::string ClipName;}
\DoxyCodeLine{00027     \textcolor{keywordtype}{float} TimePos = 0.0f;}
\DoxyCodeLine{00028 }
\DoxyCodeLine{00029     \textcolor{comment}{// Called every frame and increments the time position, interpolates the }}
\DoxyCodeLine{00030     \textcolor{comment}{// animations for each bone based on the current animation clip, and }}
\DoxyCodeLine{00031     \textcolor{comment}{// generates the final transforms which are ultimately set to the effect}}
\DoxyCodeLine{00032     \textcolor{comment}{// for processing in the vertex shader.}}
\DoxyCodeLine{00033     \textcolor{keywordtype}{void} UpdateSkinnedAnimation(\textcolor{keywordtype}{float} dt)}
\DoxyCodeLine{00034     \{}
\DoxyCodeLine{00035         TimePos += dt;}
\DoxyCodeLine{00036 }
\DoxyCodeLine{00037         \textcolor{comment}{// Loop animation}}
\DoxyCodeLine{00038         \textcolor{keywordflow}{if}(TimePos > SkinnedInfo-\/>GetClipEndTime(ClipName))}
\DoxyCodeLine{00039             TimePos = 0.0f;}
\DoxyCodeLine{00040 }
\DoxyCodeLine{00041         \textcolor{comment}{// Compute the final transforms for this time position.}}
\DoxyCodeLine{00042         SkinnedInfo-\/>GetFinalTransforms(ClipName, TimePos, FinalTransforms);}
\DoxyCodeLine{00043     \}}
\DoxyCodeLine{00044 \};}
\DoxyCodeLine{00045 }
\DoxyCodeLine{00046 \textcolor{comment}{// Lightweight structure stores parameters to draw a shape.  This will}}
\DoxyCodeLine{00047 \textcolor{comment}{// vary from app-\/to-\/app.}}
\DoxyCodeLine{00048 \textcolor{keyword}{struct }RenderItem}
\DoxyCodeLine{00049 \{}
\DoxyCodeLine{00050     RenderItem() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{00051     RenderItem(\textcolor{keyword}{const} RenderItem\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00052  }
\DoxyCodeLine{00053     \textcolor{comment}{// World matrix of the shape that describes the object's local space}}
\DoxyCodeLine{00054     \textcolor{comment}{// relative to the world space, which defines the position, orientation,}}
\DoxyCodeLine{00055     \textcolor{comment}{// and scale of the object in the world.}}
\DoxyCodeLine{00056     XMFLOAT4X4 World = MathHelper::Identity4x4();}
\DoxyCodeLine{00057 }
\DoxyCodeLine{00058     XMFLOAT4X4 TexTransform = MathHelper::Identity4x4();}
\DoxyCodeLine{00059 }
\DoxyCodeLine{00060     \textcolor{comment}{// Dirty flag indicating the object data has changed and we need to update the constant buffer.}}
\DoxyCodeLine{00061     \textcolor{comment}{// Because we have an object cbuffer for each FrameResource, we have to apply the}}
\DoxyCodeLine{00062     \textcolor{comment}{// update to each FrameResource.  Thus, when we modify obect data we should set }}
\DoxyCodeLine{00063     \textcolor{comment}{// NumFramesDirty = gNumFrameResources so that each frame resource gets the update.}}
\DoxyCodeLine{00064     \textcolor{keywordtype}{int} NumFramesDirty = gNumFrameResources;}
\DoxyCodeLine{00065 }
\DoxyCodeLine{00066     \textcolor{comment}{// Index into GPU constant buffer corresponding to the ObjectCB for this render item.}}
\DoxyCodeLine{00067     UINT ObjCBIndex = -\/1;}
\DoxyCodeLine{00068  }
\DoxyCodeLine{00069     Material* Mat = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00070     MeshGeometry* Geo = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00071 }
\DoxyCodeLine{00072     \textcolor{comment}{// Primitive topology.}}
\DoxyCodeLine{00073     D3D12\_PRIMITIVE\_TOPOLOGY PrimitiveType = D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{00074 }
\DoxyCodeLine{00075     \textcolor{comment}{// DrawIndexedInstanced parameters.}}
\DoxyCodeLine{00076     UINT IndexCount = 0;}
\DoxyCodeLine{00077     UINT StartIndexLocation = 0;}
\DoxyCodeLine{00078     \textcolor{keywordtype}{int} BaseVertexLocation = 0;}
\DoxyCodeLine{00079     }
\DoxyCodeLine{00080     \textcolor{comment}{// Only applicable to skinned render-\/items.}}
\DoxyCodeLine{00081     UINT SkinnedCBIndex = -\/1;}
\DoxyCodeLine{00082     }
\DoxyCodeLine{00083     \textcolor{comment}{// nullptr if this render-\/item is not animated by skinned mesh.}}
\DoxyCodeLine{00084     SkinnedModelInstance* SkinnedModelInst = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00085 \};}
\DoxyCodeLine{00086 }
\DoxyCodeLine{00087 \textcolor{keyword}{enum class} RenderLayer : int}
\DoxyCodeLine{00088 \{}
\DoxyCodeLine{00089     Opaque = 0,}
\DoxyCodeLine{00090     SkinnedOpaque,}
\DoxyCodeLine{00091     Debug,}
\DoxyCodeLine{00092     Sky,}
\DoxyCodeLine{00093     Count}
\DoxyCodeLine{00094 \};}
\DoxyCodeLine{00095 }
\DoxyCodeLine{00096 \textcolor{keyword}{class }SkinnedMeshApp : \textcolor{keyword}{public} D3DApp}
\DoxyCodeLine{00097 \{}
\DoxyCodeLine{00098 \textcolor{keyword}{public}:}
\DoxyCodeLine{00099     SkinnedMeshApp(HINSTANCE hInstance);}
\DoxyCodeLine{00100     SkinnedMeshApp(\textcolor{keyword}{const} SkinnedMeshApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00101     SkinnedMeshApp\& operator=(\textcolor{keyword}{const} SkinnedMeshApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00102     \string~SkinnedMeshApp();}
\DoxyCodeLine{00103 }
\DoxyCodeLine{00104     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} Initialize()\textcolor{keyword}{override};}
\DoxyCodeLine{00105 }
\DoxyCodeLine{00106 \textcolor{keyword}{private}:}
\DoxyCodeLine{00107     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} CreateRtvAndDsvDescriptorHeaps()\textcolor{keyword}{override};}
\DoxyCodeLine{00108     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnResize()\textcolor{keyword}{override};}
\DoxyCodeLine{00109     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Update(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00110     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Draw(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00111 }
\DoxyCodeLine{00112     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00113     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00114     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00115 }
\DoxyCodeLine{00116     \textcolor{keywordtype}{void} OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00117     \textcolor{keywordtype}{void} AnimateMaterials(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00118     \textcolor{keywordtype}{void} UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00119     \textcolor{keywordtype}{void} UpdateSkinnedCBs(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00120     \textcolor{keywordtype}{void} UpdateMaterialBuffer(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00121     \textcolor{keywordtype}{void} UpdateShadowTransform(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00122     \textcolor{keywordtype}{void} UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00123     \textcolor{keywordtype}{void} UpdateShadowPassCB(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00124     \textcolor{keywordtype}{void} UpdateSsaoCB(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00125 }
\DoxyCodeLine{00126     \textcolor{keywordtype}{void} LoadTextures();}
\DoxyCodeLine{00127     \textcolor{keywordtype}{void} BuildRootSignature();}
\DoxyCodeLine{00128     \textcolor{keywordtype}{void} BuildSsaoRootSignature();}
\DoxyCodeLine{00129     \textcolor{keywordtype}{void} BuildDescriptorHeaps();}
\DoxyCodeLine{00130     \textcolor{keywordtype}{void} BuildShadersAndInputLayout();}
\DoxyCodeLine{00131     \textcolor{keywordtype}{void} BuildShapeGeometry();}
\DoxyCodeLine{00132     \textcolor{keywordtype}{void} LoadSkinnedModel();}
\DoxyCodeLine{00133     \textcolor{keywordtype}{void} BuildPSOs();}
\DoxyCodeLine{00134     \textcolor{keywordtype}{void} BuildFrameResources();}
\DoxyCodeLine{00135     \textcolor{keywordtype}{void} BuildMaterials();}
\DoxyCodeLine{00136     \textcolor{keywordtype}{void} BuildRenderItems();}
\DoxyCodeLine{00137     \textcolor{keywordtype}{void} DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems);}
\DoxyCodeLine{00138     \textcolor{keywordtype}{void} DrawSceneToShadowMap();}
\DoxyCodeLine{00139     \textcolor{keywordtype}{void} DrawNormalsAndDepth();}
\DoxyCodeLine{00140 }
\DoxyCodeLine{00141     CD3DX12\_CPU\_DESCRIPTOR\_HANDLE GetCpuSrv(\textcolor{keywordtype}{int} index)\textcolor{keyword}{const};}
\DoxyCodeLine{00142     CD3DX12\_GPU\_DESCRIPTOR\_HANDLE GetGpuSrv(\textcolor{keywordtype}{int} index)\textcolor{keyword}{const};}
\DoxyCodeLine{00143     CD3DX12\_CPU\_DESCRIPTOR\_HANDLE GetDsv(\textcolor{keywordtype}{int} index)\textcolor{keyword}{const};}
\DoxyCodeLine{00144     CD3DX12\_CPU\_DESCRIPTOR\_HANDLE GetRtv(\textcolor{keywordtype}{int} index)\textcolor{keyword}{const};}
\DoxyCodeLine{00145 }
\DoxyCodeLine{00146     std::array<const CD3DX12\_STATIC\_SAMPLER\_DESC, 7> GetStaticSamplers();}
\DoxyCodeLine{00147 }
\DoxyCodeLine{00148 \textcolor{keyword}{private}:}
\DoxyCodeLine{00149 }
\DoxyCodeLine{00150     std::vector<std::unique\_ptr<FrameResource>> mFrameResources;}
\DoxyCodeLine{00151     FrameResource* mCurrFrameResource = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00152     \textcolor{keywordtype}{int} mCurrFrameResourceIndex = 0;}
\DoxyCodeLine{00153 }
\DoxyCodeLine{00154     ComPtr<ID3D12RootSignature> mRootSignature = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00155     ComPtr<ID3D12RootSignature> mSsaoRootSignature = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00156 }
\DoxyCodeLine{00157     ComPtr<ID3D12DescriptorHeap> mSrvDescriptorHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00158 }
\DoxyCodeLine{00159     std::unordered\_map<std::string, std::unique\_ptr<MeshGeometry>> mGeometries;}
\DoxyCodeLine{00160     std::unordered\_map<std::string, std::unique\_ptr<Material>> mMaterials;}
\DoxyCodeLine{00161     std::unordered\_map<std::string, std::unique\_ptr<Texture>> mTextures;}
\DoxyCodeLine{00162     std::unordered\_map<std::string, ComPtr<ID3DBlob>> mShaders;}
\DoxyCodeLine{00163     std::unordered\_map<std::string, ComPtr<ID3D12PipelineState>> mPSOs;}
\DoxyCodeLine{00164 }
\DoxyCodeLine{00165     std::vector<D3D12\_INPUT\_ELEMENT\_DESC> mInputLayout;}
\DoxyCodeLine{00166     std::vector<D3D12\_INPUT\_ELEMENT\_DESC> mSkinnedInputLayout;}
\DoxyCodeLine{00167  }
\DoxyCodeLine{00168     \textcolor{comment}{// List of all the render items.}}
\DoxyCodeLine{00169     std::vector<std::unique\_ptr<RenderItem>> mAllRitems;}
\DoxyCodeLine{00170 }
\DoxyCodeLine{00171     \textcolor{comment}{// Render items divided by PSO.}}
\DoxyCodeLine{00172     std::vector<RenderItem*> mRitemLayer[(int)RenderLayer::Count];}
\DoxyCodeLine{00173 }
\DoxyCodeLine{00174     UINT mSkyTexHeapIndex = 0;}
\DoxyCodeLine{00175     UINT mShadowMapHeapIndex = 0;}
\DoxyCodeLine{00176     UINT mSsaoHeapIndexStart = 0;}
\DoxyCodeLine{00177     UINT mSsaoAmbientMapIndex = 0;}
\DoxyCodeLine{00178 }
\DoxyCodeLine{00179     UINT mNullCubeSrvIndex = 0;}
\DoxyCodeLine{00180     UINT mNullTexSrvIndex1 = 0;}
\DoxyCodeLine{00181     UINT mNullTexSrvIndex2 = 0;}
\DoxyCodeLine{00182 }
\DoxyCodeLine{00183     CD3DX12\_GPU\_DESCRIPTOR\_HANDLE mNullSrv;}
\DoxyCodeLine{00184 }
\DoxyCodeLine{00185     PassConstants mMainPassCB;  \textcolor{comment}{// index 0 of pass cbuffer.}}
\DoxyCodeLine{00186     PassConstants mShadowPassCB;\textcolor{comment}{// index 1 of pass cbuffer.}}
\DoxyCodeLine{00187 }
\DoxyCodeLine{00188     UINT mSkinnedSrvHeapStart = 0;}
\DoxyCodeLine{00189     std::string mSkinnedModelFilename = \textcolor{stringliteral}{"{}Models\(\backslash\)\(\backslash\)soldier.m3d"{}};}
\DoxyCodeLine{00190     std::unique\_ptr<SkinnedModelInstance> mSkinnedModelInst; }
\DoxyCodeLine{00191     SkinnedData mSkinnedInfo;}
\DoxyCodeLine{00192     std::vector<M3DLoader::Subset> mSkinnedSubsets;}
\DoxyCodeLine{00193     std::vector<M3DLoader::M3dMaterial> mSkinnedMats;}
\DoxyCodeLine{00194     std::vector<std::string> mSkinnedTextureNames;}
\DoxyCodeLine{00195 }
\DoxyCodeLine{00196     Camera mCamera;}
\DoxyCodeLine{00197 }
\DoxyCodeLine{00198     std::unique\_ptr<ShadowMap> mShadowMap;}
\DoxyCodeLine{00199 }
\DoxyCodeLine{00200     std::unique\_ptr<Ssao> mSsao;}
\DoxyCodeLine{00201 }
\DoxyCodeLine{00202     DirectX::BoundingSphere mSceneBounds;}
\DoxyCodeLine{00203 }
\DoxyCodeLine{00204     \textcolor{keywordtype}{float} mLightNearZ = 0.0f;}
\DoxyCodeLine{00205     \textcolor{keywordtype}{float} mLightFarZ = 0.0f;}
\DoxyCodeLine{00206     XMFLOAT3 mLightPosW;}
\DoxyCodeLine{00207     XMFLOAT4X4 mLightView = MathHelper::Identity4x4();}
\DoxyCodeLine{00208     XMFLOAT4X4 mLightProj = MathHelper::Identity4x4();}
\DoxyCodeLine{00209     XMFLOAT4X4 mShadowTransform = MathHelper::Identity4x4();}
\DoxyCodeLine{00210 }
\DoxyCodeLine{00211     \textcolor{keywordtype}{float} mLightRotationAngle = 0.0f;}
\DoxyCodeLine{00212     XMFLOAT3 mBaseLightDirections[3] = \{}
\DoxyCodeLine{00213         XMFLOAT3(0.57735f, -\/0.57735f, 0.57735f),}
\DoxyCodeLine{00214         XMFLOAT3(-\/0.57735f, -\/0.57735f, 0.57735f),}
\DoxyCodeLine{00215         XMFLOAT3(0.0f, -\/0.707f, -\/0.707f)}
\DoxyCodeLine{00216     \};}
\DoxyCodeLine{00217     XMFLOAT3 mRotatedLightDirections[3];}
\DoxyCodeLine{00218 }
\DoxyCodeLine{00219     POINT mLastMousePos;}
\DoxyCodeLine{00220 \};}
\DoxyCodeLine{00221 }
\DoxyCodeLine{00222 \textcolor{keywordtype}{int} WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance,}
\DoxyCodeLine{00223     PSTR cmdLine, \textcolor{keywordtype}{int} showCmd)}
\DoxyCodeLine{00224 \{}
\DoxyCodeLine{00225     \textcolor{comment}{// Enable run-\/time memory check for debug builds.}}
\DoxyCodeLine{00226 \textcolor{preprocessor}{\#if defined(DEBUG) | defined(\_DEBUG)}}
\DoxyCodeLine{00227     \_CrtSetDbgFlag(\_CRTDBG\_ALLOC\_MEM\_DF | \_CRTDBG\_LEAK\_CHECK\_DF);}
\DoxyCodeLine{00228 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00229 }
\DoxyCodeLine{00230     \textcolor{keywordflow}{try}}
\DoxyCodeLine{00231     \{}
\DoxyCodeLine{00232         SkinnedMeshApp theApp(hInstance);}
\DoxyCodeLine{00233         \textcolor{keywordflow}{if}(!theApp.Initialize())}
\DoxyCodeLine{00234             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00235 }
\DoxyCodeLine{00236         \textcolor{keywordflow}{return} theApp.Run();}
\DoxyCodeLine{00237     \}}
\DoxyCodeLine{00238     \textcolor{keywordflow}{catch}(DxException\& e)}
\DoxyCodeLine{00239     \{}
\DoxyCodeLine{00240         MessageBox(\textcolor{keyword}{nullptr}, e.ToString().c\_str(), L\textcolor{stringliteral}{"{}HR Failed"{}}, MB\_OK);}
\DoxyCodeLine{00241         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00242     \}}
\DoxyCodeLine{00243 \}}
\DoxyCodeLine{00244 }
\DoxyCodeLine{00245 SkinnedMeshApp::SkinnedMeshApp(HINSTANCE hInstance)}
\DoxyCodeLine{00246     : D3DApp(hInstance)}
\DoxyCodeLine{00247 \{}
\DoxyCodeLine{00248     \textcolor{comment}{// Estimate the scene bounding sphere manually since we know how the scene was constructed.}}
\DoxyCodeLine{00249     \textcolor{comment}{// The grid is the "{}widest object"{} with a width of 20 and depth of 30.0f, and centered at}}
\DoxyCodeLine{00250     \textcolor{comment}{// the world space origin.  In general, you need to loop over every world space vertex}}
\DoxyCodeLine{00251     \textcolor{comment}{// position and compute the bounding sphere.}}
\DoxyCodeLine{00252     mSceneBounds.Center = XMFLOAT3(0.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00253     mSceneBounds.Radius = sqrtf(10.0f*10.0f + 15.0f*15.0f);}
\DoxyCodeLine{00254 \}}
\DoxyCodeLine{00255 }
\DoxyCodeLine{00256 SkinnedMeshApp::\string~SkinnedMeshApp()}
\DoxyCodeLine{00257 \{}
\DoxyCodeLine{00258     \textcolor{keywordflow}{if}(md3dDevice != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00259         FlushCommandQueue();}
\DoxyCodeLine{00260 \}}
\DoxyCodeLine{00261 }
\DoxyCodeLine{00262 \textcolor{keywordtype}{bool} SkinnedMeshApp::Initialize()}
\DoxyCodeLine{00263 \{}
\DoxyCodeLine{00264     \textcolor{keywordflow}{if}(!D3DApp::Initialize())}
\DoxyCodeLine{00265         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00266 }
\DoxyCodeLine{00267     \textcolor{comment}{// Reset the command list to prep for initialization commands.}}
\DoxyCodeLine{00268     ThrowIfFailed(mCommandList-\/>Reset(mDirectCmdListAlloc.Get(), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{00269 }
\DoxyCodeLine{00270     mCamera.SetPosition(0.0f, 2.0f, -\/15.0f);}
\DoxyCodeLine{00271  }
\DoxyCodeLine{00272     mShadowMap = std::make\_unique<ShadowMap>(md3dDevice.Get(),}
\DoxyCodeLine{00273         2048, 2048);}
\DoxyCodeLine{00274 }
\DoxyCodeLine{00275     mSsao = std::make\_unique<Ssao>(}
\DoxyCodeLine{00276         md3dDevice.Get(),}
\DoxyCodeLine{00277         mCommandList.Get(),}
\DoxyCodeLine{00278         mClientWidth, mClientHeight);}
\DoxyCodeLine{00279 }
\DoxyCodeLine{00280     LoadSkinnedModel();}
\DoxyCodeLine{00281     LoadTextures();}
\DoxyCodeLine{00282     BuildRootSignature();}
\DoxyCodeLine{00283     BuildSsaoRootSignature();}
\DoxyCodeLine{00284     BuildDescriptorHeaps();}
\DoxyCodeLine{00285     BuildShadersAndInputLayout();}
\DoxyCodeLine{00286     BuildShapeGeometry();}
\DoxyCodeLine{00287     BuildMaterials();}
\DoxyCodeLine{00288     BuildRenderItems();}
\DoxyCodeLine{00289     BuildFrameResources();}
\DoxyCodeLine{00290     BuildPSOs();}
\DoxyCodeLine{00291 }
\DoxyCodeLine{00292     mSsao-\/>SetPSOs(mPSOs[\textcolor{stringliteral}{"{}ssao"{}}].Get(), mPSOs[\textcolor{stringliteral}{"{}ssaoBlur"{}}].Get());}
\DoxyCodeLine{00293 }
\DoxyCodeLine{00294     \textcolor{comment}{// Execute the initialization commands.}}
\DoxyCodeLine{00295     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00296     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00297     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00298 }
\DoxyCodeLine{00299     \textcolor{comment}{// Wait until initialization is complete.}}
\DoxyCodeLine{00300     FlushCommandQueue();}
\DoxyCodeLine{00301 }
\DoxyCodeLine{00302     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00303 \}}
\DoxyCodeLine{00304 }
\DoxyCodeLine{00305 \textcolor{keywordtype}{void} SkinnedMeshApp::CreateRtvAndDsvDescriptorHeaps()}
\DoxyCodeLine{00306 \{}
\DoxyCodeLine{00307     \textcolor{comment}{// Add +1 for screen normal map, +2 for ambient maps.}}
\DoxyCodeLine{00308     D3D12\_DESCRIPTOR\_HEAP\_DESC rtvHeapDesc;}
\DoxyCodeLine{00309     rtvHeapDesc.NumDescriptors = SwapChainBufferCount + 3;}
\DoxyCodeLine{00310     rtvHeapDesc.Type = D3D12\_DESCRIPTOR\_HEAP\_TYPE\_RTV;}
\DoxyCodeLine{00311     rtvHeapDesc.Flags = D3D12\_DESCRIPTOR\_HEAP\_FLAG\_NONE;}
\DoxyCodeLine{00312     rtvHeapDesc.NodeMask = 0;}
\DoxyCodeLine{00313     ThrowIfFailed(md3dDevice-\/>CreateDescriptorHeap(}
\DoxyCodeLine{00314         \&rtvHeapDesc, IID\_PPV\_ARGS(mRtvHeap.GetAddressOf())));}
\DoxyCodeLine{00315 }
\DoxyCodeLine{00316     \textcolor{comment}{// Add +1 DSV for shadow map.}}
\DoxyCodeLine{00317     D3D12\_DESCRIPTOR\_HEAP\_DESC dsvHeapDesc;}
\DoxyCodeLine{00318     dsvHeapDesc.NumDescriptors = 2;}
\DoxyCodeLine{00319     dsvHeapDesc.Type = D3D12\_DESCRIPTOR\_HEAP\_TYPE\_DSV;}
\DoxyCodeLine{00320     dsvHeapDesc.Flags = D3D12\_DESCRIPTOR\_HEAP\_FLAG\_NONE;}
\DoxyCodeLine{00321     dsvHeapDesc.NodeMask = 0;}
\DoxyCodeLine{00322     ThrowIfFailed(md3dDevice-\/>CreateDescriptorHeap(}
\DoxyCodeLine{00323         \&dsvHeapDesc, IID\_PPV\_ARGS(mDsvHeap.GetAddressOf())));}
\DoxyCodeLine{00324 \}}
\DoxyCodeLine{00325  }
\DoxyCodeLine{00326 \textcolor{keywordtype}{void} SkinnedMeshApp::OnResize()}
\DoxyCodeLine{00327 \{}
\DoxyCodeLine{00328     D3DApp::OnResize();}
\DoxyCodeLine{00329 }
\DoxyCodeLine{00330     mCamera.SetLens(0.25f*MathHelper::Pi, AspectRatio(), 1.0f, 1000.0f);}
\DoxyCodeLine{00331 }
\DoxyCodeLine{00332     \textcolor{keywordflow}{if}(mSsao != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00333     \{}
\DoxyCodeLine{00334         mSsao-\/>OnResize(mClientWidth, mClientHeight);}
\DoxyCodeLine{00335 }
\DoxyCodeLine{00336         \textcolor{comment}{// Resources changed, so need to rebuild descriptors.}}
\DoxyCodeLine{00337         mSsao-\/>RebuildDescriptors(mDepthStencilBuffer.Get());}
\DoxyCodeLine{00338     \}}
\DoxyCodeLine{00339 \}}
\DoxyCodeLine{00340 }
\DoxyCodeLine{00341 \textcolor{keywordtype}{void} SkinnedMeshApp::Update(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00342 \{}
\DoxyCodeLine{00343     OnKeyboardInput(gt);}
\DoxyCodeLine{00344 }
\DoxyCodeLine{00345     \textcolor{comment}{// Cycle through the circular frame resource array.}}
\DoxyCodeLine{00346     mCurrFrameResourceIndex = (mCurrFrameResourceIndex + 1) \% gNumFrameResources;}
\DoxyCodeLine{00347     mCurrFrameResource = mFrameResources[mCurrFrameResourceIndex].get();}
\DoxyCodeLine{00348 }
\DoxyCodeLine{00349     \textcolor{comment}{// Has the GPU finished processing the commands of the current frame resource?}}
\DoxyCodeLine{00350     \textcolor{comment}{// If not, wait until the GPU has completed commands up to this fence point.}}
\DoxyCodeLine{00351     \textcolor{keywordflow}{if}(mCurrFrameResource-\/>Fence != 0 \&\& mFence-\/>GetCompletedValue() < mCurrFrameResource-\/>Fence)}
\DoxyCodeLine{00352     \{}
\DoxyCodeLine{00353         HANDLE eventHandle = CreateEventEx(\textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr}, \textcolor{keyword}{false}, EVENT\_ALL\_ACCESS);}
\DoxyCodeLine{00354         ThrowIfFailed(mFence-\/>SetEventOnCompletion(mCurrFrameResource-\/>Fence, eventHandle));}
\DoxyCodeLine{00355         WaitForSingleObject(eventHandle, INFINITE);}
\DoxyCodeLine{00356         CloseHandle(eventHandle);}
\DoxyCodeLine{00357     \}}
\DoxyCodeLine{00358 }
\DoxyCodeLine{00359     \textcolor{comment}{//}}
\DoxyCodeLine{00360     \textcolor{comment}{// Animate the lights (and hence shadows).}}
\DoxyCodeLine{00361     \textcolor{comment}{//}}
\DoxyCodeLine{00362 }
\DoxyCodeLine{00363     mLightRotationAngle += 0.1f*gt.DeltaTime();}
\DoxyCodeLine{00364 }
\DoxyCodeLine{00365     XMMATRIX R = XMMatrixRotationY(mLightRotationAngle);}
\DoxyCodeLine{00366     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 3; ++i)}
\DoxyCodeLine{00367     \{}
\DoxyCodeLine{00368         XMVECTOR lightDir = XMLoadFloat3(\&mBaseLightDirections[i]);}
\DoxyCodeLine{00369         lightDir = XMVector3TransformNormal(lightDir, R);}
\DoxyCodeLine{00370         XMStoreFloat3(\&mRotatedLightDirections[i], lightDir);}
\DoxyCodeLine{00371     \}}
\DoxyCodeLine{00372  }
\DoxyCodeLine{00373     AnimateMaterials(gt);}
\DoxyCodeLine{00374     UpdateObjectCBs(gt);}
\DoxyCodeLine{00375     UpdateSkinnedCBs(gt);}
\DoxyCodeLine{00376     UpdateMaterialBuffer(gt);}
\DoxyCodeLine{00377     UpdateShadowTransform(gt);}
\DoxyCodeLine{00378     UpdateMainPassCB(gt);}
\DoxyCodeLine{00379     UpdateShadowPassCB(gt);}
\DoxyCodeLine{00380     UpdateSsaoCB(gt);}
\DoxyCodeLine{00381 \}}
\DoxyCodeLine{00382 }
\DoxyCodeLine{00383 \textcolor{keywordtype}{void} SkinnedMeshApp::Draw(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00384 \{}
\DoxyCodeLine{00385     \textcolor{keyword}{auto} cmdListAlloc = mCurrFrameResource-\/>CmdListAlloc;}
\DoxyCodeLine{00386 }
\DoxyCodeLine{00387     \textcolor{comment}{// Reuse the memory associated with command recording.}}
\DoxyCodeLine{00388     \textcolor{comment}{// We can only reset when the associated command lists have finished execution on the GPU.}}
\DoxyCodeLine{00389     ThrowIfFailed(cmdListAlloc-\/>Reset());}
\DoxyCodeLine{00390 }
\DoxyCodeLine{00391     \textcolor{comment}{// A command list can be reset after it has been added to the command queue via ExecuteCommandList.}}
\DoxyCodeLine{00392     \textcolor{comment}{// Reusing the command list reuses memory.}}
\DoxyCodeLine{00393     ThrowIfFailed(mCommandList-\/>Reset(cmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}opaque"{}}].Get()));}
\DoxyCodeLine{00394 }
\DoxyCodeLine{00395     ID3D12DescriptorHeap* descriptorHeaps[] = \{ mSrvDescriptorHeap.Get() \};}
\DoxyCodeLine{00396     mCommandList-\/>SetDescriptorHeaps(\_countof(descriptorHeaps), descriptorHeaps);}
\DoxyCodeLine{00397 }
\DoxyCodeLine{00398     mCommandList-\/>SetGraphicsRootSignature(mRootSignature.Get());}
\DoxyCodeLine{00399 }
\DoxyCodeLine{00400     \textcolor{comment}{//}}
\DoxyCodeLine{00401     \textcolor{comment}{// Shadow map pass.}}
\DoxyCodeLine{00402     \textcolor{comment}{//}}
\DoxyCodeLine{00403 }
\DoxyCodeLine{00404     \textcolor{comment}{// Bind all the materials used in this scene.  For structured buffers, we can bypass the heap and }}
\DoxyCodeLine{00405     \textcolor{comment}{// set as a root descriptor.}}
\DoxyCodeLine{00406     \textcolor{keyword}{auto} matBuffer = mCurrFrameResource-\/>MaterialBuffer-\/>Resource();}
\DoxyCodeLine{00407     mCommandList-\/>SetGraphicsRootShaderResourceView(3, matBuffer-\/>GetGPUVirtualAddress());}
\DoxyCodeLine{00408     }
\DoxyCodeLine{00409     \textcolor{comment}{// Bind null SRV for shadow map pass.}}
\DoxyCodeLine{00410     mCommandList-\/>SetGraphicsRootDescriptorTable(4, mNullSrv);   }
\DoxyCodeLine{00411 }
\DoxyCodeLine{00412     \textcolor{comment}{// Bind all the textures used in this scene.  Observe}}
\DoxyCodeLine{00413     \textcolor{comment}{// that we only have to specify the first descriptor in the table.  }}
\DoxyCodeLine{00414     \textcolor{comment}{// The root signature knows how many descriptors are expected in the table.}}
\DoxyCodeLine{00415     mCommandList-\/>SetGraphicsRootDescriptorTable(5, mSrvDescriptorHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00416 }
\DoxyCodeLine{00417     DrawSceneToShadowMap();}
\DoxyCodeLine{00418 }
\DoxyCodeLine{00419     \textcolor{comment}{//}}
\DoxyCodeLine{00420     \textcolor{comment}{// Normal/depth pass.}}
\DoxyCodeLine{00421     \textcolor{comment}{//}}
\DoxyCodeLine{00422     }
\DoxyCodeLine{00423     DrawNormalsAndDepth();}
\DoxyCodeLine{00424     }
\DoxyCodeLine{00425     \textcolor{comment}{//}}
\DoxyCodeLine{00426     \textcolor{comment}{//}}
\DoxyCodeLine{00427     \textcolor{comment}{// }}
\DoxyCodeLine{00428     }
\DoxyCodeLine{00429     mCommandList-\/>SetGraphicsRootSignature(mSsaoRootSignature.Get());}
\DoxyCodeLine{00430     mSsao-\/>ComputeSsao(mCommandList.Get(), mCurrFrameResource, 2);}
\DoxyCodeLine{00431     }
\DoxyCodeLine{00432     \textcolor{comment}{//}}
\DoxyCodeLine{00433     \textcolor{comment}{// Main rendering pass.}}
\DoxyCodeLine{00434     \textcolor{comment}{//}}
\DoxyCodeLine{00435     }
\DoxyCodeLine{00436     mCommandList-\/>SetGraphicsRootSignature(mRootSignature.Get());}
\DoxyCodeLine{00437 }
\DoxyCodeLine{00438     \textcolor{comment}{// Rebind state whenever graphics root signature changes.}}
\DoxyCodeLine{00439 }
\DoxyCodeLine{00440     \textcolor{comment}{// Bind all the materials used in this scene.  For structured buffers, we can bypass the heap and }}
\DoxyCodeLine{00441     \textcolor{comment}{// set as a root descriptor.}}
\DoxyCodeLine{00442     matBuffer = mCurrFrameResource-\/>MaterialBuffer-\/>Resource();}
\DoxyCodeLine{00443     mCommandList-\/>SetGraphicsRootShaderResourceView(3, matBuffer-\/>GetGPUVirtualAddress());}
\DoxyCodeLine{00444 }
\DoxyCodeLine{00445 }
\DoxyCodeLine{00446     mCommandList-\/>RSSetViewports(1, \&mScreenViewport);}
\DoxyCodeLine{00447     mCommandList-\/>RSSetScissorRects(1, \&mScissorRect);}
\DoxyCodeLine{00448 }
\DoxyCodeLine{00449     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00450     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00451         D3D12\_RESOURCE\_STATE\_PRESENT, D3D12\_RESOURCE\_STATE\_RENDER\_TARGET));}
\DoxyCodeLine{00452 }
\DoxyCodeLine{00453     \textcolor{comment}{// Clear the back buffer and depth buffer.}}
\DoxyCodeLine{00454     mCommandList-\/>ClearRenderTargetView(CurrentBackBufferView(), Colors::LightSteelBlue, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00455     mCommandList-\/>ClearDepthStencilView(DepthStencilView(), D3D12\_CLEAR\_FLAG\_DEPTH | D3D12\_CLEAR\_FLAG\_STENCIL, 1.0f, 0, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00456 }
\DoxyCodeLine{00457     \textcolor{comment}{// Specify the buffers we are going to render to.}}
\DoxyCodeLine{00458     mCommandList-\/>OMSetRenderTargets(1, \&CurrentBackBufferView(), \textcolor{keyword}{true}, \&DepthStencilView());}
\DoxyCodeLine{00459 }
\DoxyCodeLine{00460     \textcolor{comment}{// Bind all the textures used in this scene.  Observe}}
\DoxyCodeLine{00461     \textcolor{comment}{// that we only have to specify the first descriptor in the table.  }}
\DoxyCodeLine{00462     \textcolor{comment}{// The root signature knows how many descriptors are expected in the table.}}
\DoxyCodeLine{00463     mCommandList-\/>SetGraphicsRootDescriptorTable(5, mSrvDescriptorHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00464     }
\DoxyCodeLine{00465     \textcolor{keyword}{auto} passCB = mCurrFrameResource-\/>PassCB-\/>Resource();}
\DoxyCodeLine{00466     mCommandList-\/>SetGraphicsRootConstantBufferView(2, passCB-\/>GetGPUVirtualAddress());}
\DoxyCodeLine{00467 }
\DoxyCodeLine{00468     \textcolor{comment}{// Bind the sky cube map.  For our demos, we just use one "{}world"{} cube map representing the environment}}
\DoxyCodeLine{00469     \textcolor{comment}{// from far away, so all objects will use the same cube map and we only need to set it once per-\/frame.  }}
\DoxyCodeLine{00470     \textcolor{comment}{// If we wanted to use "{}local"{} cube maps, we would have to change them per-\/object, or dynamically}}
\DoxyCodeLine{00471     \textcolor{comment}{// index into an array of cube maps.}}
\DoxyCodeLine{00472 }
\DoxyCodeLine{00473     CD3DX12\_GPU\_DESCRIPTOR\_HANDLE skyTexDescriptor(mSrvDescriptorHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00474     skyTexDescriptor.Offset(mSkyTexHeapIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00475     mCommandList-\/>SetGraphicsRootDescriptorTable(4, skyTexDescriptor);}
\DoxyCodeLine{00476 }
\DoxyCodeLine{00477     mCommandList-\/>SetPipelineState(mPSOs[\textcolor{stringliteral}{"{}opaque"{}}].Get());}
\DoxyCodeLine{00478     DrawRenderItems(mCommandList.Get(), mRitemLayer[(\textcolor{keywordtype}{int})RenderLayer::Opaque]);}
\DoxyCodeLine{00479 }
\DoxyCodeLine{00480     mCommandList-\/>SetPipelineState(mPSOs[\textcolor{stringliteral}{"{}skinnedOpaque"{}}].Get());}
\DoxyCodeLine{00481     DrawRenderItems(mCommandList.Get(), mRitemLayer[(\textcolor{keywordtype}{int})RenderLayer::SkinnedOpaque]);}
\DoxyCodeLine{00482 }
\DoxyCodeLine{00483     mCommandList-\/>SetPipelineState(mPSOs[\textcolor{stringliteral}{"{}debug"{}}].Get());}
\DoxyCodeLine{00484     DrawRenderItems(mCommandList.Get(), mRitemLayer[(\textcolor{keywordtype}{int})RenderLayer::Debug]);}
\DoxyCodeLine{00485 }
\DoxyCodeLine{00486     mCommandList-\/>SetPipelineState(mPSOs[\textcolor{stringliteral}{"{}sky"{}}].Get());}
\DoxyCodeLine{00487     DrawRenderItems(mCommandList.Get(), mRitemLayer[(\textcolor{keywordtype}{int})RenderLayer::Sky]);}
\DoxyCodeLine{00488 }
\DoxyCodeLine{00489     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00490     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00491         D3D12\_RESOURCE\_STATE\_RENDER\_TARGET, D3D12\_RESOURCE\_STATE\_PRESENT));}
\DoxyCodeLine{00492 }
\DoxyCodeLine{00493     \textcolor{comment}{// Done recording commands.}}
\DoxyCodeLine{00494     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00495 }
\DoxyCodeLine{00496     \textcolor{comment}{// Add the command list to the queue for execution.}}
\DoxyCodeLine{00497     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00498     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00499 }
\DoxyCodeLine{00500     \textcolor{comment}{// Swap the back and front buffers}}
\DoxyCodeLine{00501     ThrowIfFailed(mSwapChain-\/>Present(0, 0));}
\DoxyCodeLine{00502     mCurrBackBuffer = (mCurrBackBuffer + 1) \% SwapChainBufferCount;}
\DoxyCodeLine{00503 }
\DoxyCodeLine{00504     \textcolor{comment}{// Advance the fence value to mark commands up to this fence point.}}
\DoxyCodeLine{00505     mCurrFrameResource-\/>Fence = ++mCurrentFence;}
\DoxyCodeLine{00506 }
\DoxyCodeLine{00507     \textcolor{comment}{// Add an instruction to the command queue to set a new fence point. }}
\DoxyCodeLine{00508     \textcolor{comment}{// Because we are on the GPU timeline, the new fence point won't be }}
\DoxyCodeLine{00509     \textcolor{comment}{// set until the GPU finishes processing all the commands prior to this Signal().}}
\DoxyCodeLine{00510     mCommandQueue-\/>Signal(mFence.Get(), mCurrentFence);}
\DoxyCodeLine{00511 \}}
\DoxyCodeLine{00512 }
\DoxyCodeLine{00513 \textcolor{keywordtype}{void} SkinnedMeshApp::OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00514 \{}
\DoxyCodeLine{00515     mLastMousePos.x = x;}
\DoxyCodeLine{00516     mLastMousePos.y = y;}
\DoxyCodeLine{00517 }
\DoxyCodeLine{00518     SetCapture(mhMainWnd);}
\DoxyCodeLine{00519 \}}
\DoxyCodeLine{00520 }
\DoxyCodeLine{00521 \textcolor{keywordtype}{void} SkinnedMeshApp::OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00522 \{}
\DoxyCodeLine{00523     ReleaseCapture();}
\DoxyCodeLine{00524 \}}
\DoxyCodeLine{00525 }
\DoxyCodeLine{00526 \textcolor{keywordtype}{void} SkinnedMeshApp::OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00527 \{}
\DoxyCodeLine{00528     \textcolor{keywordflow}{if}((btnState \& MK\_LBUTTON) != 0)}
\DoxyCodeLine{00529     \{}
\DoxyCodeLine{00530         \textcolor{comment}{// Make each pixel correspond to a quarter of a degree.}}
\DoxyCodeLine{00531         \textcolor{keywordtype}{float} dx = XMConvertToRadians(0.25f*\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x -\/ mLastMousePos.x));}
\DoxyCodeLine{00532         \textcolor{keywordtype}{float} dy = XMConvertToRadians(0.25f*\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(y -\/ mLastMousePos.y));}
\DoxyCodeLine{00533 }
\DoxyCodeLine{00534         mCamera.Pitch(dy);}
\DoxyCodeLine{00535         mCamera.RotateY(dx);}
\DoxyCodeLine{00536     \}}
\DoxyCodeLine{00537 }
\DoxyCodeLine{00538     mLastMousePos.x = x;}
\DoxyCodeLine{00539     mLastMousePos.y = y;}
\DoxyCodeLine{00540 \}}
\DoxyCodeLine{00541  }
\DoxyCodeLine{00542 \textcolor{keywordtype}{void} SkinnedMeshApp::OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00543 \{}
\DoxyCodeLine{00544     \textcolor{keyword}{const} \textcolor{keywordtype}{float} dt = gt.DeltaTime();}
\DoxyCodeLine{00545 }
\DoxyCodeLine{00546     \textcolor{keywordflow}{if}(GetAsyncKeyState(\textcolor{charliteral}{'W'}) \& 0x8000)}
\DoxyCodeLine{00547         mCamera.Walk(10.0f*dt);}
\DoxyCodeLine{00548 }
\DoxyCodeLine{00549     \textcolor{keywordflow}{if}(GetAsyncKeyState(\textcolor{charliteral}{'S'}) \& 0x8000)}
\DoxyCodeLine{00550         mCamera.Walk(-\/10.0f*dt);}
\DoxyCodeLine{00551 }
\DoxyCodeLine{00552     \textcolor{keywordflow}{if}(GetAsyncKeyState(\textcolor{charliteral}{'A'}) \& 0x8000)}
\DoxyCodeLine{00553         mCamera.Strafe(-\/10.0f*dt);}
\DoxyCodeLine{00554 }
\DoxyCodeLine{00555     \textcolor{keywordflow}{if}(GetAsyncKeyState(\textcolor{charliteral}{'D'}) \& 0x8000)}
\DoxyCodeLine{00556         mCamera.Strafe(10.0f*dt);}
\DoxyCodeLine{00557 }
\DoxyCodeLine{00558     mCamera.UpdateViewMatrix();}
\DoxyCodeLine{00559 \}}
\DoxyCodeLine{00560  }
\DoxyCodeLine{00561 \textcolor{keywordtype}{void} SkinnedMeshApp::AnimateMaterials(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00562 \{}
\DoxyCodeLine{00563     }
\DoxyCodeLine{00564 \}}
\DoxyCodeLine{00565 }
\DoxyCodeLine{00566 \textcolor{keywordtype}{void} SkinnedMeshApp::UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00567 \{}
\DoxyCodeLine{00568     \textcolor{keyword}{auto} currObjectCB = mCurrFrameResource-\/>ObjectCB.get();}
\DoxyCodeLine{00569     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& e : mAllRitems)}
\DoxyCodeLine{00570     \{}
\DoxyCodeLine{00571         \textcolor{comment}{// Only update the cbuffer data if the constants have changed.  }}
\DoxyCodeLine{00572         \textcolor{comment}{// This needs to be tracked per frame resource.}}
\DoxyCodeLine{00573         \textcolor{keywordflow}{if}(e-\/>NumFramesDirty > 0)}
\DoxyCodeLine{00574         \{}
\DoxyCodeLine{00575             XMMATRIX world = XMLoadFloat4x4(\&e-\/>World);}
\DoxyCodeLine{00576             XMMATRIX texTransform = XMLoadFloat4x4(\&e-\/>TexTransform);}
\DoxyCodeLine{00577 }
\DoxyCodeLine{00578             ObjectConstants objConstants;}
\DoxyCodeLine{00579             XMStoreFloat4x4(\&objConstants.World, XMMatrixTranspose(world));}
\DoxyCodeLine{00580             XMStoreFloat4x4(\&objConstants.TexTransform, XMMatrixTranspose(texTransform));}
\DoxyCodeLine{00581             objConstants.MaterialIndex = e-\/>Mat-\/>MatCBIndex;}
\DoxyCodeLine{00582 }
\DoxyCodeLine{00583             currObjectCB-\/>CopyData(e-\/>ObjCBIndex, objConstants);}
\DoxyCodeLine{00584 }
\DoxyCodeLine{00585             \textcolor{comment}{// Next FrameResource need to be updated too.}}
\DoxyCodeLine{00586             e-\/>NumFramesDirty-\/-\/;}
\DoxyCodeLine{00587         \}}
\DoxyCodeLine{00588     \}}
\DoxyCodeLine{00589 \}}
\DoxyCodeLine{00590 }
\DoxyCodeLine{00591 \textcolor{keywordtype}{void} SkinnedMeshApp::UpdateSkinnedCBs(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00592 \{}
\DoxyCodeLine{00593     \textcolor{keyword}{auto} currSkinnedCB = mCurrFrameResource-\/>SkinnedCB.get();}
\DoxyCodeLine{00594    }
\DoxyCodeLine{00595     \textcolor{comment}{// We only have one skinned model being animated.}}
\DoxyCodeLine{00596     mSkinnedModelInst-\/>UpdateSkinnedAnimation(gt.DeltaTime());}
\DoxyCodeLine{00597         }
\DoxyCodeLine{00598     SkinnedConstants skinnedConstants;}
\DoxyCodeLine{00599     std::copy(}
\DoxyCodeLine{00600         std::begin(mSkinnedModelInst-\/>FinalTransforms),}
\DoxyCodeLine{00601         std::end(mSkinnedModelInst-\/>FinalTransforms),}
\DoxyCodeLine{00602         \&skinnedConstants.BoneTransforms[0]);}
\DoxyCodeLine{00603 }
\DoxyCodeLine{00604     currSkinnedCB-\/>CopyData(0, skinnedConstants);}
\DoxyCodeLine{00605 \}}
\DoxyCodeLine{00606  }
\DoxyCodeLine{00607 \textcolor{keywordtype}{void} SkinnedMeshApp::UpdateMaterialBuffer(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00608 \{}
\DoxyCodeLine{00609     \textcolor{keyword}{auto} currMaterialBuffer = mCurrFrameResource-\/>MaterialBuffer.get();}
\DoxyCodeLine{00610     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& e : mMaterials)}
\DoxyCodeLine{00611     \{}
\DoxyCodeLine{00612         \textcolor{comment}{// Only update the cbuffer data if the constants have changed.  If the cbuffer}}
\DoxyCodeLine{00613         \textcolor{comment}{// data changes, it needs to be updated for each FrameResource.}}
\DoxyCodeLine{00614         Material* mat = e.second.get();}
\DoxyCodeLine{00615         \textcolor{keywordflow}{if}(mat-\/>NumFramesDirty > 0)}
\DoxyCodeLine{00616         \{}
\DoxyCodeLine{00617             XMMATRIX matTransform = XMLoadFloat4x4(\&mat-\/>MatTransform);}
\DoxyCodeLine{00618 }
\DoxyCodeLine{00619             MaterialData matData;}
\DoxyCodeLine{00620             matData.DiffuseAlbedo = mat-\/>DiffuseAlbedo;}
\DoxyCodeLine{00621             matData.FresnelR0 = mat-\/>FresnelR0;}
\DoxyCodeLine{00622             matData.Roughness = mat-\/>Roughness;}
\DoxyCodeLine{00623             XMStoreFloat4x4(\&matData.MatTransform, XMMatrixTranspose(matTransform));}
\DoxyCodeLine{00624             matData.DiffuseMapIndex = mat-\/>DiffuseSrvHeapIndex;}
\DoxyCodeLine{00625             matData.NormalMapIndex = mat-\/>NormalSrvHeapIndex;}
\DoxyCodeLine{00626 }
\DoxyCodeLine{00627             currMaterialBuffer-\/>CopyData(mat-\/>MatCBIndex, matData);}
\DoxyCodeLine{00628 }
\DoxyCodeLine{00629             \textcolor{comment}{// Next FrameResource need to be updated too.}}
\DoxyCodeLine{00630             mat-\/>NumFramesDirty-\/-\/;}
\DoxyCodeLine{00631         \}}
\DoxyCodeLine{00632     \}}
\DoxyCodeLine{00633 \}}
\DoxyCodeLine{00634 }
\DoxyCodeLine{00635 \textcolor{keywordtype}{void} SkinnedMeshApp::UpdateShadowTransform(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00636 \{}
\DoxyCodeLine{00637     \textcolor{comment}{// Only the first "{}main"{} light casts a shadow.}}
\DoxyCodeLine{00638     XMVECTOR lightDir = XMLoadFloat3(\&mRotatedLightDirections[0]);}
\DoxyCodeLine{00639     XMVECTOR lightPos = -\/2.0f*mSceneBounds.Radius*lightDir;}
\DoxyCodeLine{00640     XMVECTOR targetPos = XMLoadFloat3(\&mSceneBounds.Center);}
\DoxyCodeLine{00641     XMVECTOR lightUp = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00642     XMMATRIX lightView = XMMatrixLookAtLH(lightPos, targetPos, lightUp);}
\DoxyCodeLine{00643 }
\DoxyCodeLine{00644     XMStoreFloat3(\&mLightPosW, lightPos);}
\DoxyCodeLine{00645 }
\DoxyCodeLine{00646     \textcolor{comment}{// Transform bounding sphere to light space.}}
\DoxyCodeLine{00647     XMFLOAT3 sphereCenterLS;}
\DoxyCodeLine{00648     XMStoreFloat3(\&sphereCenterLS, XMVector3TransformCoord(targetPos, lightView));}
\DoxyCodeLine{00649 }
\DoxyCodeLine{00650     \textcolor{comment}{// Ortho frustum in light space encloses scene.}}
\DoxyCodeLine{00651     \textcolor{keywordtype}{float} l = sphereCenterLS.x -\/ mSceneBounds.Radius;}
\DoxyCodeLine{00652     \textcolor{keywordtype}{float} b = sphereCenterLS.y -\/ mSceneBounds.Radius;}
\DoxyCodeLine{00653     \textcolor{keywordtype}{float} n = sphereCenterLS.z -\/ mSceneBounds.Radius;}
\DoxyCodeLine{00654     \textcolor{keywordtype}{float} r = sphereCenterLS.x + mSceneBounds.Radius;}
\DoxyCodeLine{00655     \textcolor{keywordtype}{float} t = sphereCenterLS.y + mSceneBounds.Radius;}
\DoxyCodeLine{00656     \textcolor{keywordtype}{float} f = sphereCenterLS.z + mSceneBounds.Radius;}
\DoxyCodeLine{00657 }
\DoxyCodeLine{00658     mLightNearZ = n;}
\DoxyCodeLine{00659     mLightFarZ = f;}
\DoxyCodeLine{00660     XMMATRIX lightProj = XMMatrixOrthographicOffCenterLH(l, r, b, t, n, f);}
\DoxyCodeLine{00661 }
\DoxyCodeLine{00662     \textcolor{comment}{// Transform NDC space [-\/1,+1]\string^2 to texture space [0,1]\string^2}}
\DoxyCodeLine{00663     XMMATRIX T(}
\DoxyCodeLine{00664         0.5f, 0.0f, 0.0f, 0.0f,}
\DoxyCodeLine{00665         0.0f, -\/0.5f, 0.0f, 0.0f,}
\DoxyCodeLine{00666         0.0f, 0.0f, 1.0f, 0.0f,}
\DoxyCodeLine{00667         0.5f, 0.5f, 0.0f, 1.0f);}
\DoxyCodeLine{00668 }
\DoxyCodeLine{00669     XMMATRIX S = lightView*lightProj*T;}
\DoxyCodeLine{00670     XMStoreFloat4x4(\&mLightView, lightView);}
\DoxyCodeLine{00671     XMStoreFloat4x4(\&mLightProj, lightProj);}
\DoxyCodeLine{00672     XMStoreFloat4x4(\&mShadowTransform, S);}
\DoxyCodeLine{00673 \}}
\DoxyCodeLine{00674 }
\DoxyCodeLine{00675 \textcolor{keywordtype}{void} SkinnedMeshApp::UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00676 \{}
\DoxyCodeLine{00677     XMMATRIX view = mCamera.GetView();}
\DoxyCodeLine{00678     XMMATRIX proj = mCamera.GetProj();}
\DoxyCodeLine{00679 }
\DoxyCodeLine{00680     XMMATRIX viewProj = XMMatrixMultiply(view, proj);}
\DoxyCodeLine{00681     XMMATRIX invView = XMMatrixInverse(\&XMMatrixDeterminant(view), view);}
\DoxyCodeLine{00682     XMMATRIX invProj = XMMatrixInverse(\&XMMatrixDeterminant(proj), proj);}
\DoxyCodeLine{00683     XMMATRIX invViewProj = XMMatrixInverse(\&XMMatrixDeterminant(viewProj), viewProj);}
\DoxyCodeLine{00684 }
\DoxyCodeLine{00685     \textcolor{comment}{// Transform NDC space [-\/1,+1]\string^2 to texture space [0,1]\string^2}}
\DoxyCodeLine{00686     XMMATRIX T(}
\DoxyCodeLine{00687         0.5f, 0.0f, 0.0f, 0.0f,}
\DoxyCodeLine{00688         0.0f, -\/0.5f, 0.0f, 0.0f,}
\DoxyCodeLine{00689         0.0f, 0.0f, 1.0f, 0.0f,}
\DoxyCodeLine{00690         0.5f, 0.5f, 0.0f, 1.0f);}
\DoxyCodeLine{00691 }
\DoxyCodeLine{00692     XMMATRIX viewProjTex = XMMatrixMultiply(viewProj, T);}
\DoxyCodeLine{00693     XMMATRIX shadowTransform = XMLoadFloat4x4(\&mShadowTransform);}
\DoxyCodeLine{00694 }
\DoxyCodeLine{00695     XMStoreFloat4x4(\&mMainPassCB.View, XMMatrixTranspose(view));}
\DoxyCodeLine{00696     XMStoreFloat4x4(\&mMainPassCB.InvView, XMMatrixTranspose(invView));}
\DoxyCodeLine{00697     XMStoreFloat4x4(\&mMainPassCB.Proj, XMMatrixTranspose(proj));}
\DoxyCodeLine{00698     XMStoreFloat4x4(\&mMainPassCB.InvProj, XMMatrixTranspose(invProj));}
\DoxyCodeLine{00699     XMStoreFloat4x4(\&mMainPassCB.ViewProj, XMMatrixTranspose(viewProj));}
\DoxyCodeLine{00700     XMStoreFloat4x4(\&mMainPassCB.InvViewProj, XMMatrixTranspose(invViewProj));}
\DoxyCodeLine{00701     XMStoreFloat4x4(\&mMainPassCB.ViewProjTex, XMMatrixTranspose(viewProjTex));}
\DoxyCodeLine{00702     XMStoreFloat4x4(\&mMainPassCB.ShadowTransform, XMMatrixTranspose(shadowTransform));}
\DoxyCodeLine{00703     mMainPassCB.EyePosW = mCamera.GetPosition3f();}
\DoxyCodeLine{00704     mMainPassCB.RenderTargetSize = XMFLOAT2((\textcolor{keywordtype}{float})mClientWidth, (\textcolor{keywordtype}{float})mClientHeight);}
\DoxyCodeLine{00705     mMainPassCB.InvRenderTargetSize = XMFLOAT2(1.0f / mClientWidth, 1.0f / mClientHeight);}
\DoxyCodeLine{00706     mMainPassCB.NearZ = 1.0f;}
\DoxyCodeLine{00707     mMainPassCB.FarZ = 1000.0f;}
\DoxyCodeLine{00708     mMainPassCB.TotalTime = gt.TotalTime();}
\DoxyCodeLine{00709     mMainPassCB.DeltaTime = gt.DeltaTime();}
\DoxyCodeLine{00710     mMainPassCB.AmbientLight = \{ 0.25f, 0.25f, 0.35f, 1.0f \};}
\DoxyCodeLine{00711     mMainPassCB.Lights[0].Direction = mRotatedLightDirections[0];}
\DoxyCodeLine{00712     mMainPassCB.Lights[0].Strength = \{ 0.9f, 0.9f, 0.7f \};}
\DoxyCodeLine{00713     mMainPassCB.Lights[1].Direction = mRotatedLightDirections[1];}
\DoxyCodeLine{00714     mMainPassCB.Lights[1].Strength = \{ 0.4f, 0.4f, 0.4f \};}
\DoxyCodeLine{00715     mMainPassCB.Lights[2].Direction = mRotatedLightDirections[2];}
\DoxyCodeLine{00716     mMainPassCB.Lights[2].Strength = \{ 0.2f, 0.2f, 0.2f \};}
\DoxyCodeLine{00717  }
\DoxyCodeLine{00718     \textcolor{keyword}{auto} currPassCB = mCurrFrameResource-\/>PassCB.get();}
\DoxyCodeLine{00719     currPassCB-\/>CopyData(0, mMainPassCB);}
\DoxyCodeLine{00720 \}}
\DoxyCodeLine{00721 }
\DoxyCodeLine{00722 \textcolor{keywordtype}{void} SkinnedMeshApp::UpdateShadowPassCB(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00723 \{}
\DoxyCodeLine{00724     XMMATRIX view = XMLoadFloat4x4(\&mLightView);}
\DoxyCodeLine{00725     XMMATRIX proj = XMLoadFloat4x4(\&mLightProj);}
\DoxyCodeLine{00726 }
\DoxyCodeLine{00727     XMMATRIX viewProj = XMMatrixMultiply(view, proj);}
\DoxyCodeLine{00728     XMMATRIX invView = XMMatrixInverse(\&XMMatrixDeterminant(view), view);}
\DoxyCodeLine{00729     XMMATRIX invProj = XMMatrixInverse(\&XMMatrixDeterminant(proj), proj);}
\DoxyCodeLine{00730     XMMATRIX invViewProj = XMMatrixInverse(\&XMMatrixDeterminant(viewProj), viewProj);}
\DoxyCodeLine{00731 }
\DoxyCodeLine{00732     UINT w = mShadowMap-\/>Width();}
\DoxyCodeLine{00733     UINT h = mShadowMap-\/>Height();}
\DoxyCodeLine{00734 }
\DoxyCodeLine{00735     XMStoreFloat4x4(\&mShadowPassCB.View, XMMatrixTranspose(view));}
\DoxyCodeLine{00736     XMStoreFloat4x4(\&mShadowPassCB.InvView, XMMatrixTranspose(invView));}
\DoxyCodeLine{00737     XMStoreFloat4x4(\&mShadowPassCB.Proj, XMMatrixTranspose(proj));}
\DoxyCodeLine{00738     XMStoreFloat4x4(\&mShadowPassCB.InvProj, XMMatrixTranspose(invProj));}
\DoxyCodeLine{00739     XMStoreFloat4x4(\&mShadowPassCB.ViewProj, XMMatrixTranspose(viewProj));}
\DoxyCodeLine{00740     XMStoreFloat4x4(\&mShadowPassCB.InvViewProj, XMMatrixTranspose(invViewProj));}
\DoxyCodeLine{00741     mShadowPassCB.EyePosW = mLightPosW;}
\DoxyCodeLine{00742     mShadowPassCB.RenderTargetSize = XMFLOAT2((\textcolor{keywordtype}{float})w, (\textcolor{keywordtype}{float})h);}
\DoxyCodeLine{00743     mShadowPassCB.InvRenderTargetSize = XMFLOAT2(1.0f / w, 1.0f / h);}
\DoxyCodeLine{00744     mShadowPassCB.NearZ = mLightNearZ;}
\DoxyCodeLine{00745     mShadowPassCB.FarZ = mLightFarZ;}
\DoxyCodeLine{00746 }
\DoxyCodeLine{00747     \textcolor{keyword}{auto} currPassCB = mCurrFrameResource-\/>PassCB.get();}
\DoxyCodeLine{00748     currPassCB-\/>CopyData(1, mShadowPassCB);}
\DoxyCodeLine{00749 \}}
\DoxyCodeLine{00750 }
\DoxyCodeLine{00751 \textcolor{keywordtype}{void} SkinnedMeshApp::UpdateSsaoCB(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00752 \{}
\DoxyCodeLine{00753     SsaoConstants ssaoCB;}
\DoxyCodeLine{00754 }
\DoxyCodeLine{00755     XMMATRIX P = mCamera.GetProj();}
\DoxyCodeLine{00756 }
\DoxyCodeLine{00757     \textcolor{comment}{// Transform NDC space [-\/1,+1]\string^2 to texture space [0,1]\string^2}}
\DoxyCodeLine{00758     XMMATRIX T(}
\DoxyCodeLine{00759         0.5f, 0.0f, 0.0f, 0.0f,}
\DoxyCodeLine{00760         0.0f, -\/0.5f, 0.0f, 0.0f,}
\DoxyCodeLine{00761         0.0f, 0.0f, 1.0f, 0.0f,}
\DoxyCodeLine{00762         0.5f, 0.5f, 0.0f, 1.0f);}
\DoxyCodeLine{00763 }
\DoxyCodeLine{00764     ssaoCB.Proj    = mMainPassCB.Proj;}
\DoxyCodeLine{00765     ssaoCB.InvProj = mMainPassCB.InvProj;}
\DoxyCodeLine{00766     XMStoreFloat4x4(\&ssaoCB.ProjTex, XMMatrixTranspose(P*T));}
\DoxyCodeLine{00767 }
\DoxyCodeLine{00768     mSsao-\/>GetOffsetVectors(ssaoCB.OffsetVectors);}
\DoxyCodeLine{00769 }
\DoxyCodeLine{00770     \textcolor{keyword}{auto} blurWeights = mSsao-\/>CalcGaussWeights(2.5f);}
\DoxyCodeLine{00771     ssaoCB.BlurWeights[0] = XMFLOAT4(\&blurWeights[0]);}
\DoxyCodeLine{00772     ssaoCB.BlurWeights[1] = XMFLOAT4(\&blurWeights[4]);}
\DoxyCodeLine{00773     ssaoCB.BlurWeights[2] = XMFLOAT4(\&blurWeights[8]);}
\DoxyCodeLine{00774 }
\DoxyCodeLine{00775     ssaoCB.InvRenderTargetSize = XMFLOAT2(1.0f / mSsao-\/>SsaoMapWidth(), 1.0f / mSsao-\/>SsaoMapHeight());}
\DoxyCodeLine{00776 }
\DoxyCodeLine{00777     \textcolor{comment}{// Coordinates given in view space.}}
\DoxyCodeLine{00778     ssaoCB.OcclusionRadius = 0.5f;}
\DoxyCodeLine{00779     ssaoCB.OcclusionFadeStart = 0.2f;}
\DoxyCodeLine{00780     ssaoCB.OcclusionFadeEnd = 2.0f;}
\DoxyCodeLine{00781     ssaoCB.SurfaceEpsilon = 0.05f;}
\DoxyCodeLine{00782 }
\DoxyCodeLine{00783     \textcolor{keyword}{auto} currSsaoCB = mCurrFrameResource-\/>SsaoCB.get();}
\DoxyCodeLine{00784     currSsaoCB-\/>CopyData(0, ssaoCB);}
\DoxyCodeLine{00785 \}}
\DoxyCodeLine{00786 }
\DoxyCodeLine{00787 \textcolor{keywordtype}{void} SkinnedMeshApp::LoadTextures()}
\DoxyCodeLine{00788 \{}
\DoxyCodeLine{00789     std::vector<std::string> texNames = }
\DoxyCodeLine{00790     \{}
\DoxyCodeLine{00791         \textcolor{stringliteral}{"{}bricksDiffuseMap"{}},}
\DoxyCodeLine{00792         \textcolor{stringliteral}{"{}bricksNormalMap"{}},}
\DoxyCodeLine{00793         \textcolor{stringliteral}{"{}tileDiffuseMap"{}},}
\DoxyCodeLine{00794         \textcolor{stringliteral}{"{}tileNormalMap"{}},}
\DoxyCodeLine{00795         \textcolor{stringliteral}{"{}defaultDiffuseMap"{}},}
\DoxyCodeLine{00796         \textcolor{stringliteral}{"{}defaultNormalMap"{}},}
\DoxyCodeLine{00797         \textcolor{stringliteral}{"{}skyCubeMap"{}}}
\DoxyCodeLine{00798     \};}
\DoxyCodeLine{00799     }
\DoxyCodeLine{00800     std::vector<std::wstring> texFilenames = }
\DoxyCodeLine{00801     \{}
\DoxyCodeLine{00802         L\textcolor{stringliteral}{"{}../../Textures/bricks2.dds"{}},}
\DoxyCodeLine{00803         L\textcolor{stringliteral}{"{}../../Textures/bricks2\_nmap.dds"{}},}
\DoxyCodeLine{00804         L\textcolor{stringliteral}{"{}../../Textures/tile.dds"{}},}
\DoxyCodeLine{00805         L\textcolor{stringliteral}{"{}../../Textures/tile\_nmap.dds"{}},}
\DoxyCodeLine{00806         L\textcolor{stringliteral}{"{}../../Textures/white1x1.dds"{}},}
\DoxyCodeLine{00807         L\textcolor{stringliteral}{"{}../../Textures/default\_nmap.dds"{}},}
\DoxyCodeLine{00808         L\textcolor{stringliteral}{"{}../../Textures/desertcube1024.dds"{}}}
\DoxyCodeLine{00809     \};}
\DoxyCodeLine{00810 }
\DoxyCodeLine{00811     \textcolor{comment}{// Add skinned model textures to list so we can reference by name later.}}
\DoxyCodeLine{00812     \textcolor{keywordflow}{for}(UINT i = 0; i < mSkinnedMats.size(); ++i)}
\DoxyCodeLine{00813     \{}
\DoxyCodeLine{00814         std::string diffuseName = mSkinnedMats[i].DiffuseMapName;}
\DoxyCodeLine{00815         std::string normalName = mSkinnedMats[i].NormalMapName;}
\DoxyCodeLine{00816 }
\DoxyCodeLine{00817         std::wstring diffuseFilename = L\textcolor{stringliteral}{"{}../../Textures/"{}} + AnsiToWString(diffuseName);}
\DoxyCodeLine{00818         std::wstring normalFilename = L\textcolor{stringliteral}{"{}../../Textures/"{}} + AnsiToWString(normalName);}
\DoxyCodeLine{00819 }
\DoxyCodeLine{00820         \textcolor{comment}{// strip off extension}}
\DoxyCodeLine{00821         diffuseName = diffuseName.substr(0, diffuseName.find\_last\_of(\textcolor{stringliteral}{"{}."{}}));}
\DoxyCodeLine{00822         normalName = normalName.substr(0, normalName.find\_last\_of(\textcolor{stringliteral}{"{}."{}}));}
\DoxyCodeLine{00823 }
\DoxyCodeLine{00824         mSkinnedTextureNames.push\_back(diffuseName);}
\DoxyCodeLine{00825         texNames.push\_back(diffuseName);}
\DoxyCodeLine{00826         texFilenames.push\_back(diffuseFilename);}
\DoxyCodeLine{00827 }
\DoxyCodeLine{00828         mSkinnedTextureNames.push\_back(normalName);}
\DoxyCodeLine{00829         texNames.push\_back(normalName);}
\DoxyCodeLine{00830         texFilenames.push\_back(normalFilename);}
\DoxyCodeLine{00831     \}}
\DoxyCodeLine{00832     }
\DoxyCodeLine{00833     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < (int)texNames.size(); ++i)}
\DoxyCodeLine{00834     \{}
\DoxyCodeLine{00835         \textcolor{comment}{// Don't create duplicates.}}
\DoxyCodeLine{00836         \textcolor{keywordflow}{if}(mTextures.find(texNames[i]) == std::end(mTextures))}
\DoxyCodeLine{00837         \{}
\DoxyCodeLine{00838             \textcolor{keyword}{auto} texMap = std::make\_unique<Texture>();}
\DoxyCodeLine{00839             texMap-\/>Name = texNames[i];}
\DoxyCodeLine{00840             texMap-\/>Filename = texFilenames[i];}
\DoxyCodeLine{00841             ThrowIfFailed(DirectX::CreateDDSTextureFromFile12(md3dDevice.Get(),}
\DoxyCodeLine{00842                 mCommandList.Get(), texMap-\/>Filename.c\_str(),}
\DoxyCodeLine{00843                 texMap-\/>Resource, texMap-\/>UploadHeap));}
\DoxyCodeLine{00844 }
\DoxyCodeLine{00845             mTextures[texMap-\/>Name] = std::move(texMap);}
\DoxyCodeLine{00846         \}}
\DoxyCodeLine{00847     \}       }
\DoxyCodeLine{00848 \}}
\DoxyCodeLine{00849 }
\DoxyCodeLine{00850 \textcolor{keywordtype}{void} SkinnedMeshApp::BuildRootSignature()}
\DoxyCodeLine{00851 \{}
\DoxyCodeLine{00852     CD3DX12\_DESCRIPTOR\_RANGE texTable0;}
\DoxyCodeLine{00853     texTable0.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_SRV, 3, 0, 0);}
\DoxyCodeLine{00854 }
\DoxyCodeLine{00855     CD3DX12\_DESCRIPTOR\_RANGE texTable1;}
\DoxyCodeLine{00856     texTable1.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_SRV, 48, 3, 0);}
\DoxyCodeLine{00857 }
\DoxyCodeLine{00858     \textcolor{comment}{// Root parameter can be a table, root descriptor or root constants.}}
\DoxyCodeLine{00859     CD3DX12\_ROOT\_PARAMETER slotRootParameter[6];}
\DoxyCodeLine{00860 }
\DoxyCodeLine{00861     \textcolor{comment}{// Perfomance TIP: Order from most frequent to least frequent.}}
\DoxyCodeLine{00862     slotRootParameter[0].InitAsConstantBufferView(0);}
\DoxyCodeLine{00863     slotRootParameter[1].InitAsConstantBufferView(1);}
\DoxyCodeLine{00864     slotRootParameter[2].InitAsConstantBufferView(2);}
\DoxyCodeLine{00865     slotRootParameter[3].InitAsShaderResourceView(0, 1);}
\DoxyCodeLine{00866     slotRootParameter[4].InitAsDescriptorTable(1, \&texTable0, D3D12\_SHADER\_VISIBILITY\_PIXEL);}
\DoxyCodeLine{00867     slotRootParameter[5].InitAsDescriptorTable(1, \&texTable1, D3D12\_SHADER\_VISIBILITY\_PIXEL);}
\DoxyCodeLine{00868 }
\DoxyCodeLine{00869     \textcolor{keyword}{auto} staticSamplers = GetStaticSamplers();}
\DoxyCodeLine{00870 }
\DoxyCodeLine{00871     \textcolor{comment}{// A root signature is an array of root parameters.}}
\DoxyCodeLine{00872     CD3DX12\_ROOT\_SIGNATURE\_DESC rootSigDesc(6, slotRootParameter,}
\DoxyCodeLine{00873         (UINT)staticSamplers.size(), staticSamplers.data(),}
\DoxyCodeLine{00874         D3D12\_ROOT\_SIGNATURE\_FLAG\_ALLOW\_INPUT\_ASSEMBLER\_INPUT\_LAYOUT);}
\DoxyCodeLine{00875 }
\DoxyCodeLine{00876     \textcolor{comment}{// create a root signature with a single slot which points to a descriptor range consisting of a single constant buffer}}
\DoxyCodeLine{00877     ComPtr<ID3DBlob> serializedRootSig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00878     ComPtr<ID3DBlob> errorBlob = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00879     HRESULT hr = D3D12SerializeRootSignature(\&rootSigDesc, D3D\_ROOT\_SIGNATURE\_VERSION\_1,}
\DoxyCodeLine{00880         serializedRootSig.GetAddressOf(), errorBlob.GetAddressOf());}
\DoxyCodeLine{00881 }
\DoxyCodeLine{00882     \textcolor{keywordflow}{if}(errorBlob != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00883     \{}
\DoxyCodeLine{00884         ::OutputDebugStringA((\textcolor{keywordtype}{char}*)errorBlob-\/>GetBufferPointer());}
\DoxyCodeLine{00885     \}}
\DoxyCodeLine{00886     ThrowIfFailed(hr);}
\DoxyCodeLine{00887 }
\DoxyCodeLine{00888     ThrowIfFailed(md3dDevice-\/>CreateRootSignature(}
\DoxyCodeLine{00889         0,}
\DoxyCodeLine{00890         serializedRootSig-\/>GetBufferPointer(),}
\DoxyCodeLine{00891         serializedRootSig-\/>GetBufferSize(),}
\DoxyCodeLine{00892         IID\_PPV\_ARGS(mRootSignature.GetAddressOf())));}
\DoxyCodeLine{00893 \}}
\DoxyCodeLine{00894 }
\DoxyCodeLine{00895 \textcolor{keywordtype}{void} SkinnedMeshApp::BuildSsaoRootSignature()}
\DoxyCodeLine{00896 \{}
\DoxyCodeLine{00897     CD3DX12\_DESCRIPTOR\_RANGE texTable0;}
\DoxyCodeLine{00898     texTable0.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_SRV, 2, 0, 0);}
\DoxyCodeLine{00899 }
\DoxyCodeLine{00900     CD3DX12\_DESCRIPTOR\_RANGE texTable1;}
\DoxyCodeLine{00901     texTable1.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_SRV, 1, 2, 0);}
\DoxyCodeLine{00902 }
\DoxyCodeLine{00903     \textcolor{comment}{// Root parameter can be a table, root descriptor or root constants.}}
\DoxyCodeLine{00904     CD3DX12\_ROOT\_PARAMETER slotRootParameter[4];}
\DoxyCodeLine{00905 }
\DoxyCodeLine{00906     \textcolor{comment}{// Perfomance TIP: Order from most frequent to least frequent.}}
\DoxyCodeLine{00907     slotRootParameter[0].InitAsConstantBufferView(0);}
\DoxyCodeLine{00908     slotRootParameter[1].InitAsConstants(1, 1);}
\DoxyCodeLine{00909     slotRootParameter[2].InitAsDescriptorTable(1, \&texTable0, D3D12\_SHADER\_VISIBILITY\_PIXEL);}
\DoxyCodeLine{00910     slotRootParameter[3].InitAsDescriptorTable(1, \&texTable1, D3D12\_SHADER\_VISIBILITY\_PIXEL);}
\DoxyCodeLine{00911 }
\DoxyCodeLine{00912     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC pointClamp(}
\DoxyCodeLine{00913         0, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00914         D3D12\_FILTER\_MIN\_MAG\_MIP\_POINT, \textcolor{comment}{// filter}}
\DoxyCodeLine{00915         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00916         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00917         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{00918 }
\DoxyCodeLine{00919     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC linearClamp(}
\DoxyCodeLine{00920         1, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00921         D3D12\_FILTER\_MIN\_MAG\_MIP\_LINEAR, \textcolor{comment}{// filter}}
\DoxyCodeLine{00922         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00923         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00924         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{00925 }
\DoxyCodeLine{00926     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC depthMapSam(}
\DoxyCodeLine{00927         2, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00928         D3D12\_FILTER\_MIN\_MAG\_MIP\_LINEAR, \textcolor{comment}{// filter}}
\DoxyCodeLine{00929         D3D12\_TEXTURE\_ADDRESS\_MODE\_BORDER,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00930         D3D12\_TEXTURE\_ADDRESS\_MODE\_BORDER,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00931         D3D12\_TEXTURE\_ADDRESS\_MODE\_BORDER,  \textcolor{comment}{// addressW}}
\DoxyCodeLine{00932         0.0f,}
\DoxyCodeLine{00933         0,}
\DoxyCodeLine{00934         D3D12\_COMPARISON\_FUNC\_LESS\_EQUAL,}
\DoxyCodeLine{00935         D3D12\_STATIC\_BORDER\_COLOR\_OPAQUE\_WHITE); }
\DoxyCodeLine{00936 }
\DoxyCodeLine{00937     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC linearWrap(}
\DoxyCodeLine{00938         3, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{00939         D3D12\_FILTER\_MIN\_MAG\_MIP\_LINEAR, \textcolor{comment}{// filter}}
\DoxyCodeLine{00940         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{00941         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{00942         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{00943 }
\DoxyCodeLine{00944     std::array<CD3DX12\_STATIC\_SAMPLER\_DESC, 4> staticSamplers =}
\DoxyCodeLine{00945     \{}
\DoxyCodeLine{00946         pointClamp, linearClamp, depthMapSam, linearWrap}
\DoxyCodeLine{00947     \};}
\DoxyCodeLine{00948 }
\DoxyCodeLine{00949     \textcolor{comment}{// A root signature is an array of root parameters.}}
\DoxyCodeLine{00950     CD3DX12\_ROOT\_SIGNATURE\_DESC rootSigDesc(4, slotRootParameter,}
\DoxyCodeLine{00951         (UINT)staticSamplers.size(), staticSamplers.data(),}
\DoxyCodeLine{00952         D3D12\_ROOT\_SIGNATURE\_FLAG\_ALLOW\_INPUT\_ASSEMBLER\_INPUT\_LAYOUT);}
\DoxyCodeLine{00953 }
\DoxyCodeLine{00954     \textcolor{comment}{// create a root signature with a single slot which points to a descriptor range consisting of a single constant buffer}}
\DoxyCodeLine{00955     ComPtr<ID3DBlob> serializedRootSig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00956     ComPtr<ID3DBlob> errorBlob = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00957     HRESULT hr = D3D12SerializeRootSignature(\&rootSigDesc, D3D\_ROOT\_SIGNATURE\_VERSION\_1,}
\DoxyCodeLine{00958         serializedRootSig.GetAddressOf(), errorBlob.GetAddressOf());}
\DoxyCodeLine{00959 }
\DoxyCodeLine{00960     \textcolor{keywordflow}{if}(errorBlob != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00961     \{}
\DoxyCodeLine{00962         ::OutputDebugStringA((\textcolor{keywordtype}{char}*)errorBlob-\/>GetBufferPointer());}
\DoxyCodeLine{00963     \}}
\DoxyCodeLine{00964     ThrowIfFailed(hr);}
\DoxyCodeLine{00965 }
\DoxyCodeLine{00966     ThrowIfFailed(md3dDevice-\/>CreateRootSignature(}
\DoxyCodeLine{00967         0,}
\DoxyCodeLine{00968         serializedRootSig-\/>GetBufferPointer(),}
\DoxyCodeLine{00969         serializedRootSig-\/>GetBufferSize(),}
\DoxyCodeLine{00970         IID\_PPV\_ARGS(mSsaoRootSignature.GetAddressOf())));}
\DoxyCodeLine{00971 \}}
\DoxyCodeLine{00972 }
\DoxyCodeLine{00973 \textcolor{keywordtype}{void} SkinnedMeshApp::BuildDescriptorHeaps()}
\DoxyCodeLine{00974 \{}
\DoxyCodeLine{00975     \textcolor{comment}{//}}
\DoxyCodeLine{00976     \textcolor{comment}{// Create the SRV heap.}}
\DoxyCodeLine{00977     \textcolor{comment}{//}}
\DoxyCodeLine{00978     D3D12\_DESCRIPTOR\_HEAP\_DESC srvHeapDesc = \{\};}
\DoxyCodeLine{00979     srvHeapDesc.NumDescriptors = 64;}
\DoxyCodeLine{00980     srvHeapDesc.Type = D3D12\_DESCRIPTOR\_HEAP\_TYPE\_CBV\_SRV\_UAV;}
\DoxyCodeLine{00981     srvHeapDesc.Flags = D3D12\_DESCRIPTOR\_HEAP\_FLAG\_SHADER\_VISIBLE;}
\DoxyCodeLine{00982     ThrowIfFailed(md3dDevice-\/>CreateDescriptorHeap(\&srvHeapDesc, IID\_PPV\_ARGS(\&mSrvDescriptorHeap)));}
\DoxyCodeLine{00983 }
\DoxyCodeLine{00984     \textcolor{comment}{//}}
\DoxyCodeLine{00985     \textcolor{comment}{// Fill out the heap with actual descriptors.}}
\DoxyCodeLine{00986     \textcolor{comment}{//}}
\DoxyCodeLine{00987     CD3DX12\_CPU\_DESCRIPTOR\_HANDLE hDescriptor(mSrvDescriptorHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00988 }
\DoxyCodeLine{00989     std::vector<ComPtr<ID3D12Resource>> tex2DList = }
\DoxyCodeLine{00990     \{}
\DoxyCodeLine{00991         mTextures[\textcolor{stringliteral}{"{}bricksDiffuseMap"{}}]-\/>Resource,}
\DoxyCodeLine{00992         mTextures[\textcolor{stringliteral}{"{}bricksNormalMap"{}}]-\/>Resource,}
\DoxyCodeLine{00993         mTextures[\textcolor{stringliteral}{"{}tileDiffuseMap"{}}]-\/>Resource,}
\DoxyCodeLine{00994         mTextures[\textcolor{stringliteral}{"{}tileNormalMap"{}}]-\/>Resource,}
\DoxyCodeLine{00995         mTextures[\textcolor{stringliteral}{"{}defaultDiffuseMap"{}}]-\/>Resource,}
\DoxyCodeLine{00996         mTextures[\textcolor{stringliteral}{"{}defaultNormalMap"{}}]-\/>Resource}
\DoxyCodeLine{00997     \};}
\DoxyCodeLine{00998 }
\DoxyCodeLine{00999     mSkinnedSrvHeapStart = (UINT)tex2DList.size();}
\DoxyCodeLine{01000 }
\DoxyCodeLine{01001     \textcolor{keywordflow}{for}(UINT i = 0; i < (UINT)mSkinnedTextureNames.size(); ++i)}
\DoxyCodeLine{01002     \{}
\DoxyCodeLine{01003         \textcolor{keyword}{auto} texResource = mTextures[mSkinnedTextureNames[i]]-\/>Resource;}
\DoxyCodeLine{01004         assert(texResource != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{01005         tex2DList.push\_back(texResource);}
\DoxyCodeLine{01006     \}}
\DoxyCodeLine{01007     }
\DoxyCodeLine{01008 }
\DoxyCodeLine{01009     \textcolor{keyword}{auto} skyCubeMap = mTextures[\textcolor{stringliteral}{"{}skyCubeMap"{}}]-\/>Resource;}
\DoxyCodeLine{01010 }
\DoxyCodeLine{01011     D3D12\_SHADER\_RESOURCE\_VIEW\_DESC srvDesc = \{\};}
\DoxyCodeLine{01012     srvDesc.Shader4ComponentMapping = D3D12\_DEFAULT\_SHADER\_4\_COMPONENT\_MAPPING;}
\DoxyCodeLine{01013     srvDesc.ViewDimension = D3D12\_SRV\_DIMENSION\_TEXTURE2D;}
\DoxyCodeLine{01014     srvDesc.Texture2D.MostDetailedMip = 0;}
\DoxyCodeLine{01015     srvDesc.Texture2D.ResourceMinLODClamp = 0.0f;}
\DoxyCodeLine{01016     }
\DoxyCodeLine{01017     \textcolor{keywordflow}{for}(UINT i = 0; i < (UINT)tex2DList.size(); ++i)}
\DoxyCodeLine{01018     \{}
\DoxyCodeLine{01019         srvDesc.Format = tex2DList[i]-\/>GetDesc().Format;}
\DoxyCodeLine{01020         srvDesc.Texture2D.MipLevels = tex2DList[i]-\/>GetDesc().MipLevels;}
\DoxyCodeLine{01021         md3dDevice-\/>CreateShaderResourceView(tex2DList[i].Get(), \&srvDesc, hDescriptor);}
\DoxyCodeLine{01022 }
\DoxyCodeLine{01023         \textcolor{comment}{// next descriptor}}
\DoxyCodeLine{01024         hDescriptor.Offset(1, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{01025     \}}
\DoxyCodeLine{01026     }
\DoxyCodeLine{01027     srvDesc.ViewDimension = D3D12\_SRV\_DIMENSION\_TEXTURECUBE;}
\DoxyCodeLine{01028     srvDesc.TextureCube.MostDetailedMip = 0;}
\DoxyCodeLine{01029     srvDesc.TextureCube.MipLevels = skyCubeMap-\/>GetDesc().MipLevels;}
\DoxyCodeLine{01030     srvDesc.TextureCube.ResourceMinLODClamp = 0.0f;}
\DoxyCodeLine{01031     srvDesc.Format = skyCubeMap-\/>GetDesc().Format;}
\DoxyCodeLine{01032     md3dDevice-\/>CreateShaderResourceView(skyCubeMap.Get(), \&srvDesc, hDescriptor);}
\DoxyCodeLine{01033     }
\DoxyCodeLine{01034     mSkyTexHeapIndex = (UINT)tex2DList.size();}
\DoxyCodeLine{01035     mShadowMapHeapIndex = mSkyTexHeapIndex + 1;}
\DoxyCodeLine{01036     mSsaoHeapIndexStart = mShadowMapHeapIndex + 1;}
\DoxyCodeLine{01037     mSsaoAmbientMapIndex = mSsaoHeapIndexStart + 3;}
\DoxyCodeLine{01038     mNullCubeSrvIndex = mSsaoHeapIndexStart + 5;}
\DoxyCodeLine{01039     mNullTexSrvIndex1 = mNullCubeSrvIndex + 1;}
\DoxyCodeLine{01040     mNullTexSrvIndex2 = mNullTexSrvIndex1 + 1;}
\DoxyCodeLine{01041 }
\DoxyCodeLine{01042     \textcolor{keyword}{auto} nullSrv = GetCpuSrv(mNullCubeSrvIndex);}
\DoxyCodeLine{01043     mNullSrv = GetGpuSrv(mNullCubeSrvIndex);}
\DoxyCodeLine{01044 }
\DoxyCodeLine{01045     md3dDevice-\/>CreateShaderResourceView(\textcolor{keyword}{nullptr}, \&srvDesc, nullSrv);}
\DoxyCodeLine{01046     nullSrv.Offset(1, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{01047 }
\DoxyCodeLine{01048     srvDesc.ViewDimension = D3D12\_SRV\_DIMENSION\_TEXTURE2D;}
\DoxyCodeLine{01049     srvDesc.Format = DXGI\_FORMAT\_R8G8B8A8\_UNORM;}
\DoxyCodeLine{01050     srvDesc.Texture2D.MostDetailedMip = 0;}
\DoxyCodeLine{01051     srvDesc.Texture2D.MipLevels = 1;}
\DoxyCodeLine{01052     srvDesc.Texture2D.ResourceMinLODClamp = 0.0f;}
\DoxyCodeLine{01053     md3dDevice-\/>CreateShaderResourceView(\textcolor{keyword}{nullptr}, \&srvDesc, nullSrv);}
\DoxyCodeLine{01054 }
\DoxyCodeLine{01055     nullSrv.Offset(1, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{01056     md3dDevice-\/>CreateShaderResourceView(\textcolor{keyword}{nullptr}, \&srvDesc, nullSrv);}
\DoxyCodeLine{01057 }
\DoxyCodeLine{01058     mShadowMap-\/>BuildDescriptors(}
\DoxyCodeLine{01059         GetCpuSrv(mShadowMapHeapIndex),}
\DoxyCodeLine{01060         GetGpuSrv(mShadowMapHeapIndex),}
\DoxyCodeLine{01061         GetDsv(1));}
\DoxyCodeLine{01062 }
\DoxyCodeLine{01063     mSsao-\/>BuildDescriptors(}
\DoxyCodeLine{01064         mDepthStencilBuffer.Get(),}
\DoxyCodeLine{01065         GetCpuSrv(mSsaoHeapIndexStart),}
\DoxyCodeLine{01066         GetGpuSrv(mSsaoHeapIndexStart),}
\DoxyCodeLine{01067         GetRtv(SwapChainBufferCount),}
\DoxyCodeLine{01068         mCbvSrvUavDescriptorSize,}
\DoxyCodeLine{01069         mRtvDescriptorSize);}
\DoxyCodeLine{01070 \}}
\DoxyCodeLine{01071 }
\DoxyCodeLine{01072 \textcolor{keywordtype}{void} SkinnedMeshApp::BuildShadersAndInputLayout()}
\DoxyCodeLine{01073 \{}
\DoxyCodeLine{01074     \textcolor{keyword}{const} D3D\_SHADER\_MACRO alphaTestDefines[] =}
\DoxyCodeLine{01075     \{}
\DoxyCodeLine{01076         \textcolor{stringliteral}{"{}ALPHA\_TEST"{}}, \textcolor{stringliteral}{"{}1"{}},}
\DoxyCodeLine{01077         NULL, NULL}
\DoxyCodeLine{01078     \};}
\DoxyCodeLine{01079 }
\DoxyCodeLine{01080     \textcolor{keyword}{const} D3D\_SHADER\_MACRO skinnedDefines[] =}
\DoxyCodeLine{01081     \{}
\DoxyCodeLine{01082         \textcolor{stringliteral}{"{}SKINNED"{}}, \textcolor{stringliteral}{"{}1"{}},}
\DoxyCodeLine{01083         NULL, NULL}
\DoxyCodeLine{01084     \};}
\DoxyCodeLine{01085 }
\DoxyCodeLine{01086     mShaders[\textcolor{stringliteral}{"{}standardVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Default.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{01087     mShaders[\textcolor{stringliteral}{"{}skinnedVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Default.hlsl"{}}, skinnedDefines, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{01088     mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Default.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{01089 }
\DoxyCodeLine{01090     mShaders[\textcolor{stringliteral}{"{}shadowVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Shadows.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{01091     mShaders[\textcolor{stringliteral}{"{}skinnedShadowVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Shadows.hlsl"{}}, skinnedDefines, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{01092     mShaders[\textcolor{stringliteral}{"{}shadowOpaquePS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Shadows.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{01093     mShaders[\textcolor{stringliteral}{"{}shadowAlphaTestedPS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Shadows.hlsl"{}}, alphaTestDefines, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{01094     }
\DoxyCodeLine{01095     mShaders[\textcolor{stringliteral}{"{}debugVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)ShadowDebug.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{01096     mShaders[\textcolor{stringliteral}{"{}debugPS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)ShadowDebug.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{01097 }
\DoxyCodeLine{01098     mShaders[\textcolor{stringliteral}{"{}drawNormalsVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)DrawNormals.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{01099     mShaders[\textcolor{stringliteral}{"{}skinnedDrawNormalsVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)DrawNormals.hlsl"{}}, skinnedDefines, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{01100     mShaders[\textcolor{stringliteral}{"{}drawNormalsPS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)DrawNormals.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{01101 }
\DoxyCodeLine{01102     mShaders[\textcolor{stringliteral}{"{}ssaoVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Ssao.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{01103     mShaders[\textcolor{stringliteral}{"{}ssaoPS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Ssao.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{01104 }
\DoxyCodeLine{01105     mShaders[\textcolor{stringliteral}{"{}ssaoBlurVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)SsaoBlur.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{01106     mShaders[\textcolor{stringliteral}{"{}ssaoBlurPS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)SsaoBlur.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{01107 }
\DoxyCodeLine{01108     mShaders[\textcolor{stringliteral}{"{}skyVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Sky.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{01109     mShaders[\textcolor{stringliteral}{"{}skyPS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Sky.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{01110 }
\DoxyCodeLine{01111     mInputLayout =}
\DoxyCodeLine{01112     \{}
\DoxyCodeLine{01113         \{ \textcolor{stringliteral}{"{}POSITION"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 0, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{01114         \{ \textcolor{stringliteral}{"{}NORMAL"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 12, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{01115         \{ \textcolor{stringliteral}{"{}TEXCOORD"{}}, 0, DXGI\_FORMAT\_R32G32\_FLOAT, 0, 24, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{01116         \{ \textcolor{stringliteral}{"{}TANGENT"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 32, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{01117     \};}
\DoxyCodeLine{01118 }
\DoxyCodeLine{01119     mSkinnedInputLayout =}
\DoxyCodeLine{01120     \{}
\DoxyCodeLine{01121         \{ \textcolor{stringliteral}{"{}POSITION"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 0, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{01122         \{ \textcolor{stringliteral}{"{}NORMAL"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 12, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{01123         \{ \textcolor{stringliteral}{"{}TEXCOORD"{}}, 0, DXGI\_FORMAT\_R32G32\_FLOAT, 0, 24, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{01124         \{ \textcolor{stringliteral}{"{}TANGENT"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 32, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{01125         \{ \textcolor{stringliteral}{"{}WEIGHTS"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 44, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{01126         \{ \textcolor{stringliteral}{"{}BONEINDICES"{}}, 0, DXGI\_FORMAT\_R8G8B8A8\_UINT, 0, 56, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \}}
\DoxyCodeLine{01127     \};}
\DoxyCodeLine{01128 \}}
\DoxyCodeLine{01129 }
\DoxyCodeLine{01130 \textcolor{keywordtype}{void} SkinnedMeshApp::BuildShapeGeometry()}
\DoxyCodeLine{01131 \{}
\DoxyCodeLine{01132     GeometryGenerator geoGen;}
\DoxyCodeLine{01133     GeometryGenerator::MeshData box = geoGen.CreateBox(1.0f, 1.0f, 1.0f, 3);}
\DoxyCodeLine{01134     GeometryGenerator::MeshData grid = geoGen.CreateGrid(20.0f, 30.0f, 60, 40);}
\DoxyCodeLine{01135     GeometryGenerator::MeshData sphere = geoGen.CreateSphere(0.5f, 20, 20);}
\DoxyCodeLine{01136     GeometryGenerator::MeshData cylinder = geoGen.CreateCylinder(0.5f, 0.3f, 3.0f, 20, 20);}
\DoxyCodeLine{01137     GeometryGenerator::MeshData quad = geoGen.CreateQuad(0.0f, 0.0f, 1.0f, 1.0f, 0.0f);}
\DoxyCodeLine{01138     }
\DoxyCodeLine{01139     \textcolor{comment}{//}}
\DoxyCodeLine{01140     \textcolor{comment}{// We are concatenating all the geometry into one big vertex/index buffer.  So}}
\DoxyCodeLine{01141     \textcolor{comment}{// define the regions in the buffer each submesh covers.}}
\DoxyCodeLine{01142     \textcolor{comment}{//}}
\DoxyCodeLine{01143 }
\DoxyCodeLine{01144     \textcolor{comment}{// Cache the vertex offsets to each object in the concatenated vertex buffer.}}
\DoxyCodeLine{01145     UINT boxVertexOffset = 0;}
\DoxyCodeLine{01146     UINT gridVertexOffset = (UINT)box.Vertices.size();}
\DoxyCodeLine{01147     UINT sphereVertexOffset = gridVertexOffset + (UINT)grid.Vertices.size();}
\DoxyCodeLine{01148     UINT cylinderVertexOffset = sphereVertexOffset + (UINT)sphere.Vertices.size();}
\DoxyCodeLine{01149     UINT quadVertexOffset = cylinderVertexOffset + (UINT)cylinder.Vertices.size();}
\DoxyCodeLine{01150 }
\DoxyCodeLine{01151     \textcolor{comment}{// Cache the starting index for each object in the concatenated index buffer.}}
\DoxyCodeLine{01152     UINT boxIndexOffset = 0;}
\DoxyCodeLine{01153     UINT gridIndexOffset = (UINT)box.Indices32.size();}
\DoxyCodeLine{01154     UINT sphereIndexOffset = gridIndexOffset + (UINT)grid.Indices32.size();}
\DoxyCodeLine{01155     UINT cylinderIndexOffset = sphereIndexOffset + (UINT)sphere.Indices32.size();}
\DoxyCodeLine{01156     UINT quadIndexOffset = cylinderIndexOffset + (UINT)cylinder.Indices32.size();}
\DoxyCodeLine{01157 }
\DoxyCodeLine{01158     SubmeshGeometry boxSubmesh;}
\DoxyCodeLine{01159     boxSubmesh.IndexCount = (UINT)box.Indices32.size();}
\DoxyCodeLine{01160     boxSubmesh.StartIndexLocation = boxIndexOffset;}
\DoxyCodeLine{01161     boxSubmesh.BaseVertexLocation = boxVertexOffset;}
\DoxyCodeLine{01162 }
\DoxyCodeLine{01163     SubmeshGeometry gridSubmesh;}
\DoxyCodeLine{01164     gridSubmesh.IndexCount = (UINT)grid.Indices32.size();}
\DoxyCodeLine{01165     gridSubmesh.StartIndexLocation = gridIndexOffset;}
\DoxyCodeLine{01166     gridSubmesh.BaseVertexLocation = gridVertexOffset;}
\DoxyCodeLine{01167 }
\DoxyCodeLine{01168     SubmeshGeometry sphereSubmesh;}
\DoxyCodeLine{01169     sphereSubmesh.IndexCount = (UINT)sphere.Indices32.size();}
\DoxyCodeLine{01170     sphereSubmesh.StartIndexLocation = sphereIndexOffset;}
\DoxyCodeLine{01171     sphereSubmesh.BaseVertexLocation = sphereVertexOffset;}
\DoxyCodeLine{01172 }
\DoxyCodeLine{01173     SubmeshGeometry cylinderSubmesh;}
\DoxyCodeLine{01174     cylinderSubmesh.IndexCount = (UINT)cylinder.Indices32.size();}
\DoxyCodeLine{01175     cylinderSubmesh.StartIndexLocation = cylinderIndexOffset;}
\DoxyCodeLine{01176     cylinderSubmesh.BaseVertexLocation = cylinderVertexOffset;}
\DoxyCodeLine{01177 }
\DoxyCodeLine{01178     SubmeshGeometry quadSubmesh;}
\DoxyCodeLine{01179     quadSubmesh.IndexCount = (UINT)quad.Indices32.size();}
\DoxyCodeLine{01180     quadSubmesh.StartIndexLocation = quadIndexOffset;}
\DoxyCodeLine{01181     quadSubmesh.BaseVertexLocation = quadVertexOffset;}
\DoxyCodeLine{01182 }
\DoxyCodeLine{01183     \textcolor{comment}{//}}
\DoxyCodeLine{01184     \textcolor{comment}{// Extract the vertex elements we are interested in and pack the}}
\DoxyCodeLine{01185     \textcolor{comment}{// vertices of all the meshes into one vertex buffer.}}
\DoxyCodeLine{01186     \textcolor{comment}{//}}
\DoxyCodeLine{01187 }
\DoxyCodeLine{01188     \textcolor{keyword}{auto} totalVertexCount =}
\DoxyCodeLine{01189         box.Vertices.size() +}
\DoxyCodeLine{01190         grid.Vertices.size() +}
\DoxyCodeLine{01191         sphere.Vertices.size() +}
\DoxyCodeLine{01192         cylinder.Vertices.size() + }
\DoxyCodeLine{01193         quad.Vertices.size();}
\DoxyCodeLine{01194 }
\DoxyCodeLine{01195     std::vector<Vertex> vertices(totalVertexCount);}
\DoxyCodeLine{01196 }
\DoxyCodeLine{01197     UINT k = 0;}
\DoxyCodeLine{01198     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < box.Vertices.size(); ++i, ++k)}
\DoxyCodeLine{01199     \{}
\DoxyCodeLine{01200         vertices[k].Pos = box.Vertices[i].Position;}
\DoxyCodeLine{01201         vertices[k].Normal = box.Vertices[i].Normal;}
\DoxyCodeLine{01202         vertices[k].TexC = box.Vertices[i].TexC;}
\DoxyCodeLine{01203         vertices[k].TangentU = box.Vertices[i].TangentU;}
\DoxyCodeLine{01204     \}}
\DoxyCodeLine{01205 }
\DoxyCodeLine{01206     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < grid.Vertices.size(); ++i, ++k)}
\DoxyCodeLine{01207     \{}
\DoxyCodeLine{01208         vertices[k].Pos = grid.Vertices[i].Position;}
\DoxyCodeLine{01209         vertices[k].Normal = grid.Vertices[i].Normal;}
\DoxyCodeLine{01210         vertices[k].TexC = grid.Vertices[i].TexC;}
\DoxyCodeLine{01211         vertices[k].TangentU = grid.Vertices[i].TangentU;}
\DoxyCodeLine{01212     \}}
\DoxyCodeLine{01213 }
\DoxyCodeLine{01214     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < sphere.Vertices.size(); ++i, ++k)}
\DoxyCodeLine{01215     \{}
\DoxyCodeLine{01216         vertices[k].Pos = sphere.Vertices[i].Position;}
\DoxyCodeLine{01217         vertices[k].Normal = sphere.Vertices[i].Normal;}
\DoxyCodeLine{01218         vertices[k].TexC = sphere.Vertices[i].TexC;}
\DoxyCodeLine{01219         vertices[k].TangentU = sphere.Vertices[i].TangentU;}
\DoxyCodeLine{01220     \}}
\DoxyCodeLine{01221 }
\DoxyCodeLine{01222     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < cylinder.Vertices.size(); ++i, ++k)}
\DoxyCodeLine{01223     \{}
\DoxyCodeLine{01224         vertices[k].Pos = cylinder.Vertices[i].Position;}
\DoxyCodeLine{01225         vertices[k].Normal = cylinder.Vertices[i].Normal;}
\DoxyCodeLine{01226         vertices[k].TexC = cylinder.Vertices[i].TexC;}
\DoxyCodeLine{01227         vertices[k].TangentU = cylinder.Vertices[i].TangentU;}
\DoxyCodeLine{01228     \}}
\DoxyCodeLine{01229 }
\DoxyCodeLine{01230     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < quad.Vertices.size(); ++i, ++k)}
\DoxyCodeLine{01231     \{}
\DoxyCodeLine{01232         vertices[k].Pos = quad.Vertices[i].Position;}
\DoxyCodeLine{01233         vertices[k].Normal = quad.Vertices[i].Normal;}
\DoxyCodeLine{01234         vertices[k].TexC = quad.Vertices[i].TexC;}
\DoxyCodeLine{01235         vertices[k].TangentU = quad.Vertices[i].TangentU;}
\DoxyCodeLine{01236     \}}
\DoxyCodeLine{01237 }
\DoxyCodeLine{01238     std::vector<std::uint16\_t> indices;}
\DoxyCodeLine{01239     indices.insert(indices.end(), std::begin(box.GetIndices16()), std::end(box.GetIndices16()));}
\DoxyCodeLine{01240     indices.insert(indices.end(), std::begin(grid.GetIndices16()), std::end(grid.GetIndices16()));}
\DoxyCodeLine{01241     indices.insert(indices.end(), std::begin(sphere.GetIndices16()), std::end(sphere.GetIndices16()));}
\DoxyCodeLine{01242     indices.insert(indices.end(), std::begin(cylinder.GetIndices16()), std::end(cylinder.GetIndices16()));}
\DoxyCodeLine{01243     indices.insert(indices.end(), std::begin(quad.GetIndices16()), std::end(quad.GetIndices16()));}
\DoxyCodeLine{01244 }
\DoxyCodeLine{01245     \textcolor{keyword}{const} UINT vbByteSize = (UINT)vertices.size() * \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{01246     \textcolor{keyword}{const} UINT ibByteSize = (UINT)indices.size()  * \textcolor{keyword}{sizeof}(std::uint16\_t);}
\DoxyCodeLine{01247 }
\DoxyCodeLine{01248     \textcolor{keyword}{auto} geo = std::make\_unique<MeshGeometry>();}
\DoxyCodeLine{01249     geo-\/>Name = \textcolor{stringliteral}{"{}shapeGeo"{}};}
\DoxyCodeLine{01250 }
\DoxyCodeLine{01251     ThrowIfFailed(D3DCreateBlob(vbByteSize, \&geo-\/>VertexBufferCPU));}
\DoxyCodeLine{01252     CopyMemory(geo-\/>VertexBufferCPU-\/>GetBufferPointer(), vertices.data(), vbByteSize);}
\DoxyCodeLine{01253 }
\DoxyCodeLine{01254     ThrowIfFailed(D3DCreateBlob(ibByteSize, \&geo-\/>IndexBufferCPU));}
\DoxyCodeLine{01255     CopyMemory(geo-\/>IndexBufferCPU-\/>GetBufferPointer(), indices.data(), ibByteSize);}
\DoxyCodeLine{01256 }
\DoxyCodeLine{01257     geo-\/>VertexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{01258         mCommandList.Get(), vertices.data(), vbByteSize, geo-\/>VertexBufferUploader);}
\DoxyCodeLine{01259 }
\DoxyCodeLine{01260     geo-\/>IndexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{01261         mCommandList.Get(), indices.data(), ibByteSize, geo-\/>IndexBufferUploader);}
\DoxyCodeLine{01262 }
\DoxyCodeLine{01263     geo-\/>VertexByteStride = \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{01264     geo-\/>VertexBufferByteSize = vbByteSize;}
\DoxyCodeLine{01265     geo-\/>IndexFormat = DXGI\_FORMAT\_R16\_UINT;}
\DoxyCodeLine{01266     geo-\/>IndexBufferByteSize = ibByteSize;}
\DoxyCodeLine{01267 }
\DoxyCodeLine{01268     geo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}] = boxSubmesh;}
\DoxyCodeLine{01269     geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}] = gridSubmesh;}
\DoxyCodeLine{01270     geo-\/>DrawArgs[\textcolor{stringliteral}{"{}sphere"{}}] = sphereSubmesh;}
\DoxyCodeLine{01271     geo-\/>DrawArgs[\textcolor{stringliteral}{"{}cylinder"{}}] = cylinderSubmesh;}
\DoxyCodeLine{01272     geo-\/>DrawArgs[\textcolor{stringliteral}{"{}quad"{}}] = quadSubmesh;}
\DoxyCodeLine{01273 }
\DoxyCodeLine{01274     mGeometries[geo-\/>Name] = std::move(geo);}
\DoxyCodeLine{01275 \}}
\DoxyCodeLine{01276 }
\DoxyCodeLine{01277 \textcolor{keywordtype}{void} SkinnedMeshApp::LoadSkinnedModel()}
\DoxyCodeLine{01278 \{}
\DoxyCodeLine{01279     std::vector<M3DLoader::SkinnedVertex> vertices;}
\DoxyCodeLine{01280     std::vector<std::uint16\_t> indices; }
\DoxyCodeLine{01281  }
\DoxyCodeLine{01282     M3DLoader m3dLoader;}
\DoxyCodeLine{01283     m3dLoader.LoadM3d(mSkinnedModelFilename, vertices, indices, }
\DoxyCodeLine{01284         mSkinnedSubsets, mSkinnedMats, mSkinnedInfo);}
\DoxyCodeLine{01285 }
\DoxyCodeLine{01286     mSkinnedModelInst = std::make\_unique<SkinnedModelInstance>();}
\DoxyCodeLine{01287     mSkinnedModelInst-\/>SkinnedInfo = \&mSkinnedInfo;}
\DoxyCodeLine{01288     mSkinnedModelInst-\/>FinalTransforms.resize(mSkinnedInfo.BoneCount());}
\DoxyCodeLine{01289     mSkinnedModelInst-\/>ClipName = \textcolor{stringliteral}{"{}Take1"{}};}
\DoxyCodeLine{01290     mSkinnedModelInst-\/>TimePos = 0.0f;}
\DoxyCodeLine{01291  }
\DoxyCodeLine{01292     \textcolor{keyword}{const} UINT vbByteSize = (UINT)vertices.size() * \textcolor{keyword}{sizeof}(SkinnedVertex);}
\DoxyCodeLine{01293     \textcolor{keyword}{const} UINT ibByteSize = (UINT)indices.size()  * \textcolor{keyword}{sizeof}(std::uint16\_t);}
\DoxyCodeLine{01294 }
\DoxyCodeLine{01295     \textcolor{keyword}{auto} geo = std::make\_unique<MeshGeometry>();}
\DoxyCodeLine{01296     geo-\/>Name = mSkinnedModelFilename;}
\DoxyCodeLine{01297 }
\DoxyCodeLine{01298     ThrowIfFailed(D3DCreateBlob(vbByteSize, \&geo-\/>VertexBufferCPU));}
\DoxyCodeLine{01299     CopyMemory(geo-\/>VertexBufferCPU-\/>GetBufferPointer(), vertices.data(), vbByteSize);}
\DoxyCodeLine{01300 }
\DoxyCodeLine{01301     ThrowIfFailed(D3DCreateBlob(ibByteSize, \&geo-\/>IndexBufferCPU));}
\DoxyCodeLine{01302     CopyMemory(geo-\/>IndexBufferCPU-\/>GetBufferPointer(), indices.data(), ibByteSize);}
\DoxyCodeLine{01303 }
\DoxyCodeLine{01304     geo-\/>VertexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{01305         mCommandList.Get(), vertices.data(), vbByteSize, geo-\/>VertexBufferUploader);}
\DoxyCodeLine{01306 }
\DoxyCodeLine{01307     geo-\/>IndexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{01308         mCommandList.Get(), indices.data(), ibByteSize, geo-\/>IndexBufferUploader);}
\DoxyCodeLine{01309 }
\DoxyCodeLine{01310     geo-\/>VertexByteStride = \textcolor{keyword}{sizeof}(SkinnedVertex);}
\DoxyCodeLine{01311     geo-\/>VertexBufferByteSize = vbByteSize;}
\DoxyCodeLine{01312     geo-\/>IndexFormat = DXGI\_FORMAT\_R16\_UINT;}
\DoxyCodeLine{01313     geo-\/>IndexBufferByteSize = ibByteSize;}
\DoxyCodeLine{01314 }
\DoxyCodeLine{01315     \textcolor{keywordflow}{for}(UINT i = 0; i < (UINT)mSkinnedSubsets.size(); ++i)}
\DoxyCodeLine{01316     \{}
\DoxyCodeLine{01317         SubmeshGeometry submesh;}
\DoxyCodeLine{01318         std::string name = \textcolor{stringliteral}{"{}sm\_"{}} + std::to\_string(i);}
\DoxyCodeLine{01319         }
\DoxyCodeLine{01320         submesh.IndexCount = (UINT)mSkinnedSubsets[i].FaceCount * 3;}
\DoxyCodeLine{01321         submesh.StartIndexLocation = mSkinnedSubsets[i].FaceStart * 3;}
\DoxyCodeLine{01322         submesh.BaseVertexLocation = 0;}
\DoxyCodeLine{01323 }
\DoxyCodeLine{01324         geo-\/>DrawArgs[name] = submesh;}
\DoxyCodeLine{01325     \}}
\DoxyCodeLine{01326 }
\DoxyCodeLine{01327     mGeometries[geo-\/>Name] = std::move(geo);}
\DoxyCodeLine{01328 \}}
\DoxyCodeLine{01329 }
\DoxyCodeLine{01330 \textcolor{keywordtype}{void} SkinnedMeshApp::BuildPSOs()}
\DoxyCodeLine{01331 \{}
\DoxyCodeLine{01332     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC opaquePsoDesc;}
\DoxyCodeLine{01333 }
\DoxyCodeLine{01334     \textcolor{comment}{//}}
\DoxyCodeLine{01335     \textcolor{comment}{// PSO for opaque objects.}}
\DoxyCodeLine{01336     \textcolor{comment}{//}}
\DoxyCodeLine{01337     ZeroMemory(\&opaquePsoDesc, \textcolor{keyword}{sizeof}(D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC));}
\DoxyCodeLine{01338     opaquePsoDesc.InputLayout = \{ mInputLayout.data(), (UINT)mInputLayout.size() \};}
\DoxyCodeLine{01339     opaquePsoDesc.pRootSignature = mRootSignature.Get();}
\DoxyCodeLine{01340     opaquePsoDesc.VS = }
\DoxyCodeLine{01341     \{ }
\DoxyCodeLine{01342         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferPointer()), }
\DoxyCodeLine{01343         mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01344     \};}
\DoxyCodeLine{01345     opaquePsoDesc.PS = }
\DoxyCodeLine{01346     \{ }
\DoxyCodeLine{01347         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01348         mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01349     \};}
\DoxyCodeLine{01350     opaquePsoDesc.RasterizerState = CD3DX12\_RASTERIZER\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{01351     opaquePsoDesc.BlendState = CD3DX12\_BLEND\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{01352     opaquePsoDesc.DepthStencilState = CD3DX12\_DEPTH\_STENCIL\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{01353     opaquePsoDesc.SampleMask = UINT\_MAX;}
\DoxyCodeLine{01354     opaquePsoDesc.PrimitiveTopologyType = D3D12\_PRIMITIVE\_TOPOLOGY\_TYPE\_TRIANGLE;}
\DoxyCodeLine{01355     opaquePsoDesc.NumRenderTargets = 1;}
\DoxyCodeLine{01356     opaquePsoDesc.RTVFormats[0] = mBackBufferFormat;}
\DoxyCodeLine{01357     opaquePsoDesc.SampleDesc.Count = m4xMsaaState ? 4 : 1;}
\DoxyCodeLine{01358     opaquePsoDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality -\/ 1) : 0;}
\DoxyCodeLine{01359     opaquePsoDesc.DSVFormat = mDepthStencilFormat;}
\DoxyCodeLine{01360     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&opaquePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}opaque"{}}])));}
\DoxyCodeLine{01361 }
\DoxyCodeLine{01362     \textcolor{comment}{//}}
\DoxyCodeLine{01363     \textcolor{comment}{// PSO for skinned pass.}}
\DoxyCodeLine{01364     \textcolor{comment}{//}}
\DoxyCodeLine{01365     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC skinnedOpaquePsoDesc = opaquePsoDesc;}
\DoxyCodeLine{01366     skinnedOpaquePsoDesc.InputLayout = \{ mSkinnedInputLayout.data(), (UINT)mSkinnedInputLayout.size() \};}
\DoxyCodeLine{01367     skinnedOpaquePsoDesc.VS =}
\DoxyCodeLine{01368     \{}
\DoxyCodeLine{01369         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}skinnedVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01370         mShaders[\textcolor{stringliteral}{"{}skinnedVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01371     \};}
\DoxyCodeLine{01372     skinnedOpaquePsoDesc.PS =}
\DoxyCodeLine{01373     \{}
\DoxyCodeLine{01374         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01375         mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01376     \};}
\DoxyCodeLine{01377     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&skinnedOpaquePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}skinnedOpaque"{}}])));}
\DoxyCodeLine{01378 }
\DoxyCodeLine{01379     \textcolor{comment}{//}}
\DoxyCodeLine{01380     \textcolor{comment}{// PSO for shadow map pass.}}
\DoxyCodeLine{01381     \textcolor{comment}{//}}
\DoxyCodeLine{01382     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC smapPsoDesc = opaquePsoDesc;}
\DoxyCodeLine{01383     smapPsoDesc.RasterizerState.DepthBias = 100000;}
\DoxyCodeLine{01384     smapPsoDesc.RasterizerState.DepthBiasClamp = 0.0f;}
\DoxyCodeLine{01385     smapPsoDesc.RasterizerState.SlopeScaledDepthBias = 1.0f;}
\DoxyCodeLine{01386     smapPsoDesc.pRootSignature = mRootSignature.Get();}
\DoxyCodeLine{01387     smapPsoDesc.VS =}
\DoxyCodeLine{01388     \{}
\DoxyCodeLine{01389         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}shadowVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01390         mShaders[\textcolor{stringliteral}{"{}shadowVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01391     \};}
\DoxyCodeLine{01392     smapPsoDesc.PS =}
\DoxyCodeLine{01393     \{}
\DoxyCodeLine{01394         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}shadowOpaquePS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01395         mShaders[\textcolor{stringliteral}{"{}shadowOpaquePS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01396     \};}
\DoxyCodeLine{01397     }
\DoxyCodeLine{01398     \textcolor{comment}{// Shadow map pass does not have a render target.}}
\DoxyCodeLine{01399     smapPsoDesc.RTVFormats[0] = DXGI\_FORMAT\_UNKNOWN;}
\DoxyCodeLine{01400     smapPsoDesc.NumRenderTargets = 0;}
\DoxyCodeLine{01401     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&smapPsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}shadow\_opaque"{}}])));}
\DoxyCodeLine{01402 }
\DoxyCodeLine{01403     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC skinnedSmapPsoDesc = smapPsoDesc;}
\DoxyCodeLine{01404     skinnedSmapPsoDesc.InputLayout = \{ mSkinnedInputLayout.data(), (UINT)mSkinnedInputLayout.size() \};}
\DoxyCodeLine{01405     skinnedSmapPsoDesc.VS =}
\DoxyCodeLine{01406     \{}
\DoxyCodeLine{01407         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}skinnedShadowVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01408         mShaders[\textcolor{stringliteral}{"{}skinnedShadowVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01409     \};}
\DoxyCodeLine{01410     skinnedSmapPsoDesc.PS =}
\DoxyCodeLine{01411     \{}
\DoxyCodeLine{01412         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}shadowOpaquePS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01413         mShaders[\textcolor{stringliteral}{"{}shadowOpaquePS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01414     \};}
\DoxyCodeLine{01415     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&skinnedSmapPsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}skinnedShadow\_opaque"{}}])));}
\DoxyCodeLine{01416 }
\DoxyCodeLine{01417     \textcolor{comment}{//}}
\DoxyCodeLine{01418     \textcolor{comment}{// PSO for debug layer.}}
\DoxyCodeLine{01419     \textcolor{comment}{//}}
\DoxyCodeLine{01420     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC debugPsoDesc = opaquePsoDesc;}
\DoxyCodeLine{01421     debugPsoDesc.pRootSignature = mRootSignature.Get();}
\DoxyCodeLine{01422     debugPsoDesc.VS =}
\DoxyCodeLine{01423     \{}
\DoxyCodeLine{01424         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}debugVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01425         mShaders[\textcolor{stringliteral}{"{}debugVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01426     \};}
\DoxyCodeLine{01427     debugPsoDesc.PS =}
\DoxyCodeLine{01428     \{}
\DoxyCodeLine{01429         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}debugPS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01430         mShaders[\textcolor{stringliteral}{"{}debugPS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01431     \};}
\DoxyCodeLine{01432     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&debugPsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}debug"{}}])));}
\DoxyCodeLine{01433 }
\DoxyCodeLine{01434     \textcolor{comment}{//}}
\DoxyCodeLine{01435     \textcolor{comment}{// PSO for drawing normals.}}
\DoxyCodeLine{01436     \textcolor{comment}{//}}
\DoxyCodeLine{01437     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC drawNormalsPsoDesc = opaquePsoDesc;}
\DoxyCodeLine{01438     drawNormalsPsoDesc.VS =}
\DoxyCodeLine{01439     \{}
\DoxyCodeLine{01440         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}drawNormalsVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01441         mShaders[\textcolor{stringliteral}{"{}drawNormalsVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01442     \};}
\DoxyCodeLine{01443     drawNormalsPsoDesc.PS =}
\DoxyCodeLine{01444     \{}
\DoxyCodeLine{01445         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}drawNormalsPS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01446         mShaders[\textcolor{stringliteral}{"{}drawNormalsPS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01447     \};}
\DoxyCodeLine{01448     drawNormalsPsoDesc.RTVFormats[0] = Ssao::NormalMapFormat;}
\DoxyCodeLine{01449     drawNormalsPsoDesc.SampleDesc.Count = 1;}
\DoxyCodeLine{01450     drawNormalsPsoDesc.SampleDesc.Quality = 0;}
\DoxyCodeLine{01451     drawNormalsPsoDesc.DSVFormat = mDepthStencilFormat;}
\DoxyCodeLine{01452     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&drawNormalsPsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}drawNormals"{}}])));}
\DoxyCodeLine{01453 }
\DoxyCodeLine{01454     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC skinnedDrawNormalsPsoDesc = drawNormalsPsoDesc;}
\DoxyCodeLine{01455     skinnedDrawNormalsPsoDesc.InputLayout = \{ mSkinnedInputLayout.data(), (UINT)mSkinnedInputLayout.size() \};}
\DoxyCodeLine{01456     skinnedDrawNormalsPsoDesc.VS =}
\DoxyCodeLine{01457     \{}
\DoxyCodeLine{01458         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}skinnedDrawNormalsVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01459         mShaders[\textcolor{stringliteral}{"{}skinnedDrawNormalsVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01460     \};}
\DoxyCodeLine{01461     skinnedDrawNormalsPsoDesc.PS =}
\DoxyCodeLine{01462     \{}
\DoxyCodeLine{01463         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}drawNormalsPS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01464         mShaders[\textcolor{stringliteral}{"{}drawNormalsPS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01465     \};}
\DoxyCodeLine{01466     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&skinnedDrawNormalsPsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}skinnedDrawNormals"{}}])));}
\DoxyCodeLine{01467 }
\DoxyCodeLine{01468     \textcolor{comment}{//}}
\DoxyCodeLine{01469     \textcolor{comment}{// PSO for SSAO.}}
\DoxyCodeLine{01470     \textcolor{comment}{//}}
\DoxyCodeLine{01471     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC ssaoPsoDesc = opaquePsoDesc;}
\DoxyCodeLine{01472     ssaoPsoDesc.InputLayout = \{ \textcolor{keyword}{nullptr}, 0 \};}
\DoxyCodeLine{01473     ssaoPsoDesc.pRootSignature = mSsaoRootSignature.Get();}
\DoxyCodeLine{01474     ssaoPsoDesc.VS =}
\DoxyCodeLine{01475     \{}
\DoxyCodeLine{01476         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}ssaoVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01477         mShaders[\textcolor{stringliteral}{"{}ssaoVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01478     \};}
\DoxyCodeLine{01479     ssaoPsoDesc.PS =}
\DoxyCodeLine{01480     \{}
\DoxyCodeLine{01481         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}ssaoPS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01482         mShaders[\textcolor{stringliteral}{"{}ssaoPS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01483     \};}
\DoxyCodeLine{01484 }
\DoxyCodeLine{01485     \textcolor{comment}{// SSAO effect does not need the depth buffer.}}
\DoxyCodeLine{01486     ssaoPsoDesc.DepthStencilState.DepthEnable = \textcolor{keyword}{false};}
\DoxyCodeLine{01487     ssaoPsoDesc.DepthStencilState.DepthWriteMask = D3D12\_DEPTH\_WRITE\_MASK\_ZERO;}
\DoxyCodeLine{01488     ssaoPsoDesc.RTVFormats[0] = Ssao::AmbientMapFormat;}
\DoxyCodeLine{01489     ssaoPsoDesc.SampleDesc.Count = 1;}
\DoxyCodeLine{01490     ssaoPsoDesc.SampleDesc.Quality = 0;}
\DoxyCodeLine{01491     ssaoPsoDesc.DSVFormat = DXGI\_FORMAT\_UNKNOWN;}
\DoxyCodeLine{01492     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&ssaoPsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}ssao"{}}])));}
\DoxyCodeLine{01493 }
\DoxyCodeLine{01494     \textcolor{comment}{//}}
\DoxyCodeLine{01495     \textcolor{comment}{// PSO for SSAO blur.}}
\DoxyCodeLine{01496     \textcolor{comment}{//}}
\DoxyCodeLine{01497     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC ssaoBlurPsoDesc = ssaoPsoDesc;}
\DoxyCodeLine{01498     ssaoBlurPsoDesc.VS =}
\DoxyCodeLine{01499     \{}
\DoxyCodeLine{01500         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}ssaoBlurVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01501         mShaders[\textcolor{stringliteral}{"{}ssaoBlurVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01502     \};}
\DoxyCodeLine{01503     ssaoBlurPsoDesc.PS =}
\DoxyCodeLine{01504     \{}
\DoxyCodeLine{01505         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}ssaoBlurPS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01506         mShaders[\textcolor{stringliteral}{"{}ssaoBlurPS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01507     \};}
\DoxyCodeLine{01508     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&ssaoBlurPsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}ssaoBlur"{}}])));}
\DoxyCodeLine{01509 }
\DoxyCodeLine{01510     \textcolor{comment}{//}}
\DoxyCodeLine{01511     \textcolor{comment}{// PSO for sky.}}
\DoxyCodeLine{01512     \textcolor{comment}{//}}
\DoxyCodeLine{01513     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC skyPsoDesc = opaquePsoDesc;}
\DoxyCodeLine{01514 }
\DoxyCodeLine{01515     \textcolor{comment}{// The camera is inside the sky sphere, so just turn off culling.}}
\DoxyCodeLine{01516     skyPsoDesc.RasterizerState.CullMode = D3D12\_CULL\_MODE\_NONE;}
\DoxyCodeLine{01517 }
\DoxyCodeLine{01518     \textcolor{comment}{// Make sure the depth function is LESS\_EQUAL and not just LESS.  }}
\DoxyCodeLine{01519     \textcolor{comment}{// Otherwise, the normalized depth values at z = 1 (NDC) will }}
\DoxyCodeLine{01520     \textcolor{comment}{// fail the depth test if the depth buffer was cleared to 1.}}
\DoxyCodeLine{01521     skyPsoDesc.DepthStencilState.DepthFunc = D3D12\_COMPARISON\_FUNC\_LESS\_EQUAL;}
\DoxyCodeLine{01522     skyPsoDesc.pRootSignature = mRootSignature.Get();}
\DoxyCodeLine{01523     skyPsoDesc.VS =}
\DoxyCodeLine{01524     \{}
\DoxyCodeLine{01525         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}skyVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01526         mShaders[\textcolor{stringliteral}{"{}skyVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01527     \};}
\DoxyCodeLine{01528     skyPsoDesc.PS =}
\DoxyCodeLine{01529     \{}
\DoxyCodeLine{01530         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}skyPS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{01531         mShaders[\textcolor{stringliteral}{"{}skyPS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{01532     \};}
\DoxyCodeLine{01533     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&skyPsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}sky"{}}])));}
\DoxyCodeLine{01534 }
\DoxyCodeLine{01535 \}}
\DoxyCodeLine{01536 }
\DoxyCodeLine{01537 \textcolor{keywordtype}{void} SkinnedMeshApp::BuildFrameResources()}
\DoxyCodeLine{01538 \{}
\DoxyCodeLine{01539     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < gNumFrameResources; ++i)}
\DoxyCodeLine{01540     \{}
\DoxyCodeLine{01541         mFrameResources.push\_back(std::make\_unique<FrameResource>(md3dDevice.Get(),}
\DoxyCodeLine{01542             2, (UINT)mAllRitems.size(), }
\DoxyCodeLine{01543             1,}
\DoxyCodeLine{01544             (UINT)mMaterials.size()));}
\DoxyCodeLine{01545     \}}
\DoxyCodeLine{01546 \}}
\DoxyCodeLine{01547 }
\DoxyCodeLine{01548 \textcolor{keywordtype}{void} SkinnedMeshApp::BuildMaterials()}
\DoxyCodeLine{01549 \{}
\DoxyCodeLine{01550     \textcolor{keyword}{auto} bricks0 = std::make\_unique<Material>();}
\DoxyCodeLine{01551     bricks0-\/>Name = \textcolor{stringliteral}{"{}bricks0"{}};}
\DoxyCodeLine{01552     bricks0-\/>MatCBIndex = 0;}
\DoxyCodeLine{01553     bricks0-\/>DiffuseSrvHeapIndex = 0;}
\DoxyCodeLine{01554     bricks0-\/>NormalSrvHeapIndex = 1;}
\DoxyCodeLine{01555     bricks0-\/>DiffuseAlbedo = XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f);}
\DoxyCodeLine{01556     bricks0-\/>FresnelR0 = XMFLOAT3(0.1f, 0.1f, 0.1f);}
\DoxyCodeLine{01557     bricks0-\/>Roughness = 0.3f;}
\DoxyCodeLine{01558  }
\DoxyCodeLine{01559     \textcolor{keyword}{auto} tile0 = std::make\_unique<Material>();}
\DoxyCodeLine{01560     tile0-\/>Name = \textcolor{stringliteral}{"{}tile0"{}};}
\DoxyCodeLine{01561     tile0-\/>MatCBIndex = 1;}
\DoxyCodeLine{01562     tile0-\/>DiffuseSrvHeapIndex = 2;}
\DoxyCodeLine{01563     tile0-\/>NormalSrvHeapIndex = 3;}
\DoxyCodeLine{01564     tile0-\/>DiffuseAlbedo = XMFLOAT4(0.9f, 0.9f, 0.9f, 1.0f);}
\DoxyCodeLine{01565     tile0-\/>FresnelR0 = XMFLOAT3(0.2f, 0.2f, 0.2f);}
\DoxyCodeLine{01566     tile0-\/>Roughness = 0.1f;}
\DoxyCodeLine{01567 }
\DoxyCodeLine{01568     \textcolor{keyword}{auto} mirror0 = std::make\_unique<Material>();}
\DoxyCodeLine{01569     mirror0-\/>Name = \textcolor{stringliteral}{"{}mirror0"{}};}
\DoxyCodeLine{01570     mirror0-\/>MatCBIndex = 2;}
\DoxyCodeLine{01571     mirror0-\/>DiffuseSrvHeapIndex = 4;}
\DoxyCodeLine{01572     mirror0-\/>NormalSrvHeapIndex = 5;}
\DoxyCodeLine{01573     mirror0-\/>DiffuseAlbedo = XMFLOAT4(0.0f, 0.0f, 0.0f, 1.0f);}
\DoxyCodeLine{01574     mirror0-\/>FresnelR0 = XMFLOAT3(0.98f, 0.97f, 0.95f);}
\DoxyCodeLine{01575     mirror0-\/>Roughness = 0.1f;}
\DoxyCodeLine{01576 }
\DoxyCodeLine{01577     \textcolor{keyword}{auto} sky = std::make\_unique<Material>();}
\DoxyCodeLine{01578     sky-\/>Name = \textcolor{stringliteral}{"{}sky"{}};}
\DoxyCodeLine{01579     sky-\/>MatCBIndex = 3;}
\DoxyCodeLine{01580     sky-\/>DiffuseSrvHeapIndex = 6;}
\DoxyCodeLine{01581     sky-\/>NormalSrvHeapIndex = 7;}
\DoxyCodeLine{01582     sky-\/>DiffuseAlbedo = XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f);}
\DoxyCodeLine{01583     sky-\/>FresnelR0 = XMFLOAT3(0.1f, 0.1f, 0.1f);}
\DoxyCodeLine{01584     sky-\/>Roughness = 1.0f;}
\DoxyCodeLine{01585 }
\DoxyCodeLine{01586     mMaterials[\textcolor{stringliteral}{"{}bricks0"{}}] = std::move(bricks0);}
\DoxyCodeLine{01587     mMaterials[\textcolor{stringliteral}{"{}tile0"{}}] = std::move(tile0);}
\DoxyCodeLine{01588     mMaterials[\textcolor{stringliteral}{"{}mirror0"{}}] = std::move(mirror0);}
\DoxyCodeLine{01589     mMaterials[\textcolor{stringliteral}{"{}sky"{}}] = std::move(sky);}
\DoxyCodeLine{01590 }
\DoxyCodeLine{01591     UINT matCBIndex = 4;}
\DoxyCodeLine{01592     UINT srvHeapIndex = mSkinnedSrvHeapStart;}
\DoxyCodeLine{01593     \textcolor{keywordflow}{for}(UINT i = 0; i < mSkinnedMats.size(); ++i)}
\DoxyCodeLine{01594     \{}
\DoxyCodeLine{01595         \textcolor{keyword}{auto} mat = std::make\_unique<Material>();}
\DoxyCodeLine{01596         mat-\/>Name = mSkinnedMats[i].Name;}
\DoxyCodeLine{01597         mat-\/>MatCBIndex = matCBIndex++;}
\DoxyCodeLine{01598         mat-\/>DiffuseSrvHeapIndex = srvHeapIndex++;}
\DoxyCodeLine{01599         mat-\/>NormalSrvHeapIndex = srvHeapIndex++;}
\DoxyCodeLine{01600         mat-\/>DiffuseAlbedo = mSkinnedMats[i].DiffuseAlbedo;}
\DoxyCodeLine{01601         mat-\/>FresnelR0 = mSkinnedMats[i].FresnelR0;}
\DoxyCodeLine{01602         mat-\/>Roughness = mSkinnedMats[i].Roughness;}
\DoxyCodeLine{01603 }
\DoxyCodeLine{01604         mMaterials[mat-\/>Name] = std::move(mat);}
\DoxyCodeLine{01605     \}}
\DoxyCodeLine{01606 \}}
\DoxyCodeLine{01607 }
\DoxyCodeLine{01608 \textcolor{keywordtype}{void} SkinnedMeshApp::BuildRenderItems()}
\DoxyCodeLine{01609 \{}
\DoxyCodeLine{01610     \textcolor{keyword}{auto} skyRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{01611     XMStoreFloat4x4(\&skyRitem-\/>World, XMMatrixScaling(5000.0f, 5000.0f, 5000.0f));}
\DoxyCodeLine{01612     skyRitem-\/>TexTransform = MathHelper::Identity4x4();}
\DoxyCodeLine{01613     skyRitem-\/>ObjCBIndex = 0;}
\DoxyCodeLine{01614     skyRitem-\/>Mat = mMaterials[\textcolor{stringliteral}{"{}sky"{}}].get();}
\DoxyCodeLine{01615     skyRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}shapeGeo"{}}].get();}
\DoxyCodeLine{01616     skyRitem-\/>PrimitiveType = D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{01617     skyRitem-\/>IndexCount = skyRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}sphere"{}}].IndexCount;}
\DoxyCodeLine{01618     skyRitem-\/>StartIndexLocation = skyRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}sphere"{}}].StartIndexLocation;}
\DoxyCodeLine{01619     skyRitem-\/>BaseVertexLocation = skyRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}sphere"{}}].BaseVertexLocation;}
\DoxyCodeLine{01620 }
\DoxyCodeLine{01621     mRitemLayer[(int)RenderLayer::Sky].push\_back(skyRitem.get());}
\DoxyCodeLine{01622     mAllRitems.push\_back(std::move(skyRitem));}
\DoxyCodeLine{01623     }
\DoxyCodeLine{01624     \textcolor{keyword}{auto} quadRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{01625     quadRitem-\/>World = MathHelper::Identity4x4();}
\DoxyCodeLine{01626     quadRitem-\/>TexTransform = MathHelper::Identity4x4();}
\DoxyCodeLine{01627     quadRitem-\/>ObjCBIndex = 1;}
\DoxyCodeLine{01628     quadRitem-\/>Mat = mMaterials[\textcolor{stringliteral}{"{}bricks0"{}}].get();}
\DoxyCodeLine{01629     quadRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}shapeGeo"{}}].get();}
\DoxyCodeLine{01630     quadRitem-\/>PrimitiveType = D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{01631     quadRitem-\/>IndexCount = quadRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}quad"{}}].IndexCount;}
\DoxyCodeLine{01632     quadRitem-\/>StartIndexLocation = quadRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}quad"{}}].StartIndexLocation;}
\DoxyCodeLine{01633     quadRitem-\/>BaseVertexLocation = quadRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}quad"{}}].BaseVertexLocation;}
\DoxyCodeLine{01634 }
\DoxyCodeLine{01635     mRitemLayer[(int)RenderLayer::Debug].push\_back(quadRitem.get());}
\DoxyCodeLine{01636     mAllRitems.push\_back(std::move(quadRitem));}
\DoxyCodeLine{01637     }
\DoxyCodeLine{01638     \textcolor{keyword}{auto} boxRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{01639     XMStoreFloat4x4(\&boxRitem-\/>World, XMMatrixScaling(2.0f, 1.0f, 2.0f)*XMMatrixTranslation(0.0f, 0.5f, 0.0f));}
\DoxyCodeLine{01640     XMStoreFloat4x4(\&boxRitem-\/>TexTransform, XMMatrixScaling(1.0f, 1.0f, 1.0f));}
\DoxyCodeLine{01641     boxRitem-\/>ObjCBIndex = 2;}
\DoxyCodeLine{01642     boxRitem-\/>Mat = mMaterials[\textcolor{stringliteral}{"{}bricks0"{}}].get();}
\DoxyCodeLine{01643     boxRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}shapeGeo"{}}].get();}
\DoxyCodeLine{01644     boxRitem-\/>PrimitiveType = D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{01645     boxRitem-\/>IndexCount = boxRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}].IndexCount;}
\DoxyCodeLine{01646     boxRitem-\/>StartIndexLocation = boxRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}].StartIndexLocation;}
\DoxyCodeLine{01647     boxRitem-\/>BaseVertexLocation = boxRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}].BaseVertexLocation;}
\DoxyCodeLine{01648 }
\DoxyCodeLine{01649     mRitemLayer[(int)RenderLayer::Opaque].push\_back(boxRitem.get());}
\DoxyCodeLine{01650     mAllRitems.push\_back(std::move(boxRitem));}
\DoxyCodeLine{01651 }
\DoxyCodeLine{01652     \textcolor{keyword}{auto} gridRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{01653     gridRitem-\/>World = MathHelper::Identity4x4();}
\DoxyCodeLine{01654     XMStoreFloat4x4(\&gridRitem-\/>TexTransform, XMMatrixScaling(8.0f, 8.0f, 1.0f));}
\DoxyCodeLine{01655     gridRitem-\/>ObjCBIndex = 3;}
\DoxyCodeLine{01656     gridRitem-\/>Mat = mMaterials[\textcolor{stringliteral}{"{}tile0"{}}].get();}
\DoxyCodeLine{01657     gridRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}shapeGeo"{}}].get();}
\DoxyCodeLine{01658     gridRitem-\/>PrimitiveType = D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{01659     gridRitem-\/>IndexCount = gridRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}].IndexCount;}
\DoxyCodeLine{01660     gridRitem-\/>StartIndexLocation = gridRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}].StartIndexLocation;}
\DoxyCodeLine{01661     gridRitem-\/>BaseVertexLocation = gridRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}].BaseVertexLocation;}
\DoxyCodeLine{01662 }
\DoxyCodeLine{01663     mRitemLayer[(int)RenderLayer::Opaque].push\_back(gridRitem.get());}
\DoxyCodeLine{01664     mAllRitems.push\_back(std::move(gridRitem));}
\DoxyCodeLine{01665 }
\DoxyCodeLine{01666     XMMATRIX brickTexTransform = XMMatrixScaling(1.5f, 2.0f, 1.0f);}
\DoxyCodeLine{01667     UINT objCBIndex = 4;}
\DoxyCodeLine{01668     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 5; ++i)}
\DoxyCodeLine{01669     \{}
\DoxyCodeLine{01670         \textcolor{keyword}{auto} leftCylRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{01671         \textcolor{keyword}{auto} rightCylRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{01672         \textcolor{keyword}{auto} leftSphereRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{01673         \textcolor{keyword}{auto} rightSphereRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{01674 }
\DoxyCodeLine{01675         XMMATRIX leftCylWorld = XMMatrixTranslation(-\/5.0f, 1.5f, -\/10.0f + i*5.0f);}
\DoxyCodeLine{01676         XMMATRIX rightCylWorld = XMMatrixTranslation(+5.0f, 1.5f, -\/10.0f + i*5.0f);}
\DoxyCodeLine{01677 }
\DoxyCodeLine{01678         XMMATRIX leftSphereWorld = XMMatrixTranslation(-\/5.0f, 3.5f, -\/10.0f + i*5.0f);}
\DoxyCodeLine{01679         XMMATRIX rightSphereWorld = XMMatrixTranslation(+5.0f, 3.5f, -\/10.0f + i*5.0f);}
\DoxyCodeLine{01680 }
\DoxyCodeLine{01681         XMStoreFloat4x4(\&leftCylRitem-\/>World, rightCylWorld);}
\DoxyCodeLine{01682         XMStoreFloat4x4(\&leftCylRitem-\/>TexTransform, brickTexTransform);}
\DoxyCodeLine{01683         leftCylRitem-\/>ObjCBIndex = objCBIndex++;}
\DoxyCodeLine{01684         leftCylRitem-\/>Mat = mMaterials[\textcolor{stringliteral}{"{}bricks0"{}}].get();}
\DoxyCodeLine{01685         leftCylRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}shapeGeo"{}}].get();}
\DoxyCodeLine{01686         leftCylRitem-\/>PrimitiveType = D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{01687         leftCylRitem-\/>IndexCount = leftCylRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}cylinder"{}}].IndexCount;}
\DoxyCodeLine{01688         leftCylRitem-\/>StartIndexLocation = leftCylRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}cylinder"{}}].StartIndexLocation;}
\DoxyCodeLine{01689         leftCylRitem-\/>BaseVertexLocation = leftCylRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}cylinder"{}}].BaseVertexLocation;}
\DoxyCodeLine{01690 }
\DoxyCodeLine{01691         XMStoreFloat4x4(\&rightCylRitem-\/>World, leftCylWorld);}
\DoxyCodeLine{01692         XMStoreFloat4x4(\&rightCylRitem-\/>TexTransform, brickTexTransform);}
\DoxyCodeLine{01693         rightCylRitem-\/>ObjCBIndex = objCBIndex++;}
\DoxyCodeLine{01694         rightCylRitem-\/>Mat = mMaterials[\textcolor{stringliteral}{"{}bricks0"{}}].get();}
\DoxyCodeLine{01695         rightCylRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}shapeGeo"{}}].get();}
\DoxyCodeLine{01696         rightCylRitem-\/>PrimitiveType = D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{01697         rightCylRitem-\/>IndexCount = rightCylRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}cylinder"{}}].IndexCount;}
\DoxyCodeLine{01698         rightCylRitem-\/>StartIndexLocation = rightCylRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}cylinder"{}}].StartIndexLocation;}
\DoxyCodeLine{01699         rightCylRitem-\/>BaseVertexLocation = rightCylRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}cylinder"{}}].BaseVertexLocation;}
\DoxyCodeLine{01700 }
\DoxyCodeLine{01701         XMStoreFloat4x4(\&leftSphereRitem-\/>World, leftSphereWorld);}
\DoxyCodeLine{01702         leftSphereRitem-\/>TexTransform = MathHelper::Identity4x4();}
\DoxyCodeLine{01703         leftSphereRitem-\/>ObjCBIndex = objCBIndex++;}
\DoxyCodeLine{01704         leftSphereRitem-\/>Mat = mMaterials[\textcolor{stringliteral}{"{}mirror0"{}}].get();}
\DoxyCodeLine{01705         leftSphereRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}shapeGeo"{}}].get();}
\DoxyCodeLine{01706         leftSphereRitem-\/>PrimitiveType = D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{01707         leftSphereRitem-\/>IndexCount = leftSphereRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}sphere"{}}].IndexCount;}
\DoxyCodeLine{01708         leftSphereRitem-\/>StartIndexLocation = leftSphereRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}sphere"{}}].StartIndexLocation;}
\DoxyCodeLine{01709         leftSphereRitem-\/>BaseVertexLocation = leftSphereRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}sphere"{}}].BaseVertexLocation;}
\DoxyCodeLine{01710 }
\DoxyCodeLine{01711         XMStoreFloat4x4(\&rightSphereRitem-\/>World, rightSphereWorld);}
\DoxyCodeLine{01712         rightSphereRitem-\/>TexTransform = MathHelper::Identity4x4();}
\DoxyCodeLine{01713         rightSphereRitem-\/>ObjCBIndex = objCBIndex++;}
\DoxyCodeLine{01714         rightSphereRitem-\/>Mat = mMaterials[\textcolor{stringliteral}{"{}mirror0"{}}].get();}
\DoxyCodeLine{01715         rightSphereRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}shapeGeo"{}}].get();}
\DoxyCodeLine{01716         rightSphereRitem-\/>PrimitiveType = D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{01717         rightSphereRitem-\/>IndexCount = rightSphereRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}sphere"{}}].IndexCount;}
\DoxyCodeLine{01718         rightSphereRitem-\/>StartIndexLocation = rightSphereRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}sphere"{}}].StartIndexLocation;}
\DoxyCodeLine{01719         rightSphereRitem-\/>BaseVertexLocation = rightSphereRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}sphere"{}}].BaseVertexLocation;}
\DoxyCodeLine{01720 }
\DoxyCodeLine{01721         mRitemLayer[(int)RenderLayer::Opaque].push\_back(leftCylRitem.get());}
\DoxyCodeLine{01722         mRitemLayer[(int)RenderLayer::Opaque].push\_back(rightCylRitem.get());}
\DoxyCodeLine{01723         mRitemLayer[(int)RenderLayer::Opaque].push\_back(leftSphereRitem.get());}
\DoxyCodeLine{01724         mRitemLayer[(int)RenderLayer::Opaque].push\_back(rightSphereRitem.get());}
\DoxyCodeLine{01725 }
\DoxyCodeLine{01726         mAllRitems.push\_back(std::move(leftCylRitem));}
\DoxyCodeLine{01727         mAllRitems.push\_back(std::move(rightCylRitem));}
\DoxyCodeLine{01728         mAllRitems.push\_back(std::move(leftSphereRitem));}
\DoxyCodeLine{01729         mAllRitems.push\_back(std::move(rightSphereRitem));}
\DoxyCodeLine{01730     \}}
\DoxyCodeLine{01731 }
\DoxyCodeLine{01732     \textcolor{keywordflow}{for}(UINT i = 0; i < mSkinnedMats.size(); ++i)}
\DoxyCodeLine{01733     \{}
\DoxyCodeLine{01734         std::string submeshName = \textcolor{stringliteral}{"{}sm\_"{}} + std::to\_string(i);}
\DoxyCodeLine{01735 }
\DoxyCodeLine{01736         \textcolor{keyword}{auto} ritem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{01737 }
\DoxyCodeLine{01738         \textcolor{comment}{// Reflect to change coordinate system from the RHS the data was exported out as.}}
\DoxyCodeLine{01739         XMMATRIX modelScale = XMMatrixScaling(0.05f, 0.05f, -\/0.05f);}
\DoxyCodeLine{01740         XMMATRIX modelRot = XMMatrixRotationY(MathHelper::Pi);}
\DoxyCodeLine{01741         XMMATRIX modelOffset = XMMatrixTranslation(0.0f, 0.0f, -\/5.0f);}
\DoxyCodeLine{01742         XMStoreFloat4x4(\&ritem-\/>World, modelScale*modelRot*modelOffset);}
\DoxyCodeLine{01743 }
\DoxyCodeLine{01744         ritem-\/>TexTransform = MathHelper::Identity4x4();}
\DoxyCodeLine{01745         ritem-\/>ObjCBIndex = objCBIndex++;}
\DoxyCodeLine{01746         ritem-\/>Mat = mMaterials[mSkinnedMats[i].Name].get();}
\DoxyCodeLine{01747         ritem-\/>Geo = mGeometries[mSkinnedModelFilename].get();}
\DoxyCodeLine{01748         ritem-\/>PrimitiveType = D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{01749         ritem-\/>IndexCount = ritem-\/>Geo-\/>DrawArgs[submeshName].IndexCount;}
\DoxyCodeLine{01750         ritem-\/>StartIndexLocation = ritem-\/>Geo-\/>DrawArgs[submeshName].StartIndexLocation;}
\DoxyCodeLine{01751         ritem-\/>BaseVertexLocation = ritem-\/>Geo-\/>DrawArgs[submeshName].BaseVertexLocation;}
\DoxyCodeLine{01752 }
\DoxyCodeLine{01753         \textcolor{comment}{// All render items for this solider.m3d instance share}}
\DoxyCodeLine{01754         \textcolor{comment}{// the same skinned model instance.}}
\DoxyCodeLine{01755         ritem-\/>SkinnedCBIndex = 0;}
\DoxyCodeLine{01756         ritem-\/>SkinnedModelInst = mSkinnedModelInst.get();}
\DoxyCodeLine{01757 }
\DoxyCodeLine{01758         mRitemLayer[(int)RenderLayer::SkinnedOpaque].push\_back(ritem.get());}
\DoxyCodeLine{01759         mAllRitems.push\_back(std::move(ritem));}
\DoxyCodeLine{01760     \}}
\DoxyCodeLine{01761 \}}
\DoxyCodeLine{01762 }
\DoxyCodeLine{01763 \textcolor{keywordtype}{void} SkinnedMeshApp::DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems)}
\DoxyCodeLine{01764 \{}
\DoxyCodeLine{01765     UINT objCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(ObjectConstants));}
\DoxyCodeLine{01766     UINT skinnedCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(SkinnedConstants));}
\DoxyCodeLine{01767 }
\DoxyCodeLine{01768     \textcolor{keyword}{auto} objectCB = mCurrFrameResource-\/>ObjectCB-\/>Resource();}
\DoxyCodeLine{01769     \textcolor{keyword}{auto} skinnedCB = mCurrFrameResource-\/>SkinnedCB-\/>Resource();}
\DoxyCodeLine{01770 }
\DoxyCodeLine{01771     \textcolor{comment}{// For each render item...}}
\DoxyCodeLine{01772     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < ritems.size(); ++i)}
\DoxyCodeLine{01773     \{}
\DoxyCodeLine{01774         \textcolor{keyword}{auto} ri = ritems[i];}
\DoxyCodeLine{01775 }
\DoxyCodeLine{01776         cmdList-\/>IASetVertexBuffers(0, 1, \&ri-\/>Geo-\/>VertexBufferView());}
\DoxyCodeLine{01777         cmdList-\/>IASetIndexBuffer(\&ri-\/>Geo-\/>IndexBufferView());}
\DoxyCodeLine{01778         cmdList-\/>IASetPrimitiveTopology(ri-\/>PrimitiveType);}
\DoxyCodeLine{01779 }
\DoxyCodeLine{01780         D3D12\_GPU\_VIRTUAL\_ADDRESS objCBAddress = objectCB-\/>GetGPUVirtualAddress() + ri-\/>ObjCBIndex*objCBByteSize;}
\DoxyCodeLine{01781 }
\DoxyCodeLine{01782         cmdList-\/>SetGraphicsRootConstantBufferView(0, objCBAddress);}
\DoxyCodeLine{01783 }
\DoxyCodeLine{01784         \textcolor{keywordflow}{if}(ri-\/>SkinnedModelInst != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{01785         \{}
\DoxyCodeLine{01786             D3D12\_GPU\_VIRTUAL\_ADDRESS skinnedCBAddress = skinnedCB-\/>GetGPUVirtualAddress() + ri-\/>SkinnedCBIndex*skinnedCBByteSize;}
\DoxyCodeLine{01787             cmdList-\/>SetGraphicsRootConstantBufferView(1, skinnedCBAddress);}
\DoxyCodeLine{01788         \}}
\DoxyCodeLine{01789         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01790         \{}
\DoxyCodeLine{01791             cmdList-\/>SetGraphicsRootConstantBufferView(1, 0);}
\DoxyCodeLine{01792         \}}
\DoxyCodeLine{01793 }
\DoxyCodeLine{01794         cmdList-\/>DrawIndexedInstanced(ri-\/>IndexCount, 1, ri-\/>StartIndexLocation, ri-\/>BaseVertexLocation, 0);}
\DoxyCodeLine{01795     \}}
\DoxyCodeLine{01796 \}}
\DoxyCodeLine{01797 }
\DoxyCodeLine{01798 \textcolor{keywordtype}{void} SkinnedMeshApp::DrawSceneToShadowMap()}
\DoxyCodeLine{01799 \{}
\DoxyCodeLine{01800     mCommandList-\/>RSSetViewports(1, \&mShadowMap-\/>Viewport());}
\DoxyCodeLine{01801     mCommandList-\/>RSSetScissorRects(1, \&mShadowMap-\/>ScissorRect());}
\DoxyCodeLine{01802 }
\DoxyCodeLine{01803     \textcolor{comment}{// Change to DEPTH\_WRITE.}}
\DoxyCodeLine{01804     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mShadowMap-\/>Resource(),}
\DoxyCodeLine{01805         D3D12\_RESOURCE\_STATE\_GENERIC\_READ, D3D12\_RESOURCE\_STATE\_DEPTH\_WRITE));}
\DoxyCodeLine{01806 }
\DoxyCodeLine{01807     \textcolor{comment}{// Clear the back buffer and depth buffer.}}
\DoxyCodeLine{01808     mCommandList-\/>ClearDepthStencilView(mShadowMap-\/>Dsv(), }
\DoxyCodeLine{01809         D3D12\_CLEAR\_FLAG\_DEPTH | D3D12\_CLEAR\_FLAG\_STENCIL, 1.0f, 0, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{01810 }
\DoxyCodeLine{01811     \textcolor{comment}{// Specify the buffers we are going to render to.}}
\DoxyCodeLine{01812     mCommandList-\/>OMSetRenderTargets(0, \textcolor{keyword}{nullptr}, \textcolor{keyword}{false}, \&mShadowMap-\/>Dsv());}
\DoxyCodeLine{01813 }
\DoxyCodeLine{01814     \textcolor{comment}{// Bind the pass constant buffer for the shadow map pass.}}
\DoxyCodeLine{01815     UINT passCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(PassConstants));}
\DoxyCodeLine{01816     \textcolor{keyword}{auto} passCB = mCurrFrameResource-\/>PassCB-\/>Resource();}
\DoxyCodeLine{01817     D3D12\_GPU\_VIRTUAL\_ADDRESS passCBAddress = passCB-\/>GetGPUVirtualAddress() + 1*passCBByteSize;}
\DoxyCodeLine{01818     mCommandList-\/>SetGraphicsRootConstantBufferView(2, passCBAddress);}
\DoxyCodeLine{01819 }
\DoxyCodeLine{01820     mCommandList-\/>SetPipelineState(mPSOs[\textcolor{stringliteral}{"{}shadow\_opaque"{}}].Get());}
\DoxyCodeLine{01821     DrawRenderItems(mCommandList.Get(), mRitemLayer[(\textcolor{keywordtype}{int})RenderLayer::Opaque]);}
\DoxyCodeLine{01822 }
\DoxyCodeLine{01823     mCommandList-\/>SetPipelineState(mPSOs[\textcolor{stringliteral}{"{}skinnedShadow\_opaque"{}}].Get());}
\DoxyCodeLine{01824     DrawRenderItems(mCommandList.Get(), mRitemLayer[(\textcolor{keywordtype}{int})RenderLayer::SkinnedOpaque]);}
\DoxyCodeLine{01825 }
\DoxyCodeLine{01826     \textcolor{comment}{// Change back to GENERIC\_READ so we can read the texture in a shader.}}
\DoxyCodeLine{01827     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(mShadowMap-\/>Resource(),}
\DoxyCodeLine{01828         D3D12\_RESOURCE\_STATE\_DEPTH\_WRITE, D3D12\_RESOURCE\_STATE\_GENERIC\_READ));}
\DoxyCodeLine{01829 \}}
\DoxyCodeLine{01830  }
\DoxyCodeLine{01831 \textcolor{keywordtype}{void} SkinnedMeshApp::DrawNormalsAndDepth()}
\DoxyCodeLine{01832 \{}
\DoxyCodeLine{01833     mCommandList-\/>RSSetViewports(1, \&mScreenViewport);}
\DoxyCodeLine{01834     mCommandList-\/>RSSetScissorRects(1, \&mScissorRect);}
\DoxyCodeLine{01835 }
\DoxyCodeLine{01836     \textcolor{keyword}{auto} normalMap = mSsao-\/>NormalMap();}
\DoxyCodeLine{01837     \textcolor{keyword}{auto} normalMapRtv = mSsao-\/>NormalMapRtv();}
\DoxyCodeLine{01838     }
\DoxyCodeLine{01839     \textcolor{comment}{// Change to RENDER\_TARGET.}}
\DoxyCodeLine{01840     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(normalMap,}
\DoxyCodeLine{01841         D3D12\_RESOURCE\_STATE\_GENERIC\_READ, D3D12\_RESOURCE\_STATE\_RENDER\_TARGET));}
\DoxyCodeLine{01842 }
\DoxyCodeLine{01843     \textcolor{comment}{// Clear the screen normal map and depth buffer.}}
\DoxyCodeLine{01844     \textcolor{keywordtype}{float} clearValue[] = \{0.0f, 0.0f, 1.0f, 0.0f\};}
\DoxyCodeLine{01845     mCommandList-\/>ClearRenderTargetView(normalMapRtv, clearValue, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{01846     mCommandList-\/>ClearDepthStencilView(DepthStencilView(), D3D12\_CLEAR\_FLAG\_DEPTH | D3D12\_CLEAR\_FLAG\_STENCIL, 1.0f, 0, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{01847 }
\DoxyCodeLine{01848     \textcolor{comment}{// Specify the buffers we are going to render to.}}
\DoxyCodeLine{01849     mCommandList-\/>OMSetRenderTargets(1, \&normalMapRtv, \textcolor{keyword}{true}, \&DepthStencilView());}
\DoxyCodeLine{01850 }
\DoxyCodeLine{01851     \textcolor{comment}{// Bind the constant buffer for this pass.}}
\DoxyCodeLine{01852     \textcolor{keyword}{auto} passCB = mCurrFrameResource-\/>PassCB-\/>Resource();}
\DoxyCodeLine{01853     mCommandList-\/>SetGraphicsRootConstantBufferView(2, passCB-\/>GetGPUVirtualAddress());}
\DoxyCodeLine{01854 }
\DoxyCodeLine{01855     mCommandList-\/>SetPipelineState(mPSOs[\textcolor{stringliteral}{"{}drawNormals"{}}].Get());}
\DoxyCodeLine{01856     DrawRenderItems(mCommandList.Get(), mRitemLayer[(\textcolor{keywordtype}{int})RenderLayer::Opaque]);}
\DoxyCodeLine{01857 }
\DoxyCodeLine{01858     mCommandList-\/>SetPipelineState(mPSOs[\textcolor{stringliteral}{"{}skinnedDrawNormals"{}}].Get());}
\DoxyCodeLine{01859     DrawRenderItems(mCommandList.Get(), mRitemLayer[(\textcolor{keywordtype}{int})RenderLayer::SkinnedOpaque]);}
\DoxyCodeLine{01860 }
\DoxyCodeLine{01861     \textcolor{comment}{// Change back to GENERIC\_READ so we can read the texture in a shader.}}
\DoxyCodeLine{01862     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(normalMap,}
\DoxyCodeLine{01863         D3D12\_RESOURCE\_STATE\_RENDER\_TARGET, D3D12\_RESOURCE\_STATE\_GENERIC\_READ));}
\DoxyCodeLine{01864 \}}
\DoxyCodeLine{01865 CD3DX12\_CPU\_DESCRIPTOR\_HANDLE SkinnedMeshApp::GetCpuSrv(\textcolor{keywordtype}{int} index)\textcolor{keyword}{const}}
\DoxyCodeLine{01866 \textcolor{keyword}{}\{}
\DoxyCodeLine{01867     \textcolor{keyword}{auto} srv = CD3DX12\_CPU\_DESCRIPTOR\_HANDLE(mSrvDescriptorHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{01868     srv.Offset(index, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{01869     \textcolor{keywordflow}{return} srv;}
\DoxyCodeLine{01870 \}}
\DoxyCodeLine{01871 }
\DoxyCodeLine{01872 CD3DX12\_GPU\_DESCRIPTOR\_HANDLE SkinnedMeshApp::GetGpuSrv(\textcolor{keywordtype}{int} index)\textcolor{keyword}{const}}
\DoxyCodeLine{01873 \textcolor{keyword}{}\{}
\DoxyCodeLine{01874     \textcolor{keyword}{auto} srv = CD3DX12\_GPU\_DESCRIPTOR\_HANDLE(mSrvDescriptorHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{01875     srv.Offset(index, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{01876     \textcolor{keywordflow}{return} srv;}
\DoxyCodeLine{01877 \}}
\DoxyCodeLine{01878 }
\DoxyCodeLine{01879 CD3DX12\_CPU\_DESCRIPTOR\_HANDLE SkinnedMeshApp::GetDsv(\textcolor{keywordtype}{int} index)\textcolor{keyword}{const}}
\DoxyCodeLine{01880 \textcolor{keyword}{}\{}
\DoxyCodeLine{01881     \textcolor{keyword}{auto} dsv = CD3DX12\_CPU\_DESCRIPTOR\_HANDLE(mDsvHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{01882     dsv.Offset(index, mDsvDescriptorSize);}
\DoxyCodeLine{01883     \textcolor{keywordflow}{return} dsv;}
\DoxyCodeLine{01884 \}}
\DoxyCodeLine{01885 }
\DoxyCodeLine{01886 CD3DX12\_CPU\_DESCRIPTOR\_HANDLE SkinnedMeshApp::GetRtv(\textcolor{keywordtype}{int} index)\textcolor{keyword}{const}}
\DoxyCodeLine{01887 \textcolor{keyword}{}\{}
\DoxyCodeLine{01888     \textcolor{keyword}{auto} rtv = CD3DX12\_CPU\_DESCRIPTOR\_HANDLE(mRtvHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{01889     rtv.Offset(index, mRtvDescriptorSize);}
\DoxyCodeLine{01890     \textcolor{keywordflow}{return} rtv;}
\DoxyCodeLine{01891 \}}
\DoxyCodeLine{01892 }
\DoxyCodeLine{01893 std::array<const CD3DX12\_STATIC\_SAMPLER\_DESC, 7> SkinnedMeshApp::GetStaticSamplers()}
\DoxyCodeLine{01894 \{}
\DoxyCodeLine{01895     \textcolor{comment}{// Applications usually only need a handful of samplers.  So just define them all up front}}
\DoxyCodeLine{01896     \textcolor{comment}{// and keep them available as part of the root signature.  }}
\DoxyCodeLine{01897 }
\DoxyCodeLine{01898     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC pointWrap(}
\DoxyCodeLine{01899         0, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{01900         D3D12\_FILTER\_MIN\_MAG\_MIP\_POINT, \textcolor{comment}{// filter}}
\DoxyCodeLine{01901         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{01902         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{01903         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{01904 }
\DoxyCodeLine{01905     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC pointClamp(}
\DoxyCodeLine{01906         1, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{01907         D3D12\_FILTER\_MIN\_MAG\_MIP\_POINT, \textcolor{comment}{// filter}}
\DoxyCodeLine{01908         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{01909         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{01910         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{01911 }
\DoxyCodeLine{01912     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC linearWrap(}
\DoxyCodeLine{01913         2, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{01914         D3D12\_FILTER\_MIN\_MAG\_MIP\_LINEAR, \textcolor{comment}{// filter}}
\DoxyCodeLine{01915         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{01916         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{01917         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{01918 }
\DoxyCodeLine{01919     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC linearClamp(}
\DoxyCodeLine{01920         3, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{01921         D3D12\_FILTER\_MIN\_MAG\_MIP\_LINEAR, \textcolor{comment}{// filter}}
\DoxyCodeLine{01922         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{01923         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{01924         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP); \textcolor{comment}{// addressW}}
\DoxyCodeLine{01925 }
\DoxyCodeLine{01926     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC anisotropicWrap(}
\DoxyCodeLine{01927         4, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{01928         D3D12\_FILTER\_ANISOTROPIC, \textcolor{comment}{// filter}}
\DoxyCodeLine{01929         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{01930         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{01931         D3D12\_TEXTURE\_ADDRESS\_MODE\_WRAP,  \textcolor{comment}{// addressW}}
\DoxyCodeLine{01932         0.0f,                             \textcolor{comment}{// mipLODBias}}
\DoxyCodeLine{01933         8);                               \textcolor{comment}{// maxAnisotropy}}
\DoxyCodeLine{01934 }
\DoxyCodeLine{01935     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC anisotropicClamp(}
\DoxyCodeLine{01936         5, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{01937         D3D12\_FILTER\_ANISOTROPIC, \textcolor{comment}{// filter}}
\DoxyCodeLine{01938         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{01939         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{01940         D3D12\_TEXTURE\_ADDRESS\_MODE\_CLAMP,  \textcolor{comment}{// addressW}}
\DoxyCodeLine{01941         0.0f,                              \textcolor{comment}{// mipLODBias}}
\DoxyCodeLine{01942         8);                                \textcolor{comment}{// maxAnisotropy}}
\DoxyCodeLine{01943 }
\DoxyCodeLine{01944     \textcolor{keyword}{const} CD3DX12\_STATIC\_SAMPLER\_DESC shadow(}
\DoxyCodeLine{01945         6, \textcolor{comment}{// shaderRegister}}
\DoxyCodeLine{01946         D3D12\_FILTER\_COMPARISON\_MIN\_MAG\_LINEAR\_MIP\_POINT, \textcolor{comment}{// filter}}
\DoxyCodeLine{01947         D3D12\_TEXTURE\_ADDRESS\_MODE\_BORDER,  \textcolor{comment}{// addressU}}
\DoxyCodeLine{01948         D3D12\_TEXTURE\_ADDRESS\_MODE\_BORDER,  \textcolor{comment}{// addressV}}
\DoxyCodeLine{01949         D3D12\_TEXTURE\_ADDRESS\_MODE\_BORDER,  \textcolor{comment}{// addressW}}
\DoxyCodeLine{01950         0.0f,                               \textcolor{comment}{// mipLODBias}}
\DoxyCodeLine{01951         16,                                 \textcolor{comment}{// maxAnisotropy}}
\DoxyCodeLine{01952         D3D12\_COMPARISON\_FUNC\_LESS\_EQUAL,}
\DoxyCodeLine{01953         D3D12\_STATIC\_BORDER\_COLOR\_OPAQUE\_BLACK);}
\DoxyCodeLine{01954 }
\DoxyCodeLine{01955     \textcolor{keywordflow}{return} \{ }
\DoxyCodeLine{01956         pointWrap, pointClamp,}
\DoxyCodeLine{01957         linearWrap, linearClamp, }
\DoxyCodeLine{01958         anisotropicWrap, anisotropicClamp,}
\DoxyCodeLine{01959         shadow }
\DoxyCodeLine{01960     \};}
\DoxyCodeLine{01961 \}}
\DoxyCodeLine{01962 }

\end{DoxyCode}
